<!DOCTYPE html>
<html lang="en">
<head>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-0VYPT117FS"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'G-0VYPT117FS');
    </script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Minds Matter</title>
    <link href="https://fonts.googleapis.com/css2?family=DM+Sans:wght@400;500;700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        :root { --bg-primary:#0d1117; --bg-secondary:#161b22; --bg-tertiary:#21262d; --text-primary:#e6edf3; --text-secondary:#8b949e; --text-muted:#6e7681; --border:#30363d; --accent:#58a6ff; --accent-subtle:#1f6feb; }
        * { margin:0; padding:0; box-sizing:border-box; }
        body { font-family:'DM Sans',sans-serif; background:var(--bg-primary); color:var(--text-primary); line-height:1.6; }
        h4 { font-weight:400; }
        .hamburger { position:fixed; top:1rem; right:1rem; z-index:1000; background:var(--bg-secondary); border:1px solid var(--border); border-radius:8px; padding:0.75rem; cursor:pointer; display:flex; flex-direction:column; gap:4px; }
        .hamburger span { display:block; width:20px; height:2px; background:var(--text-primary); transition:0.3s; }
        .hamburger.active span:nth-child(1) { transform:rotate(45deg) translate(4px,4px); }
        .hamburger.active span:nth-child(2) { opacity:0; }
        .hamburger.active span:nth-child(3) { transform:rotate(-45deg) translate(4px,-4px); }
        .side-panel { position:fixed; top:0; right:-480px; width:480px; max-width:95vw; height:100vh; background:var(--bg-secondary); border-left:1px solid var(--border); z-index:999; transition:right 0.3s; overflow-y:auto; padding:1.5rem; }
        .side-panel.active { right:0; }
        .side-panel-overlay { position:fixed; inset:0; background:rgba(0,0,0,0.5); z-index:998; opacity:0; visibility:hidden; transition:0.3s; }
        .side-panel-overlay.active { opacity:1; visibility:visible; }
        .side-panel h2 { margin-bottom:1rem; color:var(--accent); font-size:1.3rem; }
        .side-panel h3 { margin-top:1.25rem; margin-bottom:0.5rem; color:var(--accent); font-size:1rem; }
        .side-panel p { color:var(--text-secondary); margin-bottom:0.5rem; font-size:0.9rem; }
        .side-panel table { width:100%; font-size:0.85rem; margin:0.5rem 0; border-collapse:collapse; }
        .side-panel th, .side-panel td { padding:0.4rem 0.5rem; text-align:left; border-bottom:1px solid var(--border); }
        .side-panel th { color:var(--text-muted); font-weight:500; }
        .side-panel a { color:var(--accent); }
        .container { max-width:1400px; margin:0 auto; padding:2rem; }
        header { text-align:center; margin-bottom:2rem; padding-bottom:2rem; border-bottom:1px solid var(--border); }
        h1 { font-size:2.5rem; font-weight:700; margin-bottom:0.5rem; color:var(--accent); }
        .subtitle { color:var(--text-secondary); font-size:1.1rem; margin:0; }
        .citation-box { background:var(--bg-tertiary); padding:0.75rem 1.25rem; border-radius:8px; margin:1.25rem 0 0; font-size:0.95rem; color:var(--text-secondary); border:1px solid var(--border); text-align:center; }
        .citation-box a { color:var(--accent); text-decoration:none; display:block; margin-top:0.25rem; }
        .citation-box a:hover { text-decoration:underline; }
        .subtitle-wrapper { display:inline-block; text-align:center; }
        .stats-bar { display:flex; justify-content:center; gap:2rem; margin-top:1.5rem; flex-wrap:wrap; }
        .stat { background:var(--bg-secondary); padding:0.75rem 1.5rem; border-radius:8px; border:1px solid var(--border); }
        .stat-value { font-size:1.5rem; font-weight:700; color:var(--accent); }
        .stat-label { font-size:0.85rem; color:var(--text-secondary); }
        .tabs { display:flex; gap:0.5rem; margin-bottom:2rem; flex-wrap:wrap; justify-content:center; }
        .tab { padding:0.75rem 1.5rem; background:var(--bg-secondary); border:1px solid var(--border); border-radius:8px; cursor:pointer; font-family:inherit; font-size:0.95rem; color:var(--text-secondary); transition:0.2s; }
        .tab:hover { background:var(--bg-tertiary); color:var(--text-primary); }
        .tab.active { background:var(--accent-subtle); border-color:var(--accent); color:var(--text-primary); }
        .panel { display:none; } .panel.active { display:block; }
        .controls { background:var(--bg-secondary); padding:1.5rem; border-radius:12px; margin-bottom:2rem; border:1px solid var(--border); }
        .control-row { display:flex; gap:1rem; flex-wrap:wrap; align-items:flex-start; margin-bottom:1rem; }
        .control-row:last-child { margin-bottom:0; }
        .control-group { flex:1; min-width:200px; }
        .control-group label { display:block; margin-bottom:0.5rem; font-size:0.85rem; color:var(--text-secondary); font-weight:500; }
        select, input[type="text"] { width:100%; padding:0.7rem 1rem; background:var(--bg-tertiary); border:1px solid var(--border); border-radius:8px; color:var(--text-primary); font-family:inherit; font-size:0.95rem; }
        select:focus, input:focus { outline:none; border-color:var(--accent); }
        select optgroup { font-weight:500; color:var(--text-muted); font-style:normal; }
        select option { font-weight:400; color:var(--text-primary); }
        .checkbox-group { background:var(--bg-tertiary); border:1px solid var(--border); border-radius:8px; padding:0.5rem; max-height:none; overflow-y:visible; }
        .checkbox-group.scrollable { max-height:var(--filter-box-height, 220px); overflow-y:auto; }
        .checkbox-group.scrollable.entity-grid { display:grid !important; grid-template-columns:repeat(6, 1fr); gap:0.25rem 0.75rem; }
        .checkbox-group.scrollable.entity-grid .checkbox-item { padding:0.2rem 0.25rem; }
        .checkbox-group.scrollable.entity-grid .checkbox-item.select-all { grid-column: 1 / -1; }
        .control-row { display:flex; gap:1rem; }
        .control-row .control-group { display:flex; flex-direction:column; }
        .control-row .control-group:first-child { flex:1; }
        .control-row .control-group:last-child { flex:1.5; }
        #variable-container .checkbox-group.scrollable { max-height:var(--filter-box-height, 220px); }
        .checkbox-item { display:flex; align-items:center; padding:0.25rem 0.5rem; border-radius:4px; }
        .checkbox-item.sub-question { font-size:0.85rem; }
        .checkbox-item.sub-question label { color:var(--text-secondary); }
        .checkbox-item:hover { background:var(--bg-secondary); }
        .checkbox-item input { margin-right:0.5rem; accent-color:var(--accent); width:16px; height:16px; }
        .checkbox-item label { font-size:0.9rem; cursor:pointer; flex:1; }
        .checkbox-item.select-all { border-bottom:1px solid var(--border); margin-bottom:0.5rem; padding-bottom:0.5rem; }
        .checkbox-item.select-all label { font-weight:600; color:var(--accent); }
        .checkbox-section { font-size:0.75rem; color:var(--text-muted); padding:0.5rem 0.5rem 0.25rem; text-transform:uppercase; letter-spacing:0.5px; }
        .filter-row { display:flex; gap:1.5rem; margin-top:0.5rem; }
        .filter-col { flex:1; display:flex; flex-direction:column; }
        .filter-col-content { flex:1; }
        .split-controls { margin-top:auto; padding-top:0.5rem; border-top:1px dashed var(--border); }
        .split-toggle { display:flex; align-items:center; gap:0.4rem; padding:0.2rem 0.5rem; }
        .split-toggle input { accent-color:#f0a050; width:14px; height:14px; }
        .split-toggle label { font-size:0.8rem; color:var(--text-secondary); cursor:pointer; }
        .split-toggle.disabled { opacity:0.4; }
        .split-toggle.disabled input { pointer-events:none; }
        .split-toggle.disabled label { cursor:not-allowed; }
        .split-note { font-size:0.75rem; color:#f0a050; margin-top:0.25rem; padding:0.25rem 0.5rem; background:rgba(240,160,80,0.1); border-radius:4px; }
        .split-column-header { text-align:center; font-size:0.85rem; font-weight:600; padding:0.5rem; margin-bottom:0.5rem; border-radius:4px; }
        .split-group { border:1px solid var(--border); border-radius:8px; padding:0.5rem; margin-bottom:1rem; }
        .split-group-title { font-size:0.9rem; font-weight:600; color:var(--text-primary); margin-bottom:0.75rem; padding-bottom:0.5rem; border-bottom:1px solid var(--border); }
        .btn { padding:0.7rem 1.5rem; background:var(--accent-subtle); color:var(--text-primary); border:none; border-radius:8px; cursor:pointer; font-family:inherit; font-size:0.95rem; font-weight:500; transition:0.2s; align-self:flex-end; margin-top:auto; }
        .btn:hover { background:var(--accent); }
        .results { background:var(--bg-secondary); border-radius:12px; border:1px solid var(--border); overflow:visible; }
        .results-header { padding:1rem 1.5rem; background:var(--bg-tertiary); border-bottom:1px solid var(--border); border-radius:12px 12px 0 0; }
        .results-header h3 { font-weight:500; font-size:1rem; }
        .results-body { padding:1.5rem; overflow:visible; }
        .chart-container { position:relative; height:500px; margin-bottom:1.5rem; }
        .chart-grid { display:grid; gap:1rem; margin-bottom:1.5rem; width:100%; max-width:100%; overflow:visible; }
        .chart-grid.cols-1 { grid-template-columns:1fr; max-width:500px; margin:0 auto 1.5rem; }
        .chart-grid.cols-2 { grid-template-columns:repeat(2,minmax(0,1fr)); }
        .chart-grid.cols-3 { grid-template-columns:repeat(3,minmax(0,1fr)); }
        .chart-grid.cols-4 { grid-template-columns:repeat(4,minmax(0,1fr)); }
        .chart-cell { overflow:visible; min-width:0; width:100%; box-sizing:border-box; background:var(--bg-tertiary); border-radius:8px; padding:0.75rem; display:flex; flex-direction:column; position:relative; }
        .chart-cell h4 { font-size:1.15rem; margin-bottom:0.5rem; color:var(--text-secondary); text-align:center; white-space:normal; word-wrap:break-word; overflow-wrap:break-word; line-height:1.3; min-height:1.6em; display:flex; align-items:flex-start; justify-content:center; font-weight:400 !important; }
        .chart-grid.cols-4 .chart-cell h4, .chart-grid.cols-3 .chart-cell h4 { min-height:2.6em; }  /* More title height when multiple items */
        .chart-cell.single-item h4 { min-height:auto; margin-bottom:0.25rem; }  /* No min-height for single items */
        .chart-cell.single-item .chart-cell-legend { margin-bottom:0.25rem; }  /* Tighter legend spacing */
        .chart-cell-legend { font-size:0.9rem; display:flex; flex-wrap:wrap; gap:0.4rem; justify-content:center; margin-bottom:0.5rem; padding:0.4rem; background:var(--bg-secondary); border-radius:4px; min-height:1.8em; align-items:center; align-content:center; }
        .chart-cell-legend .legend-color { width:12px; height:12px; border-radius:2px; flex-shrink:0; }
        .chart-cell canvas { max-height:180px; flex:1; margin-top:auto; }
        .chart-cell[data-bar-height] canvas { max-height:none !important; height:100% !important; }
        .hbar-canvas-wrapper { position:relative; overflow:visible; }
        .split-question-row { overflow:visible; }
        #dist-chart-area { overflow:visible; }
        .chart-cell-legend .legend-item { display:flex; align-items:center; gap:0.3rem; line-height:1.4; }
        /* External tooltip for split charts */
        #chartjs-tooltip { position:absolute; background:rgba(0,0,0,0.9); color:#fff; border-radius:6px; padding:8px 12px; font-size:0.85rem; pointer-events:none; z-index:9999; white-space:nowrap; box-shadow:0 2px 8px rgba(0,0,0,0.3); transition:opacity 0.15s ease; }
        #chartjs-tooltip .tooltip-title { font-weight:600; margin-bottom:4px; }
        #chartjs-tooltip .tooltip-body { line-height:1.4; }
        table { width:100%; border-collapse:collapse; font-size:0.9rem; }
        th, td { padding:0.5rem 0.75rem; text-align:left; border-bottom:1px solid var(--border); }
        th { background:var(--bg-tertiary); font-weight:600; color:var(--text-secondary); }
        .suppressed { color:var(--text-muted); font-style:italic; }
        .free-text-list { max-height:500px; overflow-y:auto; }
        .free-text-item { padding:0.75rem; border-bottom:1px solid var(--border); font-size:0.9rem; }
        .free-text-item:hover { background:var(--bg-tertiary); }
        .response-count { background:var(--bg-tertiary); padding:0.2rem 0.6rem; border-radius:100px; font-size:0.8rem; color:var(--text-secondary); margin-left:0.5rem; }
        .crosstab-wrapper { overflow-x:auto; }
        .info-box { background:rgba(88,166,255,0.1); border:1px solid var(--accent); border-radius:8px; padding:1rem; margin-bottom:1.5rem; font-size:0.9rem; }
        .no-data { color:var(--text-muted); font-style:italic; padding:2rem; text-align:center; }
        .filter-badge { display:inline-block; background:var(--accent-subtle); padding:0.15rem 0.5rem; border-radius:100px; font-size:0.75rem; margin-left:0.5rem; }
        .filter-note { display:inline-block; background:rgba(255,166,87,0.2); color:#ffa657; padding:0.15rem 0.5rem; border-radius:100px; font-size:0.75rem; width:fit-content; vertical-align:middle; }
        .filter-note.align-left { display:block; margin-left:0 !important; }
        .filter-note.note-block { display:block; margin-top:0.35rem; margin-left:0 !important; }
        .multiselect-marker { color:#e6edf3; font-weight:bold; }
        .multiselect-note { font-size:0.85rem; color:var(--text-secondary); font-style:italic; margin-top:0.5rem; padding-left:0.25rem; }
        .legend-bar { display:flex; flex-wrap:wrap; gap:0.75rem; justify-content:center; margin-bottom:1rem; padding:0.75rem; border-radius:8px; }
        .legend-bar.with-bg { background:var(--bg-tertiary); }
        .legend-bar .legend-title { font-weight:normal; margin-right:0.5rem; color:var(--text-muted); }
        .legend-bar .legend-item { display:flex; align-items:center; gap:0.35rem; font-size:0.95rem; }
        .legend-bar .legend-color { width:16px; height:16px; border-radius:3px; }
        footer { text-align:center; padding:2rem; margin-top:3rem; border-top:1px solid var(--border); color:var(--text-muted); font-size:0.85rem; }
        @media (max-width:768px) { .container { padding:1rem; } h1 { font-size:1.75rem; } .control-row { flex-direction:column; } .chart-grid.cols-2,.chart-grid.cols-3,.chart-grid.cols-4 { grid-template-columns:repeat(2,1fr); } .filter-row { flex-direction:column; } }
    </style>
</head>
<body>
    <button class="hamburger" id="hamburger"><span></span><span></span><span></span></button>
    <div class="side-panel-overlay" id="overlay"></div>
    <div class="side-panel" id="side-panel">
        <h2>About & Statistics</h2>
        <h3>Survey Overview</h3>
        <p>This explorer shows data collected as part of a survey about the perceived relationship between consciousness and moral status. More information can be found <a href="https://osf.io/preprints/" target="_blank" style="color:#58a6ff;">here</a>.</p>
        <p style="margin-top:0.5rem;">Cite as: <a href="https://doi.org/10.17605/OSF.IO/XXXXX" target="_blank" style="color:#58a6ff;">doi.org/10.17605/OSF.IO/XXXXX</a></p>
        <h3>Survey Statistics</h3>
        <div id="survey-stats-container"></div>
    </div>

    <div class="container">
        <header>
            <h1>Minds Matter</h1>
            <div class="subtitle-wrapper">
                <p class="subtitle">An explorer of results from a survey about the relationship between consciousness and moral status</p>
                <div class="citation-box">Hirschhorn, R., Negro, N., &amp; Mudrik, L. (2026). The perceived role of consciousness in moral status attributions. <a href="https://doi.org/10.17605/OSF.IO/XXXXX" target="_blank">doi.org/10.17605/OSF.IO/XXXXX</a></div>
            </div>
            <div class="stats-bar">
                <div class="stat"><div class="stat-value" id="total-respondents">—</div><div class="stat-label">Respondents</div></div>
                <div class="stat"><div class="stat-value" id="total-questions">&gt;100</div><div class="stat-label">Questions</div></div>
                <div class="stat"><div class="stat-value" id="total-countries">—</div><div class="stat-label">Countries</div></div>
            </div>
        </header>

        <div class="tabs">
            <button class="tab active" data-panel="distributions">Question Data</button>
            <button class="tab" data-panel="crosstabs">Cross Questions <span style="font-size:0.7rem;background:#f0883e;color:#0d1117;padding:0.1rem 0.3rem;border-radius:3px;margin-left:0.3rem;vertical-align:middle;">beta</span></button>
            <!-- Free-Text tab hidden - now integrated into Distributions
            <button class="tab" data-panel="freetext">Free-Text Responses</button>
            -->
        </div>

        <div id="distributions" class="panel active">
            <div class="info-box"><strong>How to use:</strong> Select a <strong>Topic</strong> to explore. Use <strong>Filter Responses</strong> to select which sample phases and recruitment sources to include; and check the <strong>Split by</strong> options if you want to <em>compare</em> the sampled groups instead of collapsing across them. Then select one or more <strong>Questions</strong> to view the response distributions.</div>
            <div class="controls">
                <div class="control-row">
                    <div class="control-group">
                        <label>Topic</label>
                        <select id="dist-category"><option value="">Select a topic...</option></select>
                    </div>
                </div>
                <div id="scenario-text-container" style="display:none;"></div>
                <div class="control-row">
                    <div class="control-group">
                        <label>Filter Responses</label>
                        <div class="checkbox-group" id="sample-filter-box"></div>
                    </div>
                    <div class="control-group" style="flex:1.5;">
                        <label>Question(s)</label>
                        <div id="variable-container"><select id="dist-variable"><option value="">Select a topic first...</option></select></div>
                    </div>
                </div>
                <div id="free-text-container" style="display:none;"></div>
            </div>
            <div class="results" id="dist-results">
                <div class="results-header" style="display:flex;justify-content:space-between;align-items:center;">
                    <h3 id="dist-title">Select a variable to view its distribution</h3>
                    <button id="download-chart-btn" class="btn" style="display:none;padding:0.3rem 0.6rem;font-size:0.8rem;" onclick="downloadCharts()">⬇ Download PNG</button>
                </div>
                <div class="results-body">
                    <div id="dist-legend-area"></div>
                    <div id="dist-chart-area"></div>
                    <div id="dist-table-container"></div>
                    <div id="dist-freetext-area" style="display:none;margin-top:1.5rem;"></div>
                </div>
            </div>
        </div>

        <div id="crosstabs" class="panel">
            <div class="info-box"><strong>How to use:</strong> Cross-tabulate survey questions with demographics, experience levels, or other questions.</div>
            <div class="controls">
                <div class="control-row">
                    <div class="control-group"><label>Variable 1 (rows)</label><select id="cross-var1"><option value="">Select...</option></select></div>
                    <div class="control-group"><label>Variable 2 (columns)</label><select id="cross-var2"><option value="">Select...</option></select></div>
                    <button class="btn" id="cross-show">Show Cross-Tab</button>
                </div>
            </div>
            <div class="results" id="cross-results">
                <div class="results-header"><h3 id="cross-title">Select variables to view cross-tabulation</h3></div>
                <div class="results-body">
                    <div class="chart-container" id="cross-chart-container" style="display:none;"><canvas id="cross-chart"></canvas></div>
                    <div class="crosstab-wrapper" id="cross-table-container"></div>
                </div>
            </div>
        </div>

        <div id="freetext" class="panel">
            <div class="info-box"><strong>Note:</strong> Responses shown in random order without demographic links.</div>
            <div class="controls">
                <div class="control-row">
                    <div class="control-group" style="flex:2;"><label>Question</label><select id="freetext-question"><option value="">Select...</option></select></div>
                    <button class="btn" id="freetext-show">Show Responses</button>
                </div>
            </div>
            <div class="results" id="freetext-results">
                <div class="results-header"><h3 id="freetext-title">Select a question</h3></div>
                <div class="results-body">
                    <div style="margin-bottom:1rem;"><input type="text" id="freetext-search" placeholder="Search responses..."></div>
                    <div class="free-text-list" id="freetext-list"></div>
                </div>
            </div>
        </div>

        <footer>
            <p>&copy; 2025 Rony Hirschhorn</p>
            <p style="margin-top:0.5rem;"><a href="https://creativecommons.org/licenses/by/4.0/" target="_blank" style="color:var(--text-muted);">License: CC-BY 4.0</a></p>
            <p style="margin-top:0.5rem;color:var(--text-muted);">Cite as: <a href="https://doi.org/10.17605/OSF.IO/XXXXX" target="_blank" style="color:var(--text-muted);">doi.org/10.17605/OSF.IO/XXXXX</a></p>
        </footer>
    </div>

<script>
let DATA = {}, charts = {};

// Set Chart.js global defaults for consistent fonts
Chart.defaults.font.family = "'DM Sans', sans-serif";
Chart.defaults.font.size = 12;
Chart.defaults.color = '#8b949e';

// === GLOBAL CONSTANTS ===
const TABLE_MAX_ROWS = 50;  // Max rows to show before pagination

// Standard note messages - use consistently across the app
const NOTE_FOLLOWUP_EXCLUDED = 'NOTE: Data excludes Follow-up sample (not asked this question)';
const NOTE_EXP_SOURCE = 'NOTE: Experience source only includes respondents who rated 3+ on this experience';
const NOTE_NOKILL_REASON = 'NOTE: Only respondents who answered "No" to ALL killing questions were asked this question';
const NOTE_FREE_TEXT_VERBATIM = 'Responses are shown verbatim and in random order';

// Education order (from lowest to highest)
const EDU_ORDER = [
    'No formal education',
    'Primary education',
    'Secondary education (hold a high-school diploma or equivalent)',
    'Post-secondary education (hold a bachelor\'s or associate degree)',
    'Graduate education (hold a master\'s degree or doctoral degree)'
];

// AI Experience source label mapping (add "Practical" prefix)
const EXP_SOURCE_LABEL_MAP = {
    'use AI systems and technologies': 'Practical (use AI systems and technologies)'
};

// Helper to transform experience source labels
function transformExpSourceLabel(label) {
    return EXP_SOURCE_LABEL_MAP[label] || label;
}

// Rating scale for consciousness/moral status attributions (1-4)
const RL = {'1': 'Does Not Have', '2': "Probably Doesn't Have", '3': 'Probably Has', '4': 'Has'};
// Agreement scale for graded consciousness questions - general (1-4)
const AL = {'1': 'Strongly Disagree', '2': 'Disagree', '3': 'Agree', '4': 'Strongly Agree'};
// Graded agreement scale for Equal/Unequal/Incomparable (1-4) - just numbers
const GL = {'1': '1', '2': '2', '3': '3', '4': '4'};
// Experience level scale (1-5)
const EL = {'1': 'None', '2': '2', '3': '3', '4': '4', '5': 'Extremely'};
function RLab(l) { return RL[l] || l; }
function ALab(l) { return AL[l] || l; }
function GLab(l) { return GL[l] || l; }
function ELab(l) { return EL[l] || l; }

// === SPLIT VIEW COLOR CONFIGURATION ===
// Base colors for sample phases
const SPLIT_COLORS = {
    sample: {
        'pre-registered': '#0d3b66',  // Dark blue
        'exploratory': '#0f4c5c',     // Teal
        'follow-up': '#5D5646'        // Brown/olive
    },
    source: {
        'Free': '#735751',            // Warm brown
        'Prolific': '#a53860'          // Deep rose
    },
    // Combined colors for sample + source splits
    combined: {
        'pre-registered_Free': '#1a5080',     // Blue + lighter
        'pre-registered_Prolific': '#0d3b66', // Blue base
        'exploratory_Free': '#1a7080',        // Teal + lighter
        'exploratory_Prolific': '#0f4c5c',    // Teal base
        'follow-up_Free': '#6d6656',          // Brown + lighter (theoretical)
        'follow-up_Prolific': '#5D5646'       // Brown base
    }
};

// Generate color shades for scales (1-5) from a base color
function generateScaleColors(baseColor, count = 4) {
    // Handle case where baseColor is already rgb()
    let r, g, b;
    if (baseColor.startsWith('rgb')) {
        const match = baseColor.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
        if (match) {
            r = parseInt(match[1]);
            g = parseInt(match[2]);
            b = parseInt(match[3]);
        } else {
            return Array(count).fill(baseColor);
        }
    } else {
        // Parse hex to RGB
        const hex = baseColor.replace('#', '');
        r = parseInt(hex.substr(0, 2), 16);
        g = parseInt(hex.substr(2, 2), 16);
        b = parseInt(hex.substr(4, 2), 16);
    }
    
    // Handle edge case of count=1
    if (count <= 1) {
        return [baseColor];
    }
    
    const colors = [];
    for (let i = 0; i < count; i++) {
        // Lighter for lower values, base color for highest
        const factor = 0.4 + (0.6 * i / (count - 1));
        const nr = Math.round(r + (255 - r) * (1 - factor));
        const ng = Math.round(g + (255 - g) * (1 - factor));
        const nb = Math.round(b + (255 - b) * (1 - factor));
        colors.push(`rgb(${nr},${ng},${nb})`);
    }
    return colors;
}

// Generate Yes/No colors from base (darker=Yes, lighter=No)
function generateYesNoColors(baseColor) {
    const hex = baseColor.replace('#', '');
    const r = parseInt(hex.substr(0, 2), 16);
    const g = parseInt(hex.substr(2, 2), 16);
    const b = parseInt(hex.substr(4, 2), 16);
    
    // Yes = base color (darker)
    const yesColor = baseColor;
    // No = lighter version
    const factor = 0.5;
    const nr = Math.round(r + (255 - r) * factor);
    const ng = Math.round(g + (255 - g) * factor);
    const nb = Math.round(b + (255 - b) * factor);
    const noColor = `rgb(${nr},${ng},${nb})`;
    
    return { yes: yesColor, no: noColor };
}

// Get combined base color for sample + source
function getSplitBaseColor(sampleKey, sourceKey = null) {
    const sampleLower = sampleKey?.toLowerCase();
    const sampleColor = SPLIT_COLORS.sample[sampleLower] || '#58a6ff';
    if (!sourceKey) return sampleColor;
    
    // Check for predefined combined color
    const combinedKey = `${sampleLower}_${sourceKey}`;
    if (SPLIT_COLORS.combined[combinedKey]) {
        return SPLIT_COLORS.combined[combinedKey];
    }
    
    // Fallback: generate color dynamically
    const hex = sampleColor.replace('#', '');
    const r = parseInt(hex.substr(0, 2), 16);
    const g = parseInt(hex.substr(2, 2), 16);
    const b = parseInt(hex.substr(4, 2), 16);
    
    if (sourceKey.toLowerCase() === 'free') {
        // Lighter version for Free
        const factor = 0.3;
        const nr = Math.round(r + (255 - r) * factor);
        const ng = Math.round(g + (255 - g) * factor);
        const nb = Math.round(b + (255 - b) * factor);
        return `rgb(${nr},${ng},${nb})`;
    }
    return sampleColor;  // Prolific uses base color
}

// Canonical ordering for donut slices - ensures consistent positioning across charts
function getCanonicalKeyOrder(keys) {
    const keySet = new Set(keys.map(k => k.toLowerCase()));
    
    // Binary Yes/No - Yes first, then No (so "Yes" appears on left in legend, "No" on right)
    // Also handle Yes/No with suffixes like "Yes, because..." or "No, because..."
    // Check this FIRST before education (to avoid "No" matching "no formal education")
    const hasYes = keys.some(k => k.toLowerCase().startsWith('yes'));
    const hasNo = keys.some(k => k.toLowerCase().startsWith('no'));
    if (hasYes && hasNo && keys.length === 2) {
        return keys.sort((a, b) => {
            if (a.toLowerCase().startsWith('yes')) return -1;
            if (b.toLowerCase().startsWith('yes')) return 1;
            return 0;
        });
    }
    
    // Education level order: No formal → Primary → Secondary → Post-secondary → Graduate
    // Use full phrases to avoid matching simple "No" or "Yes" values
    const eduOrder = ['no formal education', 'primary school', 'secondary school', 'post-secondary', 'graduate degree'];
    const hasEduKeys = keys.some(k => {
        const kLower = k.toLowerCase();
        return eduOrder.some(e => kLower.includes(e) || 
            (kLower.includes('formal') && kLower.includes('education')) ||
            (kLower.includes('primary') && kLower.includes('school')) ||
            (kLower.includes('secondary')) ||
            (kLower.includes('post-secondary')) ||
            (kLower.includes('graduate') && kLower.includes('degree')));
    });
    if (hasEduKeys) {
        return keys.sort((a, b) => {
            const aLower = a.toLowerCase();
            const bLower = b.toLowerCase();
            // Find matching education level using more specific matching
            const getEduIdx = (s) => {
                if (s.includes('no formal') || (s.includes('formal') && s.includes('education'))) return 0;
                if (s.includes('primary')) return 1;
                if (s.includes('post-secondary') || s.includes('postsecondary')) return 3;
                if (s.includes('secondary')) return 2;
                if (s.includes('graduate')) return 4;
                return -1;
            };
            const idxA = getEduIdx(aLower);
            const idxB = getEduIdx(bLower);
            if (idxA !== -1 && idxB !== -1) return idxA - idxB;
            if (idxA !== -1) return -1;
            if (idxB !== -1) return 1;
            return a.localeCompare(b);
        });
    }
    
    // Age groups: detect and sort by first number
    // Matches patterns like "18-25", "26-35", "76+", etc.
    const isAgeGroupKey = k => /^\d+-\d+$/.test(k) || /^\d+\+$/.test(k);
    if (keys.some(isAgeGroupKey)) {
        // Predefined age group order
        const ageOrder = ['18-25', '26-35', '36-45', '46-55', '56-65', '66-75', '76+'];
        return keys.sort((a, b) => {
            const idxA = ageOrder.indexOf(a);
            const idxB = ageOrder.indexOf(b);
            if (idxA !== -1 && idxB !== -1) return idxA - idxB;
            // Fallback: extract first number for comparison
            const numA = parseInt(a.match(/\d+/)?.[0] || '999');
            const numB = parseInt(b.match(/\d+/)?.[0] || '999');
            return numA - numB;
        });
    }
    
    // Agreement scale: Strongly Disagree → Strongly Agree
    const agreementOrder = ['strongly disagree', 'disagree', 'neutral', 'agree', 'strongly agree'];
    if (keys.some(k => agreementOrder.includes(k.toLowerCase()))) {
        return keys.sort((a, b) => {
            const idxA = agreementOrder.indexOf(a.toLowerCase());
            const idxB = agreementOrder.indexOf(b.toLowerCase());
            if (idxA === -1 && idxB === -1) return a.localeCompare(b);
            if (idxA === -1) return 1;
            if (idxB === -1) return -1;
            return idxA - idxB;
        });
    }
    
    // Numeric scales: always ascending
    const allNumeric = keys.every(k => !isNaN(parseFloat(k)));
    if (allNumeric) {
        return keys.sort((a, b) => parseFloat(a) - parseFloat(b));
    }
    
    // Default: alphabetical
    return keys.sort();
}

async function loadData() {
    const base = window.location.pathname.includes('.html') ? window.location.pathname.replace(/\/[^/]*$/, '/') : window.location.pathname;
    const dataPath = base + 'data/';
    try {
        const [meta, dist, cross, ft, stats, es, fd] = await Promise.all([
            fetch(dataPath + 'metadata.json').then(r => r.json()),
            fetch(dataPath + 'distributions.json').then(r => r.json()),
            fetch(dataPath + 'crosstabs.json').then(r => r.json()),
            fetch(dataPath + 'freetext.json').then(r => r.json()),
            fetch(dataPath + 'survey_stats.json').then(r => r.json()),
            fetch(dataPath + 'entity_stats.json').then(r => r.json()),
            fetch(dataPath + 'filtered_distributions.json').then(r => r.json())
        ]);
        DATA = {metadata: meta, distributions: dist, crosstabs: cross, freetext: ft, surveyStats: stats, entityStats: es, filteredDistributions: fd};
        console.log('=== METADATA LOADED ===');
        console.log('sample_values:', DATA.metadata.sample_values);
        console.log('source_values:', DATA.metadata.source_values);
        console.log('cluster_values:', DATA.metadata.cluster_values);
        console.log('entity_list:', DATA.metadata.entity_list?.length);
        initUI();
    } catch (e) { console.error('Load error:', e); document.getElementById('dist-title').textContent = 'Error loading data'; }
}

function initUI() {
    document.getElementById('total-respondents').textContent = DATA.metadata.total_respondents?.toLocaleString() || '—';
    if (DATA.metadata.demographics?.country?.values) document.getElementById('total-countries').textContent = DATA.metadata.demographics.country.values.length;
    populateSampleFilter();
    populateCategoryDropdown();
    populateCrosstabDropdowns();
    populateFreetextDropdown();
    setupEvents();
    buildSurveyStats();
}

function DN(col) {
    const dn = DATA.metadata.display_names?.[col];
    return dn ? {s: dn[0], f: dn[1]} : {s: col?.substring?.(0,40) || col, f: col};
}

function capitalizePhase(name) {
    if (!name) return name;
    const lower = name.toLowerCase();
    if (lower === 'preregistered' || lower === 'pre-registered') return 'Pre-registered';
    if (lower === 'exploratory') return 'Exploratory';
    if (lower === 'follow-up' || lower === 'follow up') return 'Follow-up';
    if (lower === 'replication') return 'Replication';
    return name.charAt(0).toUpperCase() + name.slice(1);
}

function buildSurveyStats() {
    const s = DATA.surveyStats; if (!s) return;
    let h = `<table><tr><th>Statistic</th><th>Value</th></tr>`;
    h += `<tr><td>Total Respondents</td><td>${s.total_respondents?.toLocaleString() || '—'}</td></tr>`;
    if (s.duration?.all) h += `<tr><td>Mean Duration</td><td>${(s.duration.all.mean/60).toFixed(1)} min</td></tr>`;
    if (s.date_range?.all) h += `<tr><td>Data Collection</td><td>${s.date_range.all.start} – ${s.date_range.all.end}</td></tr>`;
    document.getElementById('survey-stats-container').innerHTML = h + '</table>';
}

// Sync Question(s) container height with Filter Responses height
function syncFilterHeights() {
    setTimeout(() => {
        const filterBox = document.getElementById('sample-filter-box');
        const varContainer = document.getElementById('variable-container');
        if (filterBox && varContainer) {
            const filterHeight = filterBox.offsetHeight;
            // Set CSS variable for scrollable max-height
            document.documentElement.style.setProperty('--filter-box-height', `${filterHeight}px`);
            // Also apply to vbox if it exists and has scrollable class
            const vbox = varContainer.querySelector('.checkbox-group.scrollable');
            if (vbox) {
                // Check if there's a display-mode-selector (for combined_attr)
                const displayModeSelector = varContainer.querySelector('.display-mode-selector');
                if (displayModeSelector) {
                    // Adjust max-height to account for display mode selector
                    const selectorHeight = displayModeSelector.offsetHeight + 16; // +16 for margin
                    const adjustedHeight = Math.max(100, filterHeight - selectorHeight);
                    vbox.style.maxHeight = `${adjustedHeight}px`;
                } else {
                    vbox.style.maxHeight = `${filterHeight}px`;
                }
            }
        }
    }, 50);
}

function populateSampleFilter() {
    const box = document.getElementById('sample-filter-box');
    const samples = DATA.metadata.sample_values || [];
    const sources = DATA.metadata.source_values || [];
    
    let h = '<div class="checkbox-item"><input type="checkbox" id="f-none" checked><label for="f-none">All respondents (no filter)</label></div>';
    
    if (samples.length > 0 || sources.length > 0) {
        h += '<div class="filter-row">';
        
        // Left column: Sample Phase
        h += '<div class="filter-col">';
        h += '<div class="filter-col-content">';
        if (samples.length > 0) {
            h += '<div class="checkbox-section">Sample Phase</div>';
            samples.forEach(v => {
                const displayName = capitalizePhase(v);
                h += `<div class="checkbox-item"><input type="checkbox" id="f-s-${v}" data-t="sample" data-v="${v}"><label for="f-s-${v}">${displayName}</label></div>`;
            });
        }
        h += '</div>';  // End filter-col-content
        h += '<div class="split-controls">';
        h += '<div class="split-toggle disabled" id="split-sample-toggle"><input type="checkbox" id="split-sample"><label for="split-sample">Split by Sample Phase</label></div>';
        h += '</div>';
        h += '</div>';  // End filter-col
        
        // Right column: Recruitment Source
        h += '<div class="filter-col">';
        h += '<div class="filter-col-content">';
        if (sources.length > 0) {
            h += '<div class="checkbox-section">Recruitment</div>';
            sources.forEach(v => {
                const displayName = v.charAt(0).toUpperCase() + v.slice(1);
                h += `<div class="checkbox-item"><input type="checkbox" id="f-r-${v}" data-t="source" data-v="${v}"><label for="f-r-${v}">${displayName}</label></div>`;
            });
        }
        h += '<div class="split-note" id="split-source-note" style="display:none;margin-top:0.5rem;margin-bottom:1rem;">Note: Follow-up sample only has Prolific recruitment</div>';
        h += '</div>';  // End filter-col-content
        h += '<div class="split-controls">';
        h += '<div class="split-toggle disabled" id="split-source-toggle"><input type="checkbox" id="split-source"><label for="split-source">Split by Recruitment</label></div>';
        h += '</div>';
        h += '</div>';  // End filter-col
        
        h += '</div>';  // End filter-row
    }
    
    box.innerHTML = h;
    
    // Sync variable container height with filter box height
    syncFilterHeights();
    
    // Handle filter checkbox changes
    box.querySelectorAll('input[data-t]').forEach(cb => cb.addEventListener('change', () => {
        if (cb.checked) {
            document.getElementById('f-none').checked = false;
        }
        if (!Array.from(box.querySelectorAll('input[data-t]:checked')).length) {
            document.getElementById('f-none').checked = true;
        }
        updateSplitToggleState();
    }));
    
    document.getElementById('f-none')?.addEventListener('change', () => {
        if (document.getElementById('f-none').checked) {
            box.querySelectorAll('input[data-t]').forEach(x => x.checked = false);
        }
        updateSplitToggleState();
    });
    
    // Handle split toggle changes
    document.getElementById('split-sample')?.addEventListener('change', (e) => {
        // If enabling split while "All respondents" is checked, auto-select all options
        if (e.target.checked && document.getElementById('f-none')?.checked) {
            document.getElementById('f-none').checked = false;
            const box = document.getElementById('sample-filter-box');
            box.querySelectorAll('input[data-t="sample"]').forEach(cb => cb.checked = true);
            box.querySelectorAll('input[data-t="source"]').forEach(cb => cb.checked = true);
        }
        updateSplitToggleState();
        showDist();  // Re-render with new split setting
    });
    document.getElementById('split-source')?.addEventListener('change', (e) => {
        // If enabling split while "All respondents" is checked, auto-select all options
        if (e.target.checked && document.getElementById('f-none')?.checked) {
            document.getElementById('f-none').checked = false;
            const box = document.getElementById('sample-filter-box');
            box.querySelectorAll('input[data-t="sample"]').forEach(cb => cb.checked = true);
            box.querySelectorAll('input[data-t="source"]').forEach(cb => cb.checked = true);
        }
        updateSplitToggleState();
        showDist();  // Re-render with new split setting
    });
    
    // Initial call to set split toggle state based on default "All respondents" selection
    updateSplitToggleState();
}

function updateSplitToggleState() {
    const box = document.getElementById('sample-filter-box');
    if (!box || !DATA?.metadata) {
        console.log('[updateSplitToggleState] No box or DATA yet');
        return;
    }
    
    const selectedSamples = Array.from(box.querySelectorAll('input[data-t="sample"]:checked')).map(cb => cb.dataset.v);
    const selectedSources = Array.from(box.querySelectorAll('input[data-t="source"]:checked')).map(cb => cb.dataset.v);
    const isAllSelected = document.getElementById('f-none')?.checked;
    
    const splitSampleToggle = document.getElementById('split-sample-toggle');
    const splitSourceToggle = document.getElementById('split-source-toggle');
    const splitSourceNote = document.getElementById('split-source-note');
    
    const allSamples = DATA.metadata.sample_values || [];
    const allSources = DATA.metadata.source_values || [];
    
    console.log('[updateSplitToggleState] isAllSelected:', isAllSelected, 'allSamples:', allSamples.length, 'allSources:', allSources.length);
    
    // Sample split: enable if multiple samples are effectively selected
    if (splitSampleToggle) {
        const effectiveSamples = isAllSelected ? allSamples : selectedSamples;
        console.log('[updateSplitToggleState] effectiveSamples:', effectiveSamples.length);
        if (effectiveSamples.length >= 2) {
            splitSampleToggle.classList.remove('disabled');
            console.log('[updateSplitToggleState] Enabling sample split');
        } else {
            splitSampleToggle.classList.add('disabled');
            document.getElementById('split-sample').checked = false;
        }
    }
    
    // Source split: enable if multiple sources available, but handle Follow-up special case
    // Also enable if no sources selected (= all sources), as long as we have samples with multiple sources
    if (splitSourceToggle) {
        const onlyFollowUp = selectedSamples.length === 1 && selectedSamples[0].toLowerCase().includes('follow');
        
        // If no sources selected, treat as "all sources" - enable split if allSources >= 2
        // If sources selected, need at least 2 selected
        const noSourcesSelected = selectedSources.length === 0;
        const canSplitBySource = (noSourcesSelected && allSources.length >= 2) || 
                                  selectedSources.length >= 2 || 
                                  (isAllSelected && allSources.length >= 2);
        
        if (onlyFollowUp) {
            // Follow-up only has Prolific - disable recruitment split
            splitSourceToggle.classList.add('disabled');
            document.getElementById('split-source').checked = false;
            if (splitSourceNote) splitSourceNote.style.display = 'none';
        } else if (canSplitBySource) {
            splitSourceToggle.classList.remove('disabled');
            console.log('[updateSplitToggleState] Enabling source split');
            // Show note if Follow-up is included in selected samples
            const hasFollowUp = isAllSelected || selectedSamples.some(s => s.toLowerCase().includes('follow'));
            if (hasFollowUp && document.getElementById('split-source')?.checked) {
                if (splitSourceNote) splitSourceNote.style.display = 'block';
            } else {
                if (splitSourceNote) splitSourceNote.style.display = 'none';
            }
        } else {
            splitSourceToggle.classList.add('disabled');
            document.getElementById('split-source').checked = false;
            if (splitSourceNote) splitSourceNote.style.display = 'none';
        }
    }
}

// Get split configuration
function getSplitConfig() {
    const splitBySample = document.getElementById('split-sample')?.checked || false;
    const splitBySource = document.getElementById('split-source')?.checked || false;
    const splitByCluster = document.getElementById('v-split-eid-cluster')?.checked || false;
    return { splitBySample, splitBySource, splitByCluster };
}

// Get filter selections without split logic (raw selections)
function getFilterSelections() {
    const box = document.getElementById('sample-filter-box');
    const isAllSelected = document.getElementById('f-none')?.checked;
    
    if (isAllSelected) {
        return {
            samples: DATA.metadata.sample_values || [],
            sources: [],  // Empty means "all sources" - getDataForFilter will use sample-only keys
            isAll: true
        };
    }
    
    const samples = Array.from(box.querySelectorAll('input[data-t="sample"]:checked')).map(cb => cb.dataset.v);
    const sources = Array.from(box.querySelectorAll('input[data-t="source"]:checked')).map(cb => cb.dataset.v);
    
    // If no samples selected but sources selected, use all samples
    const effectiveSamples = samples.length > 0 ? samples : (DATA.metadata.sample_values || []);
    // If no sources selected, return empty - this signals "use sample-only keys"
    // If some sources selected, return only those
    
    return {
        samples: effectiveSamples,
        sources: sources,  // Empty if no sources selected, otherwise the selected sources
        isAll: false
    };
}

// Get data for a specific filter combination (single sample + single source, or aggregations)
function getDataForFilter(sampleKeys, sourceKeys) {
    console.log('[getDataForFilter] sampleKeys:', sampleKeys, 'sourceKeys:', sourceKeys);
    
    // Build list of atomic keys to merge
    const keysToMerge = [];
    
    // If no source filter specified (empty sourceKeys), use sample-only keys
    if (sourceKeys.length === 0) {
        sampleKeys.forEach(smp => keysToMerge.push(`sample_${smp}`));
    } else {
        // Source filter specified - use combined keys
        sampleKeys.forEach(smp => {
            sourceKeys.forEach(src => {
                keysToMerge.push(`sample_${smp}__source_${src}`);
            });
        });
    }
    
    // If no sample keys, just use source keys
    if (sampleKeys.length === 0 && sourceKeys.length > 0) {
        sourceKeys.forEach(src => keysToMerge.push(`source_${src}`));
    }
    
    console.log('[getDataForFilter] Keys to merge:', keysToMerge);
    console.log('[getDataForFilter] Available filteredDistributions:', Object.keys(DATA.filteredDistributions || {}));
    
    // If both empty, return all
    if (keysToMerge.length === 0) {
        return {
            k: 'all',
            d: DATA.distributions,
            n: DATA.metadata.total_respondents,
            e: DATA.entityStats?.all || {},
            rc: DATA.metadata.multiselect_respondent_counts || {}
        };
    }
    
    // Merge distributions
    const mergedDists = {};
    const mergedRc = {};
    let totalN = 0;
    let mergedEntityStats = {};
    
    for (const k of keysToMerge) {
        const fd = DATA.filteredDistributions?.[k];
        if (fd) {
            totalN += fd.n;
            for (const [distKey, distData] of Object.entries(fd.distributions || {})) {
                if (!mergedDists[distKey]) mergedDists[distKey] = {};
                for (const [valKey, count] of Object.entries(distData || {})) {
                    if (typeof count === 'number') {
                        mergedDists[distKey][valKey] = (mergedDists[distKey][valKey] || 0) + count;
                    } else if (typeof count === 'string' && count.startsWith('<')) {
                        if (!mergedDists[distKey][valKey]) mergedDists[distKey][valKey] = count;
                    }
                }
            }
            for (const [rcKey, rcCount] of Object.entries(fd.multiselect_respondent_counts || {})) {
                mergedRc[rcKey] = (mergedRc[rcKey] || 0) + rcCount;
            }
            // Merge entity stats
            const es = DATA.entityStats?.[k] || {};
            for (const [entity, stats] of Object.entries(es)) {
                if (!mergedEntityStats[entity]) {
                    mergedEntityStats[entity] = {
                        short_name: stats.short_name,
                        consciousness_values: [],
                        moral_status_values: [],
                        paired_data: [],
                        paired_n: 0, c_n: 0, ms_n: 0
                    };
                }
                if (stats.consciousness_values) mergedEntityStats[entity].consciousness_values.push(...stats.consciousness_values);
                if (stats.moral_status_values) mergedEntityStats[entity].moral_status_values.push(...stats.moral_status_values);
                if (stats.paired_data) mergedEntityStats[entity].paired_data.push(...stats.paired_data);
                mergedEntityStats[entity].paired_n = (mergedEntityStats[entity].paired_n || 0) + (stats.paired_n || 0);
                mergedEntityStats[entity].c_n = (mergedEntityStats[entity].c_n || 0) + (stats.c_n || 0);
                mergedEntityStats[entity].ms_n = (mergedEntityStats[entity].ms_n || 0) + (stats.ms_n || 0);
            }
        }
    }
    
    // Calculate means/sds/sems for merged entity stats
    for (const entity of Object.keys(mergedEntityStats)) {
        const es = mergedEntityStats[entity];
        if (es.consciousness_values?.length > 0) {
            const cVals = es.consciousness_values;
            const n = cVals.length;
            es.c_mean = cVals.reduce((a, b) => a + b, 0) / n;
            es.c_std = Math.sqrt(cVals.reduce((sum, v) => sum + Math.pow(v - es.c_mean, 2), 0) / n);
            es.c_sem = es.c_std / Math.sqrt(n);
            es.c_n = n;
        }
        if (es.moral_status_values?.length > 0) {
            const mVals = es.moral_status_values;
            const n = mVals.length;
            es.ms_mean = mVals.reduce((a, b) => a + b, 0) / n;
            es.ms_std = Math.sqrt(mVals.reduce((sum, v) => sum + Math.pow(v - es.ms_mean, 2), 0) / n);
            es.ms_sem = es.ms_std / Math.sqrt(n);
            es.ms_n = n;
        }
        if (es.paired_data?.length > 0) {
            es.scatter_data = es.paired_data;
            es.paired_n = es.paired_data.length;
        }
    }
    
    return {
        k: keysToMerge.join('+'),
        d: mergedDists,
        n: totalN,
        e: mergedEntityStats,
        rc: mergedRc
    };
}

// Get all split datasets based on current configuration
function getSplitData(categoryNotInFollowup = false) {
    const { splitBySample, splitBySource, splitByCluster } = getSplitConfig();
    let { samples, sources, isAll } = getFilterSelections();
    
    console.log('[getSplitData] Initial samples:', samples, 'categoryNotInFollowup:', categoryNotInFollowup, 'splitByCluster:', splitByCluster);
    
    // If category is not in follow-up, filter out Follow-up from samples
    if (categoryNotInFollowup) {
        const originalSamples = [...samples];
        samples = samples.filter(smp => !smp.toLowerCase().includes('follow'));
        console.log('[getSplitData] Filtered samples (removed Follow-up):', samples, 'from', originalSamples);
    }
    
    // For split by source, if no sources explicitly selected, use all sources
    const effectiveSources = (splitBySource && sources.length === 0) 
        ? (DATA.metadata.source_values || []) 
        : sources;
    
    // Get cluster values if cluster splitting is enabled
    let clusters = splitByCluster ? (DATA.metadata.cluster_values || []) : [];
    // If metadata doesn't have cluster_values, derive from filtered keys
    if (splitByCluster && clusters.length === 0) {
        const clusterKeys = Object.keys(DATA.filteredDistributions || {}).filter(k => k.startsWith('cluster_') && !k.includes('__'));
        clusters = clusterKeys.map(k => k.replace('cluster_', ''));
    }
    
    console.log('[getSplitData] Config:', { splitBySample, splitBySource, splitByCluster, categoryNotInFollowup });
    console.log('[getSplitData] Final selections:', { samples, sources: effectiveSources, clusters, isAll });
    
    // No split - return single combined dataset
    if (!splitBySample && !splitBySource && !splitByCluster) {
        return [{
            label: 'All Selected',
            sampleKey: null,
            sourceKey: null,
            clusterKey: null,
            data: getDataForFilter(samples, sources),  // Use raw sources (empty = sample-only keys)
            baseColor: '#58a6ff'  // Default blue
        }];
    }
    
    const results = [];
    
    // Helper to add cluster dimension to a dataset
    // When cluster is combined with other splits, use the base split's color (sample/source)
    // and shade it by cluster position
    const addClusterSplit = (baseResults) => {
        if (!splitByCluster || clusters.length === 0) return baseResults;
        
        const clusterResults = [];
        for (const base of baseResults) {
            clusters.forEach((cluster, clusterIdx) => {
                const clusterLabel = capitalizeLabel(cluster);
                // Use base color (from sample/source) and adjust shade based on cluster index
                // First cluster (anthropocentric) = base color, second cluster (non-anthropocentric) = darker
                const shadeAmount = clusterIdx === 0 ? 0 : -30;
                const adjustedColor = adjustColor(base.baseColor, shadeAmount);
                
                clusterResults.push({
                    label: base.sampleKey || base.sourceKey ? `${base.label} / ${clusterLabel}` : clusterLabel,
                    sampleKey: base.sampleKey,
                    sourceKey: base.sourceKey,
                    clusterKey: cluster,
                    data: getDataForFilterWithCluster(
                        base.sampleKey ? [base.sampleKey] : samples,
                        base.sourceKey ? [base.sourceKey] : sources,
                        cluster
                    ),
                    baseColor: adjustedColor
                });
            });
        }
        return clusterResults;
    };
    
    // Cluster split only (no sample or source split)
    if (splitByCluster && !splitBySample && !splitBySource) {
        for (const cluster of clusters) {
            results.push({
                label: capitalizeLabel(cluster),
                sampleKey: null,
                sourceKey: null,
                clusterKey: cluster,
                data: getDataForFilterWithCluster(samples, sources, cluster),
                baseColor: getClusterColor(cluster)
            });
        }
        return results;
    }
    
    if (splitBySample && splitBySource) {
        // Split by both - need to use combination keys
        const srcForSplit = effectiveSources.length > 0 ? effectiveSources : (DATA.metadata.source_values || []);
        for (const smp of samples) {
            for (const src of srcForSplit) {
                // Check if this combination exists (Follow-up + Free doesn't exist)
                const isFollowUp = smp.toLowerCase().includes('follow');
                const isFree = src.toLowerCase() === 'free';
                if (isFollowUp && isFree) continue;  // Skip non-existent combination
                
                results.push({
                    label: `${capitalizePhase(smp)} / ${src}`,
                    sampleKey: smp,
                    sourceKey: src,
                    clusterKey: null,
                    data: getDataForFilter([smp], [src]),
                    baseColor: getSplitBaseColor(smp, src)
                });
            }
        }
    } else if (splitBySample) {
        // Split by sample - if sources are selected, filter by those sources
        // If no sources selected, use sample-only keys (all sources combined)
        for (const smp of samples) {
            let data;
            if (sources.length > 0) {
                // Sources are selected - filter to only those sources
                // Need to merge data from each sample+source combination
                const validSources = sources.filter(src => {
                    const isFollowUp = smp.toLowerCase().includes('follow');
                    const isFree = src.toLowerCase() === 'free';
                    return !(isFollowUp && isFree);  // Skip Follow-up + Free
                });
                
                if (validSources.length === 0) {
                    // No valid sources for this sample (e.g., Follow-up with only Free selected)
                    continue;
                }
                
                // If all sources are selected, use sample-only key for efficiency
                const allSources = DATA.metadata.source_values || [];
                const allSourcesSelected = allSources.every(s => sources.includes(s));
                
                if (allSourcesSelected) {
                    data = getDataForFilter([smp], []);  // Sample-only key
                } else {
                    // Merge data from valid source combinations
                    data = getDataForFilter([smp], validSources);
                }
            } else {
                // No source filter - use sample-only key
                data = getDataForFilter([smp], []);
            }
            
            console.log('[getSplitData] Sample', smp, 'data n:', data.n, 'dist keys:', Object.keys(data.d || {}).length);
            results.push({
                label: capitalizePhase(smp),
                sampleKey: smp,
                sourceKey: null,
                clusterKey: null,
                data: data,
                baseColor: getSplitBaseColor(smp, null)
            });
        }
    } else if (splitBySource) {
        // Split by source only - need to collapse samples into each source
        const srcForSplit = effectiveSources.length > 0 ? effectiveSources : (DATA.metadata.source_values || []);
        console.log('[getSplitData] splitBySource mode, srcForSplit:', srcForSplit, 'samples:', samples);
        for (const src of srcForSplit) {
            // For Follow-up, only Prolific exists (but if categoryNotInFollowup, Follow-up already filtered)
            const relevantSamples = samples.filter(smp => {
                const isFollowUp = smp.toLowerCase().includes('follow');
                const isFree = src.toLowerCase() === 'free';
                return !(isFollowUp && isFree);
            });
            
            console.log('[getSplitData] Source', src, 'relevantSamples:', relevantSamples);
            
            if (relevantSamples.length === 0) continue;
            
            const data = getDataForFilter(relevantSamples, [src]);
            console.log('[getSplitData] Source', src, 'data n:', data.n);
            
            results.push({
                label: src,
                sampleKey: null,
                sourceKey: src,
                clusterKey: null,
                data: data,
                baseColor: SPLIT_COLORS.source[src] || '#58a6ff'
            });
        }
    }
    
    // If cluster split is enabled, expand results by cluster
    const finalResults = splitByCluster ? addClusterSplit(results) : results;
    
    console.log('[getSplitData] Results:', finalResults.length, 'datasets');
    return finalResults;
}

// Get cluster-specific color (only used for cluster-only splits)
function getClusterColor(cluster) {
    const clusterColors = {
        'Anthropocentric': '#C29059',
        'Non-Anthropocentric': '#696A35',
        'anthropocentric': '#C29059',
        'non-anthropocentric': '#696A35'
    };
    return clusterColors[cluster] || '#58a6ff';
}

// Adjust color brightness
function adjustColor(hex, amount) {
    const num = parseInt(hex.replace('#', ''), 16);
    const r = Math.min(255, Math.max(0, (num >> 16) + amount));
    const g = Math.min(255, Math.max(0, ((num >> 8) & 0x00FF) + amount));
    const b = Math.min(255, Math.max(0, (num & 0x0000FF) + amount));
    return '#' + (0x1000000 + (r << 16) + (g << 8) + b).toString(16).slice(1);
}

// Get data for filter with cluster
function getDataForFilterWithCluster(samples, sources, cluster) {
    const filtered = DATA.filteredDistributions || {};
    
    // Helper to merge data
    const mergeData = (base, addition) => {
        if (!addition || addition.n === 0) return base;
        const merged = {
            n: base.n + addition.n,
            d: {...base.d},
            e: {...base.e},
            rc: {...base.rc}
        };
        for (const [key, val] of Object.entries(addition.d || {})) {
            if (!merged.d[key]) {
                merged.d[key] = {...val};
            } else {
                for (const [k, v] of Object.entries(val)) {
                    if (typeof v === 'number') {
                        merged.d[key][k] = (merged.d[key][k] || 0) + v;
                    }
                }
            }
        }
        for (const [key, val] of Object.entries(addition.rc || {})) {
            merged.rc[key] = (merged.rc[key] || 0) + val;
        }
        return merged;
    };
    
    // Try sample + source + cluster
    if (samples.length === 1 && sources.length === 1) {
        const key = `sample_${samples[0]}__source_${sources[0]}__cluster_${cluster}`;
        if (filtered[key]) {
            return { n: filtered[key].n || 0, d: filtered[key].distributions || {}, e: {}, rc: filtered[key].multiselect_respondent_counts || {} };
        }
    }
    
    // Try sample + cluster (no source filter)
    if (samples.length === 1 && sources.length === 0) {
        const key = `sample_${samples[0]}__cluster_${cluster}`;
        if (filtered[key]) {
            return { n: filtered[key].n || 0, d: filtered[key].distributions || {}, e: {}, rc: filtered[key].multiselect_respondent_counts || {} };
        }
    }
    
    // Multiple samples + sources + cluster - merge combinations
    if (samples.length > 0 && sources.length > 0) {
        let mergedData = { n: 0, d: {}, e: {}, rc: {} };
        for (const smp of samples) {
            for (const src of sources) {
                const key = `sample_${smp}__source_${src}__cluster_${cluster}`;
                if (filtered[key]) {
                    mergedData = mergeData(mergedData, {
                        n: filtered[key].n || 0,
                        d: filtered[key].distributions || {},
                        e: {},
                        rc: filtered[key].multiselect_respondent_counts || {}
                    });
                }
            }
        }
        if (mergedData.n > 0) return mergedData;
    }
    
    // Multiple samples + cluster (no source filter)
    if (samples.length > 0 && sources.length === 0) {
        let mergedData = { n: 0, d: {}, e: {}, rc: {} };
        for (const smp of samples) {
            const key = `sample_${smp}__cluster_${cluster}`;
            if (filtered[key]) {
                mergedData = mergeData(mergedData, {
                    n: filtered[key].n || 0,
                    d: filtered[key].distributions || {},
                    e: {},
                    rc: filtered[key].multiselect_respondent_counts || {}
                });
            }
        }
        if (mergedData.n > 0) return mergedData;
    }
    
    // Source + cluster (no sample filter)
    if (sources.length > 0) {
        let mergedData = { n: 0, d: {}, e: {}, rc: {} };
        for (const src of sources) {
            const key = `source_${src}__cluster_${cluster}`;
            if (filtered[key]) {
                mergedData = mergeData(mergedData, {
                    n: filtered[key].n || 0,
                    d: filtered[key].distributions || {},
                    e: {},
                    rc: filtered[key].multiselect_respondent_counts || {}
                });
            }
        }
        if (mergedData.n > 0) return mergedData;
    }
    
    // Cluster only
    const clusterKey = `cluster_${cluster}`;
    if (filtered[clusterKey]) {
        return { n: filtered[clusterKey].n || 0, d: filtered[clusterKey].distributions || {}, e: {}, rc: filtered[clusterKey].multiselect_respondent_counts || {} };
    }
    
    return { n: 0, d: {}, e: {}, rc: {} };
}

function getFilter() {
    const box = document.getElementById('sample-filter-box');
    if (document.getElementById('f-none')?.checked) {
        console.log('[getFilter] All respondents selected');
        return {k:'all', d:DATA.distributions, n:DATA.metadata.total_respondents, e:DATA.entityStats?.all||{}, rc:DATA.metadata.multiselect_respondent_counts||{}};
    }
    const smp = [], src = [];
    box.querySelectorAll('input:checked').forEach(cb => {
        if (cb.dataset.t === 'sample') smp.push(cb.dataset.v);
        if (cb.dataset.t === 'source') src.push(cb.dataset.v);
    });
    
    console.log('[getFilter] Samples:', smp, 'Sources:', src);
    
    // If nothing selected, fallback to all
    if (smp.length === 0 && src.length === 0) {
        console.log('[getFilter] Nothing selected, fallback to all');
        return {k:'all', d:DATA.distributions, n:DATA.metadata.total_respondents, e:DATA.entityStats?.all||{}, rc:DATA.metadata.multiselect_respondent_counts||{}};
    }
    
    // Check if all sources are selected (equivalent to no source filter)
    // Compare case-insensitively since source values might be capitalized
    const srcLower = src.map(s => s.toLowerCase());
    const allSourcesLower = (DATA.metadata.source_values || []).map(s => s.toLowerCase());
    const allSourcesSelected = allSourcesLower.length > 0 && allSourcesLower.every(s => srcLower.includes(s));
    const effectiveSrc = allSourcesSelected ? [] : src;  // If all sources selected, treat as no source filter
    
    // Single sample, no effective source filter
    if (smp.length === 1 && effectiveSrc.length === 0) {
        const k = `sample_${smp[0]}`;
        const fd = DATA.filteredDistributions?.[k];
        if (fd) {
            return {k, d:fd.distributions, n:fd.n, e:DATA.entityStats?.[k]||DATA.entityStats?.all||{}, rc:fd.multiselect_respondent_counts||{}};
        }
    }
    
    // No sample filter, single source
    if (smp.length === 0 && effectiveSrc.length === 1) {
        const k = `source_${effectiveSrc[0]}`;
        const fd = DATA.filteredDistributions?.[k];
        if (fd) {
            return {k, d:fd.distributions, n:fd.n, e:DATA.entityStats?.[k]||DATA.entityStats?.all||{}, rc:fd.multiselect_respondent_counts||{}};
        }
    }
    
    // No sample filter, all sources selected (equivalent to all respondents)
    if (smp.length === 0 && allSourcesSelected) {
        return {k:'all', d:DATA.distributions, n:DATA.metadata.total_respondents, e:DATA.entityStats?.all||{}, rc:DATA.metadata.multiselect_respondent_counts||{}};
    }
    
    // Single sample + single source
    if (smp.length === 1 && effectiveSrc.length === 1) {
        const k = `sample_${smp[0]}__source_${effectiveSrc[0]}`;
        const fd = DATA.filteredDistributions?.[k];
        if (fd) {
            return {k, d:fd.distributions, n:fd.n, e:DATA.entityStats?.[k]||DATA.entityStats?.all||{}, rc:fd.multiselect_respondent_counts||{}};
        }
    }
    
    // Multiple samples (with or without source filter)
    const keysToMerge = [];
    
    if (smp.length > 0 && effectiveSrc.length === 0) {
        // Multiple samples, no source filter - merge sample distributions
        smp.forEach(s => keysToMerge.push(`sample_${s}`));
    } else if (smp.length > 0 && effectiveSrc.length === 1) {
        // Multiple samples with single source - merge sample__source combinations
        smp.forEach(s => keysToMerge.push(`sample_${s}__source_${effectiveSrc[0]}`));
    } else if (smp.length > 0 && effectiveSrc.length > 1) {
        // Multiple samples with multiple (but not all) sources - complex case
        smp.forEach(s => {
            effectiveSrc.forEach(srcVal => {
                keysToMerge.push(`sample_${s}__source_${srcVal}`);
            });
        });
    } else if (smp.length === 0 && effectiveSrc.length > 1) {
        // No samples, multiple sources - merge source distributions
        effectiveSrc.forEach(s => keysToMerge.push(`source_${s}`));
    }
    
    // Merge distributions from multiple filters
    const mergedDists = {};
    const mergedRc = {};
    let totalN = 0;
    let mergedEntityStats = {};
    
    console.log('[getFilter] Keys to merge:', keysToMerge);
    console.log('[getFilter] Available filteredDistributions keys:', Object.keys(DATA.filteredDistributions || {}));
    
    for (const k of keysToMerge) {
        const fd = DATA.filteredDistributions?.[k];
        console.log(`[getFilter] Looking up key "${k}":`, fd ? `found (n=${fd.n})` : 'NOT FOUND');
        if (fd) {
            totalN += fd.n;
            for (const [distKey, distData] of Object.entries(fd.distributions || {})) {
                if (!mergedDists[distKey]) mergedDists[distKey] = {};
                for (const [valKey, count] of Object.entries(distData || {})) {
                    if (typeof count === 'number') {
                        mergedDists[distKey][valKey] = (mergedDists[distKey][valKey] || 0) + count;
                    } else if (typeof count === 'string' && count.startsWith('<')) {
                        if (!mergedDists[distKey][valKey]) mergedDists[distKey][valKey] = count;
                    }
                }
            }
            for (const [rcKey, rcCount] of Object.entries(fd.multiselect_respondent_counts || {})) {
                mergedRc[rcKey] = (mergedRc[rcKey] || 0) + rcCount;
            }
            // Merge entity stats
            const es = DATA.entityStats?.[k] || {};
            for (const [entity, stats] of Object.entries(es)) {
                if (!mergedEntityStats[entity]) {
                    mergedEntityStats[entity] = {
                        short_name: stats.short_name,
                        consciousness_values: [],
                        moral_status_values: [],
                        paired_data: [],
                        paired_n: 0,
                        c_n: 0,
                        ms_n: 0
                    };
                }
                if (stats.consciousness_values) mergedEntityStats[entity].consciousness_values.push(...stats.consciousness_values);
                if (stats.moral_status_values) mergedEntityStats[entity].moral_status_values.push(...stats.moral_status_values);
                if (stats.paired_data) mergedEntityStats[entity].paired_data.push(...stats.paired_data);
                mergedEntityStats[entity].paired_n = (mergedEntityStats[entity].paired_n || 0) + (stats.paired_n || 0);
                mergedEntityStats[entity].c_n = (mergedEntityStats[entity].c_n || 0) + (stats.c_n || 0);
                mergedEntityStats[entity].ms_n = (mergedEntityStats[entity].ms_n || 0) + (stats.ms_n || 0);
            }
        }
    }
    
    // Calculate means/sds/sems for merged entity stats
    for (const entity of Object.keys(mergedEntityStats)) {
        const es = mergedEntityStats[entity];
        if (es.consciousness_values && es.consciousness_values.length > 0) {
            const cVals = es.consciousness_values;
            const n = cVals.length;
            es.c_mean = cVals.reduce((a, b) => a + b, 0) / n;
            es.c_std = Math.sqrt(cVals.reduce((sum, v) => sum + Math.pow(v - es.c_mean, 2), 0) / n);
            es.c_sem = es.c_std / Math.sqrt(n);
            es.c_n = n;
        }
        if (es.moral_status_values && es.moral_status_values.length > 0) {
            const mVals = es.moral_status_values;
            const n = mVals.length;
            es.ms_mean = mVals.reduce((a, b) => a + b, 0) / n;
            es.ms_std = Math.sqrt(mVals.reduce((sum, v) => sum + Math.pow(v - es.ms_mean, 2), 0) / n);
            es.ms_sem = es.ms_std / Math.sqrt(n);
            es.ms_n = n;
        }
        if (es.paired_data && es.paired_data.length > 0) {
            es.scatter_data = es.paired_data;
            es.paired_n = es.paired_data.length;
        }
    }
    
    const mergedKey = keysToMerge.join('+');
    console.log('[getFilter] Final merged N:', totalN, 'Key:', mergedKey);
    return {k: mergedKey, d: mergedDists, n: totalN, e: mergedEntityStats, rc: mergedRc};
}


function populateCategoryDropdown() {
    const sel = document.getElementById('dist-category');
    sel.innerHTML = `
        <option value="">Select a topic...</option>
        <optgroup label="The Distribution of Consciousness and Moral Status">
            <option value="c_attr">Attributions of Consciousness</option>
            <option value="ms_attr">Attributions of Moral Status</option>
            <option value="combined_attr">Attributions: combined per entity</option>
        </optgroup>
        <optgroup label="Moral Dilemmas">
            <option value="zombie_pill">A Special Pill</option>
            <option value="earth_danger">Earth is in Danger</option>
            <option value="kill_test">An Important Test</option>
        </optgroup>
        <optgroup label="Direct Questions">
            <option value="graded_c">Graded Consciousness</option>
            <option value="c_intel">Consciousness & Intelligence</option>
            <option value="ics">Separating Consciousness from Intentions and Valence</option>
            <option value="moral_cons">Consciousness and Moral Considerations</option>
            <option value="moral_features">Important Features for Moral Considerations</option>
        </optgroup>
        <optgroup label="Respondents Information">
            <option value="demo">General Demographics</option>
            <option value="experience">Experience Domains</option>
        </optgroup>
    `;
    sel.addEventListener('change', updateVariableUI);
}

function buildCheckboxGroup(items, prefix) {
    let h = '<div class="checkbox-group" id="vbox">';
    h += '<div class="checkbox-item select-all"><input type="checkbox" id="v-all"><label for="v-all">Select All</label></div>';
    items.forEach((item, i) => {
        h += `<div class="checkbox-item"><input type="checkbox" id="v-${prefix}-${i}" data-k="${item.k}" data-c="${item.c}"><label for="v-${prefix}-${i}">${item.l}</label></div>`;
    });
    h += '</div>';
    return h;
}

function updateVariableUI() {
    const cat = document.getElementById('dist-category').value;
    const vc = document.getElementById('variable-container');
    const ftContainer = document.getElementById('free-text-container');
    const scenarioContainer = document.getElementById('scenario-text-container');
    
    // Clear free-text-container at the start (will be repopulated by addFreeTextSection if needed)
    if (ftContainer) {
        ftContainer.style.display = 'none';
        ftContainer.innerHTML = '';
    }
    
    // Clear and hide scenario text container by default
    if (scenarioContainer) {
        scenarioContainer.style.display = 'none';
        scenarioContainer.innerHTML = '';
    }
    
    if (!cat) {
        vc.innerHTML = '<select id="dist-variable"><option value="">Select a topic first...</option></select>';
        return;
    }
    
    // Add scenario text for moral dilemmas
    if (scenarioContainer) {
        let scenarioHtml = '';
        if (cat === 'earth_danger') {
            scenarioHtml = '<div class="scenario-text" style="font-size:0.87rem;color:var(--text-secondary);line-height:1.5;padding:0.6rem;background:var(--bg-secondary);border-radius:6px;margin-bottom:1rem;">';
            scenarioHtml += '<p style="margin:0 0 0.5rem;"><strong>Imagine the following scenario:</strong></p>';
            scenarioHtml += '<p style="margin:0 0 0.5rem;">Earth is in danger and will cease to exist. Luckily, you can evacuate safely, and you must choose only one creature/system you can save.</p>';
            scenarioHtml += '<p style="margin:0;"><strong><em>Who would you save?</em></strong></p>';
            scenarioHtml += '</div>';
        } else if (cat === 'kill_test') {
            scenarioHtml = '<div class="scenario-text" style="font-size:0.87rem;color:var(--text-secondary);line-height:1.5;padding:0.6rem;background:var(--bg-secondary);border-radius:6px;margin-bottom:1rem;">';
            scenarioHtml += '<p style="margin:0 0 0.5rem;"><strong>Imagine the following scenario:</strong></p>';
            scenarioHtml += '<p style="margin:0 0 0.5rem;">You are about to take a very important test that will affect the rest of your life - it has to go well. However, you didn\'t prepare, and you are extremely confident that you are not going to pass.</p>';
            scenarioHtml += '<p style="margin:0 0 0.5rem;">Luckily, you have the option to kill a creature/system to be 100% sure that you will pass the test.</p>';
            scenarioHtml += '<p style="margin:0;font-weight:600;"><em>Would you kill these entities to pass an important test?</em></p>';
            scenarioHtml += '</div>';
        } else if (cat === 'ms_attr') {
            scenarioHtml = '<div class="scenario-text" style="font-size:0.85rem;color:var(--text-secondary);line-height:1.5;padding:0.6rem;background:var(--bg-secondary);border-radius:6px;margin-bottom:1rem;">';
            scenarioHtml += '<p style="margin:0 0 0.5rem;"><strong>[Survey instructions]</strong></p>';
            scenarioHtml += '<p style="margin:0 0 0.5rem;">In this section, we ask you to indicate whether you think each of the following creatures has <strong>moral status</strong></p>';
            scenarioHtml += '<p style="margin:0 0 0.5rem;"><strong>Has moral status:</strong> these creatures should be treated with respect based on their own interests - we should take them into account with respect to moral issues (e.g., discussions about what is right or wrong, or what should or should not be done).</p>';
            scenarioHtml += '<p style="margin:0 0 0.5rem;font-style:italic;">For example: "the zirb-zorb* has moral status, therefore we should consider its well-being when we make decisions".</p>';
            scenarioHtml += '<p style="margin:0 0 0.5rem;font-size:0.8rem;color:var(--text-muted);">*Zirb-zorbs are something we invented for the sake of this example, replace it with the considered item in each question</p>';
            scenarioHtml += '<p style="margin:0;"><strong>Scale:</strong> 1 = does not have moral status, 2 = probably doesn\'t have moral status, 3 = probably has moral status, 4 = has moral status</p>';
            scenarioHtml += '</div>';
        } else if (cat === 'c_attr') {
            scenarioHtml = '<div class="scenario-text" style="font-size:0.85rem;color:var(--text-secondary);line-height:1.5;padding:0.6rem;background:var(--bg-secondary);border-radius:6px;margin-bottom:1rem;">';
            scenarioHtml += '<p style="margin:0 0 0.5rem;"><strong>[Survey instructions]</strong></p>';
            scenarioHtml += '<p style="margin:0 0 0.5rem;">In this section, we ask you to indicate whether you think each of the following creatures has <strong>consciousness</strong></p>';
            scenarioHtml += '<p style="margin:0 0 0.5rem;"><strong>Consciousness:</strong> based on what consciousness means to you.</p>';
            scenarioHtml += '<p style="margin:0 0 0.5rem;"><strong>Has consciousness:</strong> can be conscious, based on what consciousness means to you, even if there are cases when they are not (for example: "the zirb-zorb* is conscious in the mornings, but unconscious at nighttime") or some items in the group are not (for example: "not all zirb-zorbs are conscious, but some of them are"). In both cases, the zirb-zorb has consciousness.</p>';
            scenarioHtml += '<p style="margin:0 0 0.5rem;font-size:0.8rem;color:var(--text-muted);">*Zirb-zorbs are something we invented for the sake of this example, replace it with the considered item in each question</p>';
            scenarioHtml += '<p style="margin:0;"><strong>Scale:</strong> 1 = does not have consciousness, 2 = probably doesn\'t have consciousness, 3 = probably has consciousness, 4 = has consciousness</p>';
            scenarioHtml += '</div>';
        } else if (cat === 'combined_attr') {
            scenarioHtml = '<div class="scenario-text" style="font-size:0.85rem;color:var(--text-secondary);line-height:1.5;padding:0.6rem;background:var(--bg-secondary);border-radius:6px;margin-bottom:1rem;">';
            scenarioHtml += '<p style="margin:0;">This section combines both attribution sections of the survey, presenting for each of the 24 entities their attributions of consciousness and moral status.</p>';
            scenarioHtml += '</div>';
        } else if (cat === 'graded_c') {
            scenarioHtml = '<div class="scenario-text" style="font-size:0.85rem;color:var(--text-secondary);line-height:1.5;padding:0.6rem;background:var(--bg-secondary);border-radius:6px;margin-bottom:1rem;">';
            scenarioHtml += '<p style="margin:0 0 0.5rem;">We asked people to rate how much they agree with the following statements about consciousness</p>';
            scenarioHtml += '<p style="margin:0;font-style:italic;">(Based on whatever consciousness means to them)</p>';
            scenarioHtml += '</div>';
        }
        if (scenarioHtml) {
            scenarioContainer.innerHTML = scenarioHtml;
            scenarioContainer.style.display = 'block';
        }
    }
    
    const entities = DATA.metadata.entity_list || [];
    const qGroups = DATA.metadata.question_groups || {};
    const surveyQs = DATA.metadata.survey_questions || {};
    
    // Sort entities alphabetically by short name
    const sortedEntities = [...entities].sort((a, b) => a.short.localeCompare(b.short));
    
    // MS Attributions - checkbox list of entities
    if (cat === 'ms_attr') {
        let h = '<div class="checkbox-group scrollable entity-grid" id="vbox">';
        h += '<div class="checkbox-item select-all"><input type="checkbox" id="v-all"><label for="v-all">Select All</label></div>';
        sortedEntities.forEach(e => h += `<div class="checkbox-item"><input type="checkbox" id="v-ms-${e.key}" data-entity="${e.key}" data-type="ms"><label for="v-ms-${e.key}">${e.short}</label></div>`);
        h += '</div>';
        vc.innerHTML = h;
        document.getElementById('v-all').addEventListener('change', ev => vc.querySelectorAll('input:not(#v-all)').forEach(x => x.checked = ev.target.checked));
        return;
    }
    
    // C Attributions - checkbox list of entities
    if (cat === 'c_attr') {
        let h = '<div class="checkbox-group scrollable entity-grid" id="vbox">';
        h += '<div class="checkbox-item select-all"><input type="checkbox" id="v-all"><label for="v-all">Select All</label></div>';
        sortedEntities.forEach(e => h += `<div class="checkbox-item"><input type="checkbox" id="v-c-${e.key}" data-entity="${e.key}" data-type="c"><label for="v-c-${e.key}">${e.short}</label></div>`);
        h += '</div>';
        vc.innerHTML = h;
        document.getElementById('v-all').addEventListener('change', ev => vc.querySelectorAll('input:not(#v-all)').forEach(x => x.checked = ev.target.checked));
        return;
    }
    
    // Combined Attributions - checkbox list of entities for scatter plot
    if (cat === 'combined_attr') {
        let h = '<div class="checkbox-group scrollable entity-grid" id="vbox">';
        h += '<div class="checkbox-item select-all"><input type="checkbox" id="v-all"><label for="v-all">Select All</label></div>';
        sortedEntities.forEach(e => h += `<div class="checkbox-item"><input type="checkbox" id="v-comb-${e.key}" data-entity="${e.key}" data-type="combined"><label for="v-comb-${e.key}">${e.short}</label></div>`);
        h += '</div>';
        // Display mode selector with explanation on the right
        h += '<div class="display-mode-selector" style="margin-top:1rem;padding-top:0.75rem;border-top:1px solid var(--border);display:flex;gap:1.5rem;align-items:flex-start;">';
        h += '<div style="flex-shrink:0;">';
        h += '<label style="font-size:0.9rem;color:var(--text-secondary);margin-bottom:0.5rem;display:block;">Display Mode:</label>';
        h += '<div style="display:flex;gap:0.75rem;flex-wrap:wrap;font-size:0.95rem;">';
        h += '<label style="display:flex;align-items:center;gap:0.3rem;cursor:pointer;"><input type="radio" name="display-mode" value="mean"> Mean</label>';
        h += '<label style="display:flex;align-items:center;gap:0.3rem;cursor:pointer;"><input type="radio" name="display-mode" value="individual"> Individual Data</label>';
        h += '<label style="display:flex;align-items:center;gap:0.3rem;cursor:pointer;"><input type="radio" name="display-mode" value="both" checked> Both</label>';
        h += '</div></div>';
        // Explanation box on the right
        h += '<div style="font-size:0.75rem;color:var(--text-muted);background:var(--bg-secondary);padding:0.4rem 0.6rem;border-radius:4px;line-height:1.35;flex:1;">';
        h += '<strong>Mean:</strong> Shows the average attribution (Consciousness, Moral Status) for each entity. Hover to see ± Standard Error.<br>';
        h += '<strong>Individual Data:</strong> Shows all individual responses as jittered points.<br>';
        h += '<strong>Both:</strong> Shows both mean and individual responses.';
        h += '</div></div>';
        vc.innerHTML = h;
        document.getElementById('v-all').addEventListener('change', ev => vc.querySelectorAll('input[type="checkbox"]:not(#v-all)').forEach(x => x.checked = ev.target.checked));
        // Add listener for display mode changes
        vc.querySelectorAll('input[name="display-mode"]').forEach(r => r.addEventListener('change', showDist));
        return;
    }
    
    // Checkbox group categories (multi-select)
    const checkboxGroups = {
        'earth_danger': 'Earth in Danger',
        'ics': 'Intentions, Consciousness, Sensations',
        'moral_cons': 'Moral Considerations',
        'graded_c': 'Graded Consciousness',
        'c_intel': 'Consciousness & Intelligence'
    };
    
    // Unified Experience category - combines levels and sources
    if (cat === 'experience') {
        const expLevels = DATA.metadata.experience_levels || {};
        const expSources = DATA.metadata.experience_sources || {};
        
        // Build items: each experience level followed by its source
        let h = '<div class="checkbox-group" id="vbox">';
        h += '<div class="checkbox-item select-all"><input type="checkbox" id="v-all"><label for="v-all">Select All</label></div>';
        
        // Order: AI, Animal, Consciousness, Ethics
        const expOrder = ['ai_exp', 'animal_exp', 'consciousness_exp', 'ethics_exp'];
        const srcMap = {'ai_exp': 'ai_source', 'animal_exp': 'animal_types', 'consciousness_exp': 'consciousness_source', 'ethics_exp': 'ethics_source'};
        
        let idx = 0;
        expOrder.forEach(expKey => {
            const expData = expLevels[expKey];
            const srcKey = srcMap[expKey];
            const srcData = expSources[srcKey];
            
            if (expData) {
                const expLabel = DN(expData.label).s;
                h += `<div class="checkbox-item"><input type="checkbox" id="v-exp-${idx}" data-k="exp_${expKey}" data-c="${expData.label}" data-type="level"><label for="v-exp-${idx}">${expLabel}</label></div>`;
                idx++;
            }
            if (srcData) {
                const srcLabel = DN(srcData.label).s;  // No (Source) suffix
                h += `<div class="checkbox-item" style="margin-left:1rem;"><input type="checkbox" id="v-exp-${idx}" data-k="expsrc_${srcKey}" data-c="${srcData.label}" data-type="source"><label for="v-exp-${idx}">${srcLabel} <span class="multiselect-marker">*</span></label></div>`;
                idx++;
            }
        });
        
        h += '<div class="multiselect-note">* Respondents could select multiple options</div>';
        h += '</div>';
        vc.innerHTML = h;
        document.getElementById('v-all').addEventListener('change', ev => vc.querySelectorAll('input:not(#v-all)').forEach(x => x.checked = ev.target.checked));
        addFreeTextSection(cat, vc);
        return;
    }
    
    // Kill to Pass a Test - special nested structure with No Kill Reasons
    if (cat === 'kill_test') {
        const kptCols = qGroups['Kill to Pass a Test'] || [];
        const optionLabels = DATA.metadata.question_option_labels || {};
        let items = [];
        Object.entries(surveyQs).forEach(([k, cn]) => {
            if (kptCols.includes(cn)) {
                // Use custom option label if available
                const label = optionLabels[cn] || DN(cn).s;
                items.push({k: `survey_${k}`, c: cn, l: label});
            }
        });
        
        let h = '<div class="checkbox-group scrollable" id="vbox">';
        // Select All checkbox
        h += '<div class="checkbox-item select-all"><input type="checkbox" id="v-kpt-all"><label for="v-kpt-all">Select All</label></div>';
        // Prefix text
        h += '<div class="checkbox-prefix" style="font-size:0.95rem;color:var(--text-secondary);padding:0.5rem 0 0.25rem;font-style:italic;">A creature/system that...</div>';
        // Nested entity checkboxes
        items.forEach((item, i) => {
            h += `<div class="checkbox-item" style="margin-left:1rem;"><input type="checkbox" id="v-kpt-${i}" data-k="${item.k}" data-c="${item.c}" class="kpt-entity"><label for="v-kpt-${i}">${item.l}</label></div>`;
        });
        h += '</div>';
        vc.innerHTML = h;
        
        // Wire up the "Select All" header to toggle all entity checkboxes
        document.getElementById('v-kpt-all').addEventListener('change', ev => {
            vc.querySelectorAll('.kpt-entity').forEach(x => x.checked = ev.target.checked);
        });
        addFreeTextSection(cat, vc);
        return;
    }
    
    if (checkboxGroups[cat] !== undefined) {
        const groupName = checkboxGroups[cat];
        let items = [];
        const optionLabels = DATA.metadata.question_option_labels || {};
        
        if (groupName) {
            // Other groups - build from question_groups
            const cols = qGroups[groupName] || [];
            console.log(`Category ${cat} (${groupName}): looking for ${cols.length} columns`);
            Object.entries(surveyQs).forEach(([k, cn]) => {
                if (cols.includes(cn)) {
                    // Use custom option label if available, otherwise use display name
                    const label = optionLabels[cn] || DN(cn).s;
                    items.push({k: `survey_${k}`, c: cn, l: label});
                }
            });
            console.log(`Category ${cat}: found ${items.length} items`);
        }
        
        if (items.length > 0) {
            // Build custom checkbox group with prefix for certain categories
            let h = '<div class="checkbox-group scrollable" id="vbox">';
            h += '<div class="checkbox-item select-all"><input type="checkbox" id="v-all"><label for="v-all">Select All</label></div>';
            
            // Add prefix text for specific categories
            if (cat === 'ics') {
                h += '<div class="checkbox-prefix" style="font-size:0.95rem;color:var(--text-secondary);padding:0.5rem 0 0.25rem;font-style:italic;">Do you think a creature/system can...</div>';
            }
            // Note: earth_danger no longer has a checkbox prefix - the question is in the scenario text
            
            // Special handling for moral_cons - indent PRIOS_Q_CONS and add note
            if (cat === 'moral_cons') {
                items.forEach((item, i) => {
                    // PRIOS_Q_CONS contains "conscious creatures" but NOT "non-conscious"
                    const labelLower = item.c?.toLowerCase() || '';
                    const isConditional = labelLower.includes('conscious creatures/systems should be taken') && 
                                         !labelLower.includes('non-conscious');
                    const indent = isConditional ? 'margin-left:1.5rem;' : '';
                    h += `<div class="checkbox-item" style="${indent}"><input type="checkbox" id="v-${cat}-${i}" data-k="${item.k}" data-c="${item.c}"><label for="v-${cat}-${i}">${item.l}</label></div>`;
                    // Add note after the conditional question
                    if (isConditional) {
                        h += '<div class="checkbox-note" style="font-size:0.75rem;color:var(--text-muted);margin-left:2rem;margin-bottom:0.5rem;font-style:italic;">NOTE: Only respondents who answered "No" to the non-conscious question were asked this</div>';
                    }
                });
            } else if (cat === 'graded_c') {
                // Special handling for graded_c - indent "interests matter more" follow-up question
                items.forEach((item, i) => {
                    const labelLower = item.c?.toLowerCase() || '';
                    // The follow-up question about "interests of the more conscious entity matter more"
                    const isConditional = labelLower.includes('interests') && labelLower.includes('matter more');
                    const indent = isConditional ? 'margin-left:1.5rem;' : '';
                    h += `<div class="checkbox-item" style="${indent}"><input type="checkbox" id="v-${cat}-${i}" data-k="${item.k}" data-c="${item.c}"><label for="v-${cat}-${i}">${item.l}</label></div>`;
                    // Add note after the conditional question
                    if (isConditional) {
                        h += '<div class="checkbox-note" style="font-size:0.75rem;color:var(--text-muted);margin-left:2rem;margin-bottom:0.5rem;font-style:italic;">NOTE: Only respondents who agreed (rated 3/4) with the \'not necessarily equally conscious\' assertion were asked this</div>';
                    }
                });
            } else {
                items.forEach((item, i) => {
                    h += `<div class="checkbox-item"><input type="checkbox" id="v-${cat}-${i}" data-k="${item.k}" data-c="${item.c}"><label for="v-${cat}-${i}">${item.l}</label></div>`;
                });
            }
            h += '</div>';
            vc.innerHTML = h;
            document.getElementById('v-all').addEventListener('change', ev => vc.querySelectorAll('input:not(#v-all)').forEach(x => x.checked = ev.target.checked));
            addFreeTextSection(cat, vc);
            return;
        }
    }
    
    // Old-style group categories (dropdown) for remaining g_ prefixed
    if (cat.startsWith('g_')) {
        const gn = cat.replace('g_', '');
        const cols = qGroups[gn] || [];
        let opts = [];
        Object.entries(surveyQs).forEach(([k, cn]) => {
            if (cols.includes(cn)) opts.push({k: `survey_${k}`, l: DN(cn).s, c: cn});
        });
        let h = '<select id="dist-variable"><option value="">Select a question...</option>';
        opts.forEach(o => h += `<option value="${o.k}" data-c="${o.c}">${o.l}</option>`);
        vc.innerHTML = h + '</select>';
        return;
    }
    
    // Standard dropdown categories
    let opts = [];
    
    // Demographics - checkbox group for multi-select
    if (cat === 'demo') {
        const demos = DATA.metadata.demographics || {};
        let h = '<div class="checkbox-group" id="vbox">';
        h += '<div class="checkbox-item select-all"><input type="checkbox" id="v-all"><label for="v-all">Select All</label></div>';
        let i = 0;
        Object.entries(demos).filter(([k]) => k !== 'education').forEach(([k, o]) => {
            const label = DN(o.label).s;
            h += `<div class="checkbox-item"><input type="checkbox" id="v-demo-${i}" data-k="demo_${k}" data-c="${o.label}"><label for="v-demo-${i}">${label}</label></div>`;
            i++;
            // Insert Education questions after Employment
            if (k === 'employment') {
                h += `<div class="checkbox-item" style="margin-left:0;"><input type="checkbox" id="v-edu-background" data-k="demo_education" data-mode="single"><label for="v-edu-background">Education</label></div>`;
                h += `<div class="checkbox-item sub-question" style="margin-left:1.5rem;"><input type="checkbox" id="v-edu-field" data-k="multiselect_education_topic" data-mode="multiselect"><label for="v-edu-field">Education Topic <span class="multiselect-marker">*</span></label></div>`;
            }
        });
        h += '<div class="multiselect-note">* Respondents could select multiple options</div>';
        h += '</div>';
        vc.innerHTML = h;
        document.getElementById('v-all').addEventListener('change', ev => vc.querySelectorAll('input:not(#v-all)').forEach(x => x.checked = ev.target.checked));
        
        // Add note listener for education topic - note will appear in title area
        const eduFieldCheckbox = document.getElementById('v-edu-field');
        if (eduFieldCheckbox) {
            eduFieldCheckbox.addEventListener('change', function() {
                // Trigger showDist to update the title with the note
                showDist();
            });
        }
        
        addFreeTextSection(cat, vc);
        return;
    }
    
    if (cat === 'expsrc') Object.entries(DATA.metadata.experience_sources || {}).forEach(([k, o]) => opts.push({k: `expsrc_${k}`, l: DN(o.label).s}));
    
    // Zombie Pill - single question with full text
    else if (cat === 'zombie_pill') {
        let h = '<div class="zombie-pill-text" style="font-size:0.87rem;color:var(--text-secondary);line-height:1.5;padding:0.6rem;background:var(--bg-secondary);border-radius:6px;">';
        h += '<p style="margin:0 0 0.5rem;"><strong>Imagine the following scenario:</strong></p>';
        h += '<p style="margin:0 0 0.5rem;">Imagine someone offers you a pill. If you take it, you will live the best life one could possibly imagine (for example, you will create things of great value, have a fulfilling life surrounded by friends and family, etc.).</p>';
        h += '<p style="margin:0 0 0.5rem;">But you will not consciously experience any of this. That is, your actions and behaviors will look as if you are conscious, so no one could ever suspect that you are actually not conscious. But in reality, everything you do will not be accompanied by conscious experiences. You will be living your best life, but will not experience any aspect of it.</p>';
        h += '<p style="margin:0;font-weight:600;"><em>Would you take the pill?</em></p>';
        h += '</div>';
        vc.innerHTML = h;
        return;
    }
    // Education - two questions (background and field)
    else if (cat === 'education') {
        let h = '<div class="checkbox-group" id="vbox">';
        h += '<div class="checkbox-item"><input type="checkbox" id="v-edu-background" data-k="demo_education" data-mode="single"><label for="v-edu-background">What is your education background?</label></div>';
        h += '<div class="checkbox-item"><input type="checkbox" id="v-edu-field" data-k="multiselect_education_topic" data-mode="multiselect"><label for="v-edu-field">In what topic? <span class="multiselect-marker">*</span></label></div>';
        h += '<div class="multiselect-note">* Respondents could select multiple options</div>';
        h += '</div>';
        vc.innerHTML = h;
        addFreeTextSection(cat, vc);
        return;
    }
    // Moral features - radio button options (single selection only, but can be deselected)
    else if (cat === 'moral_features') {
        let h = '<div class="checkbox-group" id="vbox">';
        h += '<div class="checkbox-item"><input type="radio" name="mf-option" id="v-mf-important" data-k="multiselect_moral_considerations_important" data-mode="single"><label for="v-mf-important">What do you think is important for moral considerations? <span class="multiselect-marker">*</span></label></div>';
        h += '<div class="checkbox-item"><input type="radio" name="mf-option" id="v-mf-most" data-k="multiselect_moral_considerations_most" data-mode="single"><label for="v-mf-most">Which do you think is the most important for moral considerations?</label></div>';
        h += '<div class="checkbox-item"><input type="radio" name="mf-option" id="v-mf-stacked" data-mode="stacked"><label for="v-mf-stacked">Combined</label></div>';
        h += '<div class="multiselect-note">* Respondents could select multiple options</div>';
        h += '</div>';
        vc.innerHTML = h;
        
        // Add click handler to allow deselecting radio buttons
        const radios = vc.querySelectorAll('input[name="mf-option"]');
        radios.forEach(radio => {
            radio.addEventListener('click', function(e) {
                if (this.dataset.wasChecked === 'true') {
                    this.checked = false;
                    this.dataset.wasChecked = 'false';
                    showDist();  // Refresh display
                } else {
                    radios.forEach(r => r.dataset.wasChecked = 'false');
                    this.dataset.wasChecked = 'true';
                }
            });
        });
        
        addFreeTextSection(cat, vc);
        return;
    }
    
    let h = '<select id="dist-variable"><option value="">Select a question...</option>';
    opts.forEach(o => h += `<option value="${o.k}">${o.l}</option>`);
    vc.innerHTML = h + '</select>';
    
    // Add free text section if applicable
    addFreeTextSection(cat, vc);
}

// Helper to get free text questions for a category
function getFreeTextForCategory(cat) {
    const ftByTopic = DATA.metadata.free_text_by_topic || {};
    return ftByTopic[cat] || null;
}

// Helper to add free text section to the full-width container
function addFreeTextSection(cat, vc) {
    const ftInfo = getFreeTextForCategory(cat);
    const ftContainer = document.getElementById('free-text-container');
    
    // Check if we have free text questions or if this is kill_test (which has no_kill)
    const hasFreeText = ftInfo && ftInfo.questions && ftInfo.questions.length > 0;
    const isKillTest = cat === 'kill_test';
    const isEarthDanger = cat === 'earth_danger';
    const isICS = cat === 'ics';
    
    if (!hasFreeText && !isKillTest && !isEarthDanger && !isICS) {
        if (ftContainer) {
            ftContainer.style.display = 'none';
            ftContainer.innerHTML = '';
        }
        return;
    }
    
    let h = '<div class="free-text-section" style="padding:0.75rem 1rem;background:var(--bg-tertiary);border-radius:8px;margin-top:0.5rem;">';
    
    // For kill_test, add the "No Kill Reasons" section with title
    if (isKillTest) {
        h += '<div class="checkbox-section" style="font-size:0.8rem;margin-bottom:0.5rem;letter-spacing:0.5px;">When responding \'No\' to killing all entities:</div>';
        h += '<div class="checkbox-item" style="margin-bottom:0.75rem;padding-bottom:0.75rem;border-bottom:1px solid var(--border);"><input type="checkbox" id="v-nokill" data-k="multiselect_no_kill_reason" data-type="nokill"><label for="v-nokill" style="font-size:0.9rem;">You wouldn\'t eliminate any of the creatures; why? <span class="multiselect-marker">*</span></label></div>';
        h += '<div class="multiselect-note" style="margin-top:-0.5rem;margin-bottom:0.75rem;">* Respondents could select multiple options</div>';
    }
    
    // Free text questions section
    if (hasFreeText) {
        h += '<div class="checkbox-section" style="font-size:0.8rem;margin-bottom:0.5rem;letter-spacing:0.5px;">Free Text Responses in this Topic</div>';
        ftInfo.questions.forEach(([key, label], i) => {
            // Use single quotes for data attribute and escape double quotes within
            const escapedLabel = label.replace(/"/g, '&quot;');
            h += `<div class="checkbox-item"><input type="checkbox" id="ft-${i}" data-ft-key="${key}" data-ft-label="${escapedLabel}"><label for="ft-${i}" style="font-size:0.9rem;">${escHTML(label)}</label></div>`;
        });
    }
    
    // ICS - add calculated values section with ICS Group
    if (isICS) {
        if (hasFreeText) {
            h += '<div style="border-top:1px dashed var(--border);margin:0.75rem 0;"></div>';
        }
        h += '<div class="checkbox-section" style="font-size:0.8rem;margin-bottom:0.5rem;letter-spacing:0.5px;">Calculated Values</div>';
        h += '<div class="checkbox-item"><input type="checkbox" id="v-calc-ics-group" data-k="survey_group" data-type="calculated"><label for="v-calc-ics-group" style="font-size:0.9rem;">Grouping by conceptions of consciousness</label></div>';
        h += '<div class="checkbox-note" style="font-size:0.8rem;color:var(--text-muted);margin-left:1.5rem;margin-bottom:0.5rem;font-style:italic;">Participants were grouped based on their responses to whether consciousness can exist without goals and/or without feelings of pain and pleasure. This yielded four groups: Multidimensional (consciousness cannot exist without goals, nor without sensations), Cognitive-Agential (consciousness cannot exist without goals, but can without sensations), Experiential (consciousness can exist without goals, but not without sensations), and Other (consciousness can exist without both).</div>';
    }
    
    // Earth in Danger - add calculated values section with EiD Cluster
    if (isEarthDanger) {
        if (hasFreeText) {
            h += '<div style="border-top:1px dashed var(--border);margin:0.75rem 0;"></div>';
        }
        h += '<div class="checkbox-section" style="font-size:0.8rem;margin-bottom:0.5rem;letter-spacing:0.5px;">Calculated Values</div>';
        h += '<div class="checkbox-item"><input type="checkbox" id="v-calc-eid-cluster" data-k="survey_Cluster" data-type="calculated"><label for="v-calc-eid-cluster" style="font-size:0.9rem;">Clustering analysis results</label></div>';
        h += '<div class="checkbox-note" style="font-size:0.8rem;color:var(--text-muted);margin-left:1.5rem;margin-bottom:0.5rem;font-style:italic;">This data is the result of k-means clustering tested with k values between 2-4, with k=2 being the optimal solution based on a combination of silhouette score, permutation testing and 1-SE rule (the smallest k whose silhouette was within one bootstrap standard error of the maximal one, with SE estimated via nonparametric bootstrap of the silhouette over 1,000 iterations).</div>';
        h += '<div class="checkbox-item" style="margin-top:0.5rem;"><input type="checkbox" id="v-split-eid-cluster" data-type="split-cluster"><label for="v-split-eid-cluster" style="font-size:0.9rem;">Split responses by Cluster</label></div>';
    }
    
    h += '</div>';
    
    if (ftContainer) {
        ftContainer.innerHTML = h;
        ftContainer.style.display = 'block';
        
        // Add change listener to trigger refresh
        ftContainer.querySelectorAll('input').forEach(cb => {
            cb.addEventListener('change', () => {
                showDist();
                setTimeout(updateDownloadButton, 100);
            });
        });
        
        // Make clustering checkbox and split-by-cluster mutually exclusive (Earth in Danger only)
        const clusteringCheckbox = ftContainer.querySelector('#v-calc-eid-cluster');
        const splitClusterCheckbox = ftContainer.querySelector('#v-split-eid-cluster');
        if (clusteringCheckbox && splitClusterCheckbox) {
            // Add helper message elements inside the labels (so they stay inline)
            const clusteringLabel = clusteringCheckbox.nextElementSibling; // label
            const splitLabel = splitClusterCheckbox.nextElementSibling; // label
            
            // Create hint spans that will be appended inside the labels
            const clusteringMsg = document.createElement('span');
            clusteringMsg.className = 'mutex-hint';
            clusteringMsg.style.cssText = 'font-size:0.75rem;color:#8b949e;margin-left:0.5rem;display:none;font-weight:normal;';
            clusteringMsg.textContent = '(untick "Clustering analysis results" to enable)';
            splitLabel.appendChild(clusteringMsg);
            
            const splitMsg = document.createElement('span');
            splitMsg.className = 'mutex-hint';
            splitMsg.style.cssText = 'font-size:0.75rem;color:#8b949e;margin-left:0.5rem;display:none;font-weight:normal;';
            splitMsg.textContent = '(untick "Split responses by Cluster" to enable)';
            clusteringLabel.appendChild(splitMsg);
            
            clusteringCheckbox.addEventListener('change', () => {
                if (clusteringCheckbox.checked) {
                    splitClusterCheckbox.disabled = true;
                    splitClusterCheckbox.parentElement.style.opacity = '0.5';
                    clusteringMsg.style.display = 'inline';
                } else {
                    splitClusterCheckbox.disabled = false;
                    splitClusterCheckbox.parentElement.style.opacity = '1';
                    clusteringMsg.style.display = 'none';
                }
            });
            splitClusterCheckbox.addEventListener('change', () => {
                if (splitClusterCheckbox.checked) {
                    clusteringCheckbox.disabled = true;
                    clusteringCheckbox.parentElement.style.opacity = '0.5';
                    splitMsg.style.display = 'inline';
                } else {
                    clusteringCheckbox.disabled = false;
                    clusteringCheckbox.parentElement.style.opacity = '1';
                    splitMsg.style.display = 'none';
                }
            });
        }
    }
}

function populateCrosstabDropdowns() {
    const addOpts = sel => {
        if (DATA.metadata.question_groups) Object.entries(DATA.metadata.question_groups).forEach(([gn, cols]) => {
            const og = document.createElement('optgroup'); og.label = gn;
            Object.entries(DATA.metadata.survey_questions).forEach(([k, cn]) => {
                if (cols.includes(cn)) { const o = document.createElement('option'); o.value = `survey_${k}`; o.textContent = DN(cn).s; o.dataset.f = DN(cn).f; og.appendChild(o); }
            });
            if (og.children.length) sel.appendChild(og);
        });
        const dg = document.createElement('optgroup'); dg.label = 'Demographics';
        Object.entries(DATA.metadata.demographics || {}).forEach(([k, o]) => { const opt = document.createElement('option'); opt.value = `demo_${k}`; opt.textContent = DN(o.label).s; opt.dataset.f = DN(o.label).f; dg.appendChild(opt); });
        sel.appendChild(dg);
        const eg = document.createElement('optgroup'); eg.label = 'Experience Levels';
        Object.entries(DATA.metadata.experience_levels || {}).forEach(([k, o]) => { const opt = document.createElement('option'); opt.value = `exp_${k}`; opt.textContent = DN(o.label).s; opt.dataset.f = DN(o.label).f; eg.appendChild(opt); });
        sel.appendChild(eg);
    };
    addOpts(document.getElementById('cross-var1'));
    addOpts(document.getElementById('cross-var2'));
}

function populateFreetextDropdown() {
    const sel = document.getElementById('freetext-question');
    Object.entries(DATA.metadata.free_text_questions || {}).forEach(([k, l]) => {
        if (DATA.freetext[k]) { const nm = DN(l); sel.innerHTML += `<option value="${k}" data-f="${nm.f}">${nm.s}</option>`; }
    });
}

function setupEvents() {
    document.querySelectorAll('.tab').forEach(t => t.addEventListener('click', () => {
        document.querySelectorAll('.tab').forEach(x => x.classList.remove('active'));
        document.querySelectorAll('.panel').forEach(x => x.classList.remove('active'));
        t.classList.add('active'); document.getElementById(t.dataset.panel).classList.add('active');
    }));
    const hb = document.getElementById('hamburger'), sp = document.getElementById('side-panel'), ov = document.getElementById('overlay');
    hb.addEventListener('click', () => { hb.classList.toggle('active'); sp.classList.toggle('active'); ov.classList.toggle('active'); });
    ov.addEventListener('click', () => { hb.classList.remove('active'); sp.classList.remove('active'); ov.classList.remove('active'); });
    
    // Auto-refresh on category change
    document.getElementById('dist-category').addEventListener('change', () => {
        updateVariableUI();
        syncFilterHeights();
        showDist();
        setTimeout(updateDownloadButton, 100);
    });
    
    // Auto-refresh on sample filter changes
    document.getElementById('sample-filter-box').addEventListener('change', () => {
        showDist();
        setTimeout(updateDownloadButton, 100);
    });
    
    // Auto-refresh on variable container changes (checkboxes and dropdowns)
    document.getElementById('variable-container').addEventListener('change', () => {
        showDist();
        setTimeout(updateDownloadButton, 100);
    });
    
    // Auto-refresh on free-text container changes
    document.getElementById('free-text-container').addEventListener('change', () => {
        console.log('[free-text-container] Change event fired');
        showDist();
        setTimeout(updateDownloadButton, 100);
    });
    
    document.getElementById('cross-show').addEventListener('click', showCross);
    document.getElementById('freetext-show').addEventListener('click', showFreetext);
    document.getElementById('freetext-search').addEventListener('input', filterFreetext);
}

function destroyCharts() { 
    Object.values(charts).forEach(c => c?.destroy()); 
    charts = {}; 
    // Hide external tooltip when charts are destroyed
    const tooltipEl = document.getElementById('chartjs-tooltip');
    if (tooltipEl) tooltipEl.style.opacity = 0;
}

// External tooltip handler for split charts (avoids clipping by container)
function getOrCreateTooltip(chart) {
    let tooltipEl = document.getElementById('chartjs-tooltip');
    if (!tooltipEl) {
        tooltipEl = document.createElement('div');
        tooltipEl.id = 'chartjs-tooltip';
        document.body.appendChild(tooltipEl);
    }
    return tooltipEl;
}

function externalTooltipHandler(context) {
    const {chart, tooltip} = context;
    const tooltipEl = getOrCreateTooltip(chart);
    
    // Hide if no tooltip
    if (tooltip.opacity === 0) {
        tooltipEl.style.opacity = 0;
        return;
    }
    
    // Set tooltip content
    if (tooltip.body) {
        const titleLines = tooltip.title || [];
        const bodyLines = tooltip.body.map(b => b.lines);
        
        let innerHtml = '';
        if (titleLines.length > 0) {
            innerHtml += `<div class="tooltip-title">${titleLines.join('<br>')}</div>`;
        }
        innerHtml += '<div class="tooltip-body">';
        bodyLines.forEach(lines => {
            lines.forEach(line => {
                innerHtml += `<div>${line}</div>`;
            });
        });
        innerHtml += '</div>';
        tooltipEl.innerHTML = innerHtml;
    }
    
    // Position tooltip - use page coordinates to avoid container clipping
    const canvasRect = chart.canvas.getBoundingClientRect();
    const tooltipX = canvasRect.left + window.scrollX + tooltip.caretX;
    const tooltipY = canvasRect.top + window.scrollY + tooltip.caretY;
    
    tooltipEl.style.opacity = 1;
    tooltipEl.style.left = tooltipX + 'px';
    tooltipEl.style.top = tooltipY + 'px';
}

// Helper to capitalize labels for certain categories (EiD Cluster, ICS Group)
function capitalizeLabel(label) {
    if (!label || typeof label !== 'string') return label;
    // Capitalize each word
    return label.split('-').map(word => 
        word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()
    ).join('-');
}

// Map dropdown display names to title names for consistency
function getTitleName(dropdownText) {
    const titleMap = {
        'Earth is in Danger': 'Earth in Danger',
        'Separating Consciousness from Intentions and Valence': 'Intentions, Consciousness, Sensations',
        'An Important Test': 'Kill to Pass a Test',
        'Consciousness and Moral Considerations': 'Moral Considerations'
        // Others stay the same: Graded Consciousness, Consciousness & Intelligence, etc.
    };
    return titleMap[dropdownText] || dropdownText;
}

// Global helper to strip parenthetical content from tooltip labels
// Use this for hover labels to keep them concise while showing full info elsewhere
function stripTooltipParens(label) {
    if (!label || typeof label !== 'string') return label;
    return label.replace(/\s*\([^)]*\)/g, '').trim();
}

// Check if labels need capitalization (for EiD Cluster, ICS Group)
function shouldCapitalizeLabels(labels) {
    const clusterLabels = ['anthropocentric', 'non-anthropocentric'];
    const icsLabels = ['cognitive-agential', 'experiential', 'multidimensional', 'other'];
    const allLower = labels.map(l => l.toLowerCase());
    return allLower.some(l => clusterLabels.includes(l) || icsLabels.includes(l));
}

function getColors(labels, scaleType = null) {
    const c = DATA.metadata.colors || {};
    
    // Helper to convert to integer string (handles floats like '1.0' -> '1')
    const toIntStr = l => String(parseInt(parseFloat(l)));
    
    // If specific scale type requested, use it
    if (scaleType === 'graded' && labels.every(l => ['1','2','3','4'].includes(toIntStr(l)))) {
        return labels.map(l => c.graded_scale?.[toIntStr(l)] || '#58a6ff');
    }
    if (scaleType === 'experience' && labels.every(l => ['1','2','3','4','5'].includes(toIntStr(l)))) {
        return labels.map(l => c.experience_scale?.[toIntStr(l)] || '#58a6ff');
    }
    if (scaleType === 'agreement' && labels.every(l => ['1','2','3','4'].includes(toIntStr(l)))) {
        return labels.map(l => c.agreement_scale?.[toIntStr(l)] || '#58a6ff');
    }
    
    // Rating scale (1-4) - check FIRST before experience scale
    // This is for consciousness/moral status attributions
    if (labels.length <= 4 && labels.every(l => ['1','2','3','4'].includes(toIntStr(l)))) {
        return labels.map(l => c.rating_scale?.[toIntStr(l)] || '#58a6ff');
    }
    // Experience scale (1-5)
    if (labels.every(l => ['1','2','3','4','5'].includes(toIntStr(l)))) {
        return labels.map(l => c.experience_scale?.[toIntStr(l)] || '#58a6ff');
    }
    // Earth in Danger answers
    if (c.earth_danger && labels.some(l => c.earth_danger[l])) {
        return labels.map(l => c.earth_danger[l] || '#58a6ff');
    }
    // Kill answers (Yes/No with parentheses)
    if (c.kill && labels.some(l => l.includes('kill to pass the test'))) {
        return labels.map(l => c.kill[l] || '#58a6ff');
    }
    // Yes/No (simple)
    if (c.yes_no && labels.every(l => c.yes_no[l])) {
        return labels.map(l => c.yes_no[l]);
    }
    // C&I Share colors
    if (c.c_intel_share && labels.some(l => c.c_intel_share[l])) {
        return labels.map(l => c.c_intel_share[l] || '#58a6ff');
    }
    // EiD Cluster colors
    if (c.eid_cluster && labels.some(l => c.eid_cluster[l] || c.eid_cluster[l.toLowerCase()])) {
        return labels.map(l => c.eid_cluster[l] || c.eid_cluster[l.toLowerCase()] || '#58a6ff');
    }
    // ICS Group colors
    if (c.ics_group && labels.some(l => c.ics_group[l] || c.ics_group[l.toLowerCase()])) {
        return labels.map(l => c.ics_group[l] || c.ics_group[l.toLowerCase()] || '#58a6ff');
    }
    // Education background colors
    if (c.education && labels.some(l => c.education[l])) {
        return labels.map(l => c.education[l] || '#58a6ff');
    }
    // Moral features colors
    if (c.moral_features && labels.some(l => c.moral_features[l])) {
        return labels.map(l => c.moral_features[l] || '#58a6ff');
    }
    // Animal types colors
    if (c.animal_types && labels.some(l => c.animal_types[l])) {
        return labels.map(l => c.animal_types[l] || '#58a6ff');
    }
    // Gender colors
    if (c.gender && labels.some(l => c.gender[l])) {
        return labels.map(l => c.gender[l] || '#4a9b9e');
    }
    // Age colors (check for age ranges)
    if (c.age && labels.some(l => c.age[l])) {
        return labels.map(l => c.age[l] || '#4a9b9e');
    }
    const def = ['#58a6ff','#1f6feb','#388bfd','#79c0ff','#0d419d','#1158c7'];
    return labels.map((_, i) => def[i % def.length]);
}

function buildRatingLegend(scaleType = 'rating', title = '') {
    const c = DATA.metadata.colors || {};
    let labels, colorKey;
    
    if (scaleType === 'graded') {
        labels = GL;
        colorKey = 'graded_scale';
    } else if (scaleType === 'agreement') {
        labels = AL;
        colorKey = 'agreement_scale';
    } else if (scaleType === 'experience') {
        labels = EL;
        colorKey = 'experience_scale';
    } else {
        labels = RL;
        colorKey = 'rating_scale';
    }
    
    const colors = c[colorKey] || {};
    let h = '<div class="legend-bar">';
    if (title) {
        // Title styled gray, not bold
        h += `<span class="legend-title" style="font-weight:normal;color:var(--text-muted);">${title}</span>`;
    }
    const sortedKeys = Object.keys(labels).sort((a, b) => parseInt(a) - parseInt(b));
    sortedKeys.forEach(k => {
        const v = labels[k];
        const color = colors[k] || '#58a6ff';
        // For graded scale, just show the number
        // For experience scale, show "k: label" only if label differs from k
        let label;
        if (scaleType === 'graded') {
            label = v;
        } else if (scaleType === 'experience') {
            label = (v === k) ? k : `${k}: ${v}`;
        } else {
            label = `${k}: ${v}`;
        }
        h += `<span class="legend-item"><span class="legend-color" style="background:${color}"></span>${label}</span>`;
    });
    h += '</div>';
    return h;
}

function buildCustomLegend(data, title = null) {
    // Use getCanonicalKeyOrder for consistent ordering (handles Yes/No, education, age groups, etc.)
    let labels = getCanonicalKeyOrder(Object.keys(data));
    
    // Capitalize labels for EiD Cluster and ICS Group
    const needsCapitalize = shouldCapitalizeLabels(labels);
    const displayLabels = needsCapitalize ? labels.map(capitalizeLabel) : labels;
    
    const colors = getColors(labels);
    let h = '<div class="legend-bar">';
    if (title) {
        // Title styled gray, not bold
        h += `<span class="legend-title" style="font-weight:normal;margin-right:0.75rem;color:var(--text-muted);">${title}</span>`;
    }
    displayLabels.forEach((l, i) => {
        h += `<span class="legend-item"><span class="legend-color" style="background:${colors[i]}"></span>${l}</span>`;
    });
    h += '</div>';
    return h;
}

function buildChartCellLegend(data, scaleType = 'rating') {
    let labels = Object.keys(data);
    
    // Get the appropriate label map
    const labelMap = scaleType === 'graded' ? GL : (scaleType === 'agreement' ? AL : (scaleType === 'experience' ? EL : RL));
    
    // Check if numeric (could be floats like 1.0, 2.0 or strings '1', '2')
    // But exclude age ranges like "18-25" which contain dashes
    const hasDash = labels.some(l => l.includes('-'));
    const isNumeric = !hasDash && labels.every(l => !isNaN(parseFloat(l)));
    const isRating = labels.every(l => ['1','2','3','4'].includes(String(parseInt(parseFloat(l)))));
    const isExperience = labels.every(l => ['1','2','3','4','5'].includes(String(parseInt(parseFloat(l)))));
    
    // Sort - use getCanonicalKeyOrder for consistent ordering (handles Yes/No, education, etc.)
    labels = getCanonicalKeyOrder(labels);
    
    // Check if labels need capitalization (EiD Cluster, ICS Group)
    const needsCapitalize = shouldCapitalizeLabels(labels);
    
    const colors = getColors(labels, scaleType);
    let h = '<div class="chart-cell-legend">';
    labels.forEach((l, i) => {
        // For custom (demographics etc), use the label as-is
        // For rating scales, convert to int and look up label
        const displayVal = (scaleType === 'custom' || hasDash) ? l : (isNumeric ? String(parseInt(parseFloat(l))) : l);
        const labelText = labelMap[displayVal] || displayVal;
        let label;
        if (scaleType === 'graded') {
            label = displayVal;
        } else if (scaleType === 'experience' && labelText === displayVal) {
            label = displayVal;
        } else if ((isRating || isExperience) && scaleType !== 'custom') {
            label = `${displayVal}: ${labelText}`;
        } else {
            label = needsCapitalize ? capitalizeLabel(l) : l;  // Capitalize EiD Cluster, ICS Group labels
        }
        h += `<span class="legend-item"><span class="legend-color" style="background:${colors[i]}"></span>${label}</span>`;
    });
    h += '</div>';
    return h;
}

function showDist() {
    destroyCharts();
    const cat = document.getElementById('dist-category').value;
    const { splitBySample, splitBySource, splitByCluster } = getSplitConfig();
    const isSplitMode = splitBySample || splitBySource || splitByCluster;
    
    // For split mode, use new split data function
    if (isSplitMode) {
        showDistSplit(cat);
        return;
    }
    
    // Non-split mode - use existing logic
    const filter = getFilter();
    const {d: dists, n: totalN, e: entityStats, k: filterKey, rc: respondentCounts} = filter;
    
    // Clear free text area initially
    const ftArea = document.getElementById('dist-freetext-area');
    if (ftArea) {
        ftArea.style.display = 'none';
        ftArea.innerHTML = '';
    }
    
    // Check actual filter checkbox selections
    const box = document.getElementById('sample-filter-box');
    const isAllSelected = document.getElementById('f-none')?.checked;
    const followUpCheckbox = box?.querySelector('input[data-v="follow-up"]');
    const isFollowUpChecked = followUpCheckbox?.checked || false;
    
    // Count how many sample checkboxes are checked
    const sampleCheckboxes = box?.querySelectorAll('input[data-t="sample"]:checked') || [];
    const isFollowUpOnly = isFollowUpChecked && sampleCheckboxes.length === 1 && 
        Array.from(sampleCheckboxes).every(cb => cb.dataset.v === 'follow-up');
    
    // Categories that were NOT asked in follow-up
    const notInFollowup = DATA.metadata.not_in_followup || [];
    const categoryNotInFollowup = notInFollowup.includes(cat);
    
    // Helper to calculate actual N from distribution data
    const calcNFromData = (data) => {
        if (!data) return 0;
        return Object.values(data).reduce((sum, v) => {
            return sum + (typeof v === 'number' ? v : 0);
        }, 0);
    };
    
    // Helper to get respondent count for a key (for multiselect questions)
    const getRespondentCount = (key) => {
        return respondentCounts?.[key] || null;
    };
    
    // Helper to check if data has suppressed values (k<5)
    const hasSuppressedValues = (data) => {
        if (!data) return false;
        return Object.values(data).some(v => typeof v === 'string' && v.startsWith('<'));
    };
    
    // Build badge - will be updated with actual N later
    // For now, create a function that builds the badge with the correct N
    const buildBadge = (actualN, hasData, data = null) => {
        let b = ` <span class="filter-badge">N=${actualN}</span>`;
        
        // If follow-up only AND category not in follow-up - just show N=0, no note (the "Data not available" message will show)
        if (isFollowUpOnly && categoryNotInFollowup) {
            return ` <span class="filter-badge">N=0</span>`;
        }
        // If all respondents or follow-up is included AND category not in follow-up
        if ((isAllSelected || isFollowUpChecked) && categoryNotInFollowup) {
            b += `<span class="filter-note note-block">${NOTE_FOLLOWUP_EXCLUDED}</span>`;
        }
        // Single variable distributions no longer have k-anonymity suppression
        // (suppression only applies to crosstabs)
        
        return b;
    };
    
    const chartArea = document.getElementById('dist-chart-area');
    const tableArea = document.getElementById('dist-table-container');
    const legendArea = document.getElementById('dist-legend-area');
    
    legendArea.innerHTML = '';
    
    if (!cat) { document.getElementById('dist-title').textContent = 'Please select a topic'; chartArea.innerHTML = ''; tableArea.innerHTML = ''; return; }
    
    // For follow-up only on non-followup category, show empty state with explanation
    if (isFollowUpOnly && categoryNotInFollowup) {
        const badge = buildBadge(0, false);
        document.getElementById('dist-title').innerHTML = 'No Data Available' + badge;
        chartArea.innerHTML = '<p class="no-data"><em>Data not available: this sample was not presented with these questions</em></p>';
        tableArea.innerHTML = '';
        return;
    }
    
    // MS Attributions
    if (cat === 'ms_attr') {
        const sel = getSelectedEntities('ms');
        if (sel.length === 0) { document.getElementById('dist-title').textContent = 'Please select at least one entity'; chartArea.innerHTML = ''; tableArea.innerHTML = ''; return; }
        // Calculate N from first entity's data
        const firstData = sel.length > 0 ? dists[`ms_${sel[0].entity}`] : null;
        const actualN = firstData ? calcNFromData(firstData) : totalN;
        showEntityDonuts(sel, 'ms', dists, buildBadge(actualN, !!firstData), legendArea);
        return;
    }
    
    // C Attributions
    if (cat === 'c_attr') {
        const sel = getSelectedEntities('c');
        if (sel.length === 0) { document.getElementById('dist-title').textContent = 'Please select at least one entity'; chartArea.innerHTML = ''; tableArea.innerHTML = ''; return; }
        const firstData = sel.length > 0 ? dists[`c_${sel[0].entity}`] : null;
        const actualN = firstData ? calcNFromData(firstData) : totalN;
        showEntityDonuts(sel, 'c', dists, buildBadge(actualN, !!firstData), legendArea);
        return;
    }
    
    // Combined Attributions (scatter)
    if (cat === 'combined_attr') {
        const sel = getSelectedEntities('combined');
        if (sel.length === 0) { document.getElementById('dist-title').textContent = 'Please select at least one entity'; chartArea.innerHTML = ''; tableArea.innerHTML = ''; return; }
        // For combined, use the paired_n from entity stats
        const firstStats = sel.length > 0 ? entityStats[sel[0].entity] : null;
        const actualN = firstStats?.paired_n || totalN;
        // Get display mode
        const displayModeRadio = document.querySelector('input[name="display-mode"]:checked');
        const displayMode = displayModeRadio?.value || 'mean';
        showCombinedScatter(sel, entityStats, buildBadge(actualN, !!firstStats), legendArea, displayMode);
        return;
    }
    
    // Kill for Test - special handling with nested entity questions and No Kill Reasons
    if (cat === 'kill_test') {
        const vbox = document.getElementById('vbox');
        const entityChecks = vbox ? Array.from(vbox.querySelectorAll('.kpt-entity:checked')) : [];
        
        // No Kill checkbox is now in the free-text-container
        const ftContainer = document.getElementById('free-text-container');
        const noKillCheck = ftContainer ? ftContainer.querySelector('#v-nokill:checked') : null;
        const hasFreeText = ftContainer && ftContainer.querySelectorAll('input[data-ft-key]:checked').length > 0;
        
        if (entityChecks.length === 0 && !noKillCheck) {
            if (hasFreeText) {
                // No main questions but free text selected - show only free text
                let ftTitle = `Kill to Pass a Test: Free Text Responses`;
                // Add follow-up note if relevant (kill_test is in notInFollowup)
                if (categoryNotInFollowup && (isAllSelected || isFollowUpChecked) && !isFollowUpOnly) {
                    ftTitle += `<span class="filter-note note-block">${NOTE_FOLLOWUP_EXCLUDED}</span>`;
                }
                document.getElementById('dist-title').innerHTML = ftTitle;
                chartArea.innerHTML = '';
                tableArea.innerHTML = '';
                showDistFreeText(filterKey);
                return;
            }
            document.getElementById('dist-title').textContent = 'Please select at least one question';
            chartArea.innerHTML = '';
            tableArea.innerHTML = '';
            return;
        }
        
        // Build selections
        const entitySel = entityChecks.map(cb => ({k: cb.dataset.k, c: cb.dataset.c, l: cb.nextElementSibling.textContent}));
        
        // If only No Kill Reasons is selected
        if (entityChecks.length === 0 && noKillCheck) {
            const key = 'multiselect_no_kill_reason';
            const data = dists[key];
            const exclusiveData = dists['multiselect_no_kill_reason_exclusive'] || {};
            console.log('[KPT NoKill] All dists keys:', Object.keys(dists).slice(0, 20));
            console.log('[KPT NoKill] data:', data ? Object.keys(data).length + ' options' : 'null');
            console.log('[KPT NoKill] exclusiveData:', exclusiveData, 'has values:', Object.keys(exclusiveData).length > 0);
            const dataN = getRespondentCount(key) || (data ? calcNFromData(data) : 0);
            let mselectBadge = ` <span class="filter-badge">N=${dataN}</span>`;
            // Add Follow-up exclusion note first (if relevant)
            if ((isAllSelected || isFollowUpChecked) && !isFollowUpOnly) {
                mselectBadge += `<span class="filter-note note-block">${NOTE_FOLLOWUP_EXCLUDED}</span>`;
            }
            // Then add the no-kill reason note
            mselectBadge += `<span class="filter-note note-block">${NOTE_NOKILL_REASON}</span>`;
            document.getElementById('dist-title').innerHTML = 'You wouldn\'t eliminate any of the creatures; why?' + mselectBadge;
            legendArea.innerHTML = '';
            if (!data || Object.keys(data).length === 0) {
                chartArea.innerHTML = '<p class="no-data"><em>Data not available: this sample was not presented with this question</em></p>';
                tableArea.innerHTML = '';
                showDistFreeText(filterKey);  // Still show free text if selected
                return;
            }
            showHorizontalBarChart(data, 'You wouldn\'t eliminate any of the creatures; why?', dataN, exclusiveData);
            showDistFreeText(filterKey);  // Show free text responses if any selected
            return;
        }
        
        // If only entity questions selected (no No Kill Reasons)
        if (entityChecks.length > 0 && !noKillCheck) {
            const firstData = entitySel.length > 0 ? dists[entitySel[0].k] : null;
            const actualN = firstData ? calcNFromData(firstData) : 0;
            const badge = buildBadge(actualN, !!firstData);
            // Single question fills full row, 2 questions use cols-2, 3+ use cols-3
            const gridClass = entitySel.length === 1 ? 'cols-1' : (entitySel.length <= 2 ? 'cols-2' : 'cols-3');
            showMultiDist(entitySel, dists, badge, gridClass, legendArea, 'kill_test');
            showDistFreeText(filterKey);
            return;
        }
        
        // Both entity questions and No Kill Reasons selected
        const firstData = entitySel.length > 0 ? dists[entitySel[0].k] : null;
        const actualN = firstData ? calcNFromData(firstData) : 0;
        const badge = buildBadge(actualN, !!firstData);
        
        document.getElementById('dist-title').innerHTML = `Kill to Pass a Test: ${entitySel.length + 1} Questions${badge}`;
        
        // Create grid for entity donuts, then horizontal bar for No Kill Reasons
        // Single entity fills full row, 2 entities use cols-2, 3+ use cols-3
        const gridClass = entitySel.length === 1 ? 'cols-1' : (entitySel.length <= 2 ? 'cols-2' : 'cols-3');
        let htmlParts = [];
        htmlParts.push(`<div class="chart-grid ${gridClass}" id="cgrid-kpt"></div>`);
        
        // Add No Kill Reasons section with increased font sizes (since it's in its own row with plenty of space)
        const noKillData = dists['multiselect_no_kill_reason'];
        const noKillN = getRespondentCount('multiselect_no_kill_reason') || (noKillData ? calcNFromData(noKillData) : 0);
        htmlParts.push(`<div class="special-demo-section" style="margin-top:1.5rem;">
            <h4 style="text-align:center;margin:0 0 0.5rem;color:var(--text-secondary);font-size:1.15rem;">You wouldn't eliminate any of the creatures; why? <span class="filter-badge" style="font-weight:normal;font-size:0.85rem;color:#e6edf3;">N=${noKillN}</span></h4>
            <p style="text-align:center;font-size:0.85rem;color:var(--text-muted);margin-bottom:0.5rem">Only respondents who answered "No" to ALL killing questions were asked this question</p>
            <div class="chart-container" style="height:350px"><canvas id="c-nokill"></canvas></div>
        </div>`);
        
        chartArea.innerHTML = htmlParts.join('');
        legendArea.innerHTML = '';  // No global legend for mixed view
        
        // Create donut charts for entities with per-cell legends
        const grid = document.getElementById('cgrid-kpt');
        entitySel.forEach((o, i) => {
            const data = dists[o.k];
            if (!data) return;
            
            const cell = document.createElement('div');
            cell.className = 'chart-cell';
            const cellLegend = buildChartCellLegend(data, 'rating');
            // Add prefix for KPT entity descriptions
            const titlePrefix = 'A creature/system that ';
            cell.innerHTML = `<h4>${titlePrefix}${o.l}</h4>${cellLegend}<canvas id="c-kpt-${i}"></canvas>`;
            grid.appendChild(cell);
            
            // KPT questions have binary yes/no responses, not 1-4 ratings
            // Keys are the actual response labels (e.g., "Yes (will kill...)", "No (will not...)")
            const keys = Object.keys(data).sort((a, b) => {
                // Sort so "Yes" comes before "No" (for consistent display - Yes on left in legend)
                const aIsYes = a.toLowerCase().startsWith('yes');
                const bIsYes = b.toLowerCase().startsWith('yes');
                if (aIsYes && !bIsYes) return -1;
                if (!aIsYes && bIsYes) return 1;
                return a.localeCompare(b);
            });
            // Use simplified labels for display (strip parenthetical content)
            const simplifyLabel = l => l.replace(/\s*\([^)]*\)/g, '').trim();
            const labels = keys.map(l => simplifyLabel(l));
            const values = keys.map(k => typeof data[k] === 'number' ? data[k] : 0);
            const total = values.reduce((a, b) => a + b, 0);
            
            charts[`c-kpt-${i}`] = new Chart(document.getElementById(`c-kpt-${i}`).getContext('2d'), {
                type: 'doughnut',
                data: {labels, datasets: [{data: values, backgroundColor: getColors(keys, 'binary'), borderWidth: 0}]},
                options: {responsive: true, plugins: {legend: {display: false}, tooltip: {callbacks: {
                    title: ctx => ctx[0].chart.data.labels[ctx[0].dataIndex] || '',
                    label: ctx => {
                        const sliceLabel = ctx.chart.data.labels[ctx.dataIndex] || '';
                        return `${sliceLabel}: ${ctx.raw} (${((ctx.raw/total)*100).toFixed(1)}%)`;
                    }
                }}}}
            });
        });
        
        // Create horizontal bar chart for No Kill Reasons (always stacked when exclusive data available)
        if (noKillData) {
            const sortedEntries = Object.entries(noKillData)
                .filter(([k, v]) => typeof v === 'number')
                .sort((a, b) => b[1] - a[1]);
            const labels = sortedEntries.map(([k]) => k);
            const values = sortedEntries.map(([, v]) => v);
            
            // Get exclusive data for stacked bars
            const exclusiveData = dists['multiselect_no_kill_reason_exclusive'] || {};
            const hasExclusiveData = Object.keys(exclusiveData).length > 0 && 
                Object.values(exclusiveData).some(v => typeof v === 'number' && v > 0);
            
            if (hasExclusiveData) {
                // Stacked bar chart
                const exclusiveValues = labels.map(k => exclusiveData[k] || 0);
                const nonExclusiveValues = values.map((v, i) => Math.max(0, v - exclusiveValues[i]));
                
                charts['c-nokill'] = new Chart(document.getElementById('c-nokill').getContext('2d'), {
                    type: 'bar',
                    data: {
                        labels, 
                        datasets: [
                            {label: 'Only this option', data: exclusiveValues, backgroundColor: '#4a9b9e', borderWidth: 0},
                            {label: 'With other options', data: nonExclusiveValues, backgroundColor: 'rgba(74,155,158,0.4)', borderWidth: 0}
                        ]
                    },
                    options: {
                        indexAxis: 'y',
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {display: false}, 
                            tooltip: {callbacks: {
                                label: ctx => {
                                    const total = values[ctx.dataIndex];
                                    const exclusive = exclusiveValues[ctx.dataIndex];
                                    if (ctx.datasetIndex === 0) {
                                        return `Only this: ${exclusive} (${((exclusive/noKillN)*100).toFixed(1)}%)`;
                                    } else {
                                        return `With others: ${total - exclusive} (${((total - exclusive)/noKillN*100).toFixed(1)}%)`;
                                    }
                                },
                                afterBody: ctx => `Total: ${values[ctx[0].dataIndex]} (${((values[ctx[0].dataIndex]/noKillN)*100).toFixed(1)}%)`
                            }}
                        },
                        scales: {
                            x: {stacked: true, beginAtZero: true, grid: {color: '#30363d'}, ticks: {color: '#8b949e', font: {size: 13}}}, 
                            y: {stacked: true, grid: {display: false}, ticks: {color: '#e6edf3', autoSkip: false, font: {size: 14}}}
                        }
                    }
                });
            } else {
                // Standard bar chart (fallback)
                charts['c-nokill'] = new Chart(document.getElementById('c-nokill').getContext('2d'), {
                    type: 'bar',
                    data: {labels, datasets: [{data: values, backgroundColor: '#4a9b9e', borderWidth: 0}]},
                    options: {
                        indexAxis: 'y',
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {legend: {display: false}, tooltip: {callbacks: {label: ctx => `${ctx.raw} (${((ctx.raw/noKillN)*100).toFixed(1)}%)`}}},
                        scales: {x: {beginAtZero: true, grid: {color: '#30363d'}, ticks: {color: '#8b949e', font: {size: 13}}}, y: {grid: {display: false}, ticks: {color: '#e6edf3', autoSkip: false, font: {size: 14}}}}
                    }
                });
            }
        }
        
        tableArea.innerHTML = '<p class="no-data">Select individual questions for detailed tables</p>';
        showDistFreeText(filterKey);
        return;
    }
    
    // Checkbox group categories
    const checkboxCats = ['earth_danger', 'ics', 'moral_cons', 'graded_c', 'c_intel'];
    const checkboxCatNames = {
        'earth_danger': 'Earth in Danger',
        'ics': 'Intentions, Consciousness, Sensations',
        'moral_cons': 'Moral Considerations',
        'graded_c': 'Graded Consciousness',
        'c_intel': 'Consciousness & Intelligence'
    };
    if (checkboxCats.includes(cat)) {
        const vbox = document.getElementById('vbox');
        let sel = vbox ? Array.from(vbox.querySelectorAll('input:checked:not(#v-all)')).map(cb => ({k: cb.dataset.k, c: cb.dataset.c, l: cb.nextElementSibling.textContent})) : [];
        
        // Check for calculated value checkboxes
        if (cat === 'ics') {
            const icsGroupCb = document.getElementById('v-calc-ics-group');
            if (icsGroupCb?.checked) {
                sel.push({
                    k: 'survey_group',
                    c: 'group',
                    l: 'Grouping by conceptions of consciousness'
                });
            }
        } else if (cat === 'earth_danger') {
            const eidClusterCb = document.getElementById('v-calc-eid-cluster');
            if (eidClusterCb?.checked) {
                sel.push({
                    k: 'survey_Cluster',
                    c: 'Cluster',
                    l: 'Clustering analysis results'
                });
            }
        }
        
        // Check if free text is selected (only #ft-box inputs)
        const ftContainer = document.getElementById('free-text-container');
        const hasFreeText = ftContainer && ftContainer.querySelectorAll('input[data-ft-key]:checked').length > 0;
        
        // Check if this category was not in follow-up
        const categoryNotInFollowup = notInFollowup.includes(cat);
        
        if (sel.length === 0) {
            if (hasFreeText) {
                // No main questions but free text selected - show only free text
                let ftTitle = `${checkboxCatNames[cat] || cat}: Free Text Responses`;
                // Add follow-up note if relevant
                if (categoryNotInFollowup && (isAllSelected || isFollowUpChecked) && !isFollowUpOnly) {
                    ftTitle += `<span class="filter-note note-block">${NOTE_FOLLOWUP_EXCLUDED}</span>`;
                }
                document.getElementById('dist-title').innerHTML = ftTitle;
                chartArea.innerHTML = '';
                tableArea.innerHTML = '';
                showDistFreeText(filterKey);
                return;
            }
            document.getElementById('dist-title').textContent = 'Please select at least one question';
            chartArea.innerHTML = '';
            tableArea.innerHTML = '';
            return;
        }
        
        // Calculate actual N from first question's data
        const firstData = sel.length > 0 ? dists[sel[0].k] : null;
        const actualN = firstData ? calcNFromData(firstData) : 0;
        let badge = buildBadge(actualN, !!firstData);
        
        // For moral_cons, check if any selected questions are not in Follow-up
        // Questions like "Some people > others?" and "Some animals > others?" were not asked in Follow-up
        if (cat === 'moral_cons' && (isAllSelected || isFollowUpChecked) && !isFollowUpOnly) {
            const questionsNotInFollowup = DATA.metadata.questions_not_in_followup || [];
            const hasQuestionsNotInFollowup = sel.some(o => questionsNotInFollowup.some(q => o.l.includes(q)));
            if (hasQuestionsNotInFollowup) {
                badge = ` <span class="filter-badge">N=${actualN}</span>`;
                badge += `<span class="filter-note note-block">NOTE: Data excludes Follow-up sample for some questions (not asked this question)</span>`;
            }
        }
        
        // Earth in Danger and Kill for Test: max 3 columns
        const max3Cols = ['earth_danger'];
        let gridClass;
        if (sel.length === 1) {
            gridClass = '';  // Single item - full width
        } else if (max3Cols.includes(cat)) {
            gridClass = sel.length === 2 ? 'cols-2' : 'cols-3';
        } else {
            gridClass = sel.length === 2 ? 'cols-2' : (sel.length === 3 ? 'cols-3' : 'cols-4');
        }
        showMultiDist(sel, dists, badge, gridClass, legendArea, cat);
        showDistFreeText(filterKey);
        return;
    }
    
    // Unified Experience category
    if (cat === 'experience') {
        const vbox = document.getElementById('vbox');
        const checkedInputs = vbox ? Array.from(vbox.querySelectorAll('input:checked:not(#v-all)')) : [];
        
        // Check if free text is selected
        const ftContainer = document.getElementById('free-text-container');
        const hasFreeText = ftContainer && ftContainer.querySelectorAll('input:checked').length > 0;
        
        if (checkedInputs.length === 0) {
            if (hasFreeText) {
                // No main questions but free text selected - show only free text
                document.getElementById('dist-title').innerHTML = `Experience: Free Text Responses`;
                chartArea.innerHTML = '';
                tableArea.innerHTML = '';
                showDistFreeText(filterKey);
                return;
            }
            document.getElementById('dist-title').textContent = 'Please select at least one question';
            chartArea.innerHTML = '';
            tableArea.innerHTML = '';
            return;
        }
        
        // Separate levels and sources - strip asterisks from source labels (asterisks are only for checkbox display)
        const stripAsterisk = (text) => (text || '').replace(/\s*\*\s*$/, '').trim();
        const levels = checkedInputs.filter(cb => cb.dataset.type === 'level').map(cb => ({k: cb.dataset.k, c: cb.dataset.c, l: cb.nextElementSibling.textContent}));
        const sources = checkedInputs.filter(cb => cb.dataset.type === 'source').map(cb => ({k: cb.dataset.k, c: cb.dataset.c, l: stripAsterisk(cb.nextElementSibling.textContent)}));
        
        // Calculate actual N from first item's data
        // For sources (multiselect), use respondent count; for levels, use calcNFromData
        const firstKey = checkedInputs[0]?.dataset.k;
        const firstData = firstKey ? dists[firstKey] : null;
        const firstIsSource = checkedInputs[0]?.dataset.type === 'source';
        const actualN = firstIsSource ? 
            (getRespondentCount(firstKey) || (firstData ? calcNFromData(firstData) : 0)) :
            (firstData ? calcNFromData(firstData) : 0);
        
        // Check if sources are selected
        const hasSourceSelected = sources.length > 0;
        let expBadge = buildBadge(actualN, !!firstData, firstData);
        
        // For sources, add note that it's only for those who rated 3+ on that experience
        if (hasSourceSelected) {
            const sourceKey = sources[0].k;
            const sourceN = getRespondentCount(sourceKey) || (dists[sourceKey] ? calcNFromData(dists[sourceKey]) : actualN);
            expBadge = ` <span class="filter-badge">N=${sourceN}</span><span class="filter-note">NOTE: Experience source only includes respondents who rated 3+ on this experience</span>`;
        }
        
        // If only one item selected
        if (checkedInputs.length === 1) {
            const cb = checkedInputs[0];
            const data = dists[cb.dataset.k];
            const title = cb.nextElementSibling.textContent;
            // For sources (multiselect), use respondent count; for levels, use calcNFromData
            const isSource = cb.dataset.type === 'source';
            const itemN = isSource ?
                (getRespondentCount(cb.dataset.k) || (data ? calcNFromData(data) : 0)) :
                (data ? calcNFromData(data) : 0);
            
            // Build badge for this specific item
            let itemBadge;
            if (cb.dataset.type === 'source') {
                // Experience sources are only for those who rated 3+ on that experience
                itemBadge = ` <span class="filter-badge">N=${itemN}</span><span class="filter-note note-block">${NOTE_EXP_SOURCE}</span>`;
            } else {
                itemBadge = buildBadge(itemN, !!data, data);
            }
            
            // Strip asterisk from title
            const cleanTitle = title.replace(/\s*\*\s*$/, '').trim();
            document.getElementById('dist-title').innerHTML = cleanTitle + itemBadge;
            
            if (!data || Object.keys(data).length === 0) {
                chartArea.innerHTML = '<p class="no-data"><em>Data not available: this sample was not presented with this question</em></p>';
                tableArea.innerHTML = '';
                return;
            }
            
            if (cb.dataset.type === 'source') {
                // Sources: animal_types gets vertical colored bars, others get horizontal bars
                const isAnimalTypes = cb.dataset.k.includes('animal_types');
                // Pass respondent N for percentage calculation
                const respN = getRespondentCount(cb.dataset.k) || itemN;
                // Get exclusive data for stacked bars
                const exclusiveKey = `${cb.dataset.k}_exclusive`;
                const exclusiveData = dists[exclusiveKey] || {};
                if (isAnimalTypes) {
                    showBarChart(data, cleanTitle, 'animal_types', respN, exclusiveData);
                } else {
                    showHorizontalBarChart(data, cleanTitle, respN, exclusiveData);
                }
            } else {
                // Levels: donut chart with experience scale
                showExperienceDonut(data, title, legendArea);
            }
            return;
        }
        
        // Multiple items: show grid
        const allSel = [...levels, ...sources];
        const gridClass = allSel.length <= 2 ? 'cols-2' : (allSel.length <= 3 ? 'cols-3' : 'cols-4');
        showExperienceMixed(allSel, dists, expBadge, gridClass, legendArea, respondentCounts);
        showDistFreeText(filterKey);
        return;
    }
    
    // Moral Features category - radio button options (single selection)
    if (cat === 'moral_features') {
        const vbox = document.getElementById('vbox');
        const selectedInput = vbox ? vbox.querySelector('input:checked') : null;
        
        // Check if free text is selected
        const ftContainer = document.getElementById('free-text-container');
        const hasFreeText = ftContainer && ftContainer.querySelectorAll('input:checked').length > 0;
        
        if (!selectedInput) {
            if (hasFreeText) {
                // No main questions but free text selected - show only free text
                document.getElementById('dist-title').innerHTML = `Important Features for Moral Considerations: Free Text Responses`;
                chartArea.innerHTML = '';
                tableArea.innerHTML = '';
                showDistFreeText(filterKey);
                return;
            }
            document.getElementById('dist-title').textContent = 'Please select a question option';
            chartArea.innerHTML = '';
            tableArea.innerHTML = '';
            return;
        }
        
        const isStacked = selectedInput.dataset.mode === 'stacked';
        const isMostImportant = selectedInput.dataset.k === 'multiselect_moral_considerations_most';
        
        // Check if follow-up only is selected - Most Important doesn't have follow-up data
        if (isFollowUpOnly && isMostImportant) {
            // Show no data for Most Important when only follow-up is selected
            document.getElementById('dist-title').innerHTML = 'Most Important Feature' + ` <span class="filter-badge">N=0</span><span class="filter-note">NOTE: "Most Important" was not asked in the Follow-up sample</span>`;
            chartArea.innerHTML = '';
            tableArea.innerHTML = '';
            legendArea.innerHTML = '';
            return;
        }
        
        // Follow-up only + Combined: show Important data with note about Most Important
        if (isFollowUpOnly && isStacked) {
            const importantData = dists['multiselect_moral_considerations_important'];
            const dataN = getRespondentCount('multiselect_moral_considerations_important') || (importantData ? calcNFromData(importantData) : 0);
            let badge = ` <span class="filter-badge">N=${dataN}</span>`;
            badge += `<span class="filter-note">NOTE: "Most Important" was not asked in Follow-up. Showing only "Important for Moral Considerations".</span>`;
            document.getElementById('dist-title').innerHTML = 'Important Features for Moral Considerations' + badge;
            
            if (!importantData || Object.keys(importantData).length === 0) {
                chartArea.innerHTML = '<p class="no-data"><em>Data not available</em></p>';
                tableArea.innerHTML = '';
                return;
            }
            const respN = getRespondentCount('multiselect_moral_considerations_important') || dataN;
            showBarChart(importantData, 'What do you think is important for moral considerations?', 'moral_features', respN);
            return;
        }
        
        if (isStacked) {
            const importantData = dists['multiselect_moral_considerations_important'];
            const mostData = dists['multiselect_moral_considerations_most'];
            // Use respondent count from filter - this is the actual number of people who answered
            // Do NOT use calcNFromData for multiselect as it sums all selections, not respondents
            const stackedN = getRespondentCount('multiselect_moral_considerations_important') || totalN;
            let stackedBadge = buildBadge(stackedN, !!(importantData || mostData));
            // Only show the "Most Important" note for Combined (no follow-up exclusion note needed)
            stackedBadge += `<span class="filter-note note-block">NOTE: "Most Important" only asked if multiple features were marked as "Important"</span>`;
            document.getElementById('dist-title').innerHTML = 'Important Features for Moral Considerations (Combined)' + stackedBadge;
            
            if ((!importantData || Object.keys(importantData).length === 0) && (!mostData || Object.keys(mostData).length === 0)) {
                chartArea.innerHTML = '<p class="no-data"><em>Data not available: this sample was not presented with these questions</em></p>';
                tableArea.innerHTML = '';
                return;
            }
            showStackedBarChart(importantData, mostData, 'Features', 'moral_features', dists, stackedN);
        } else {
            // Single question selected
            const data = dists[selectedInput.dataset.k];
            // Use respondent count from filter
            const dataN = getRespondentCount(selectedInput.dataset.k) || (data ? calcNFromData(data) : 0);
            let singleBadge = buildBadge(dataN, !!data, data);
            const isMostQ = selectedInput.dataset.k.includes('_most');
            const titleText = isMostQ ? 'Which do you think is the most important for moral considerations?' : 'What do you think is important for moral considerations?';
            // Add notes for Most Important
            if (isMostImportant) {
                // First note: Follow-up exclusion if Follow-up is included
                if (isFollowUpChecked || isAllSelected) {
                    singleBadge += `<span class="filter-note note-block">${NOTE_FOLLOWUP_EXCLUDED}</span>`;
                }
                // Second note: Multiple features requirement (always shown for Most Important)
                singleBadge += `<span class="filter-note note-block">NOTE: Only asked if multiple features were marked as "Important for Moral Considerations"</span>`;
            }
            document.getElementById('dist-title').innerHTML = titleText + singleBadge;
            
            if (!data || Object.keys(data).length === 0) {
                chartArea.innerHTML = '<p class="no-data"><em>Data not available: this sample was not presented with this question</em></p>';
                tableArea.innerHTML = '';
                return;
            }
            showBarChart(data, titleText, 'moral_features', dataN);
        }
        showDistFreeText(filterKey);
        return;
    }
    
    // Zombie Pill - single question auto-display
    if (cat === 'zombie_pill') {
        // Find the Zombie Pill question in survey_questions
        const qGroups = DATA.metadata.question_groups || {};
        const surveyQs = DATA.metadata.survey_questions || {};
        const zombieCols = qGroups['Zombie Pill'] || [];
        let zombieKey = null;
        Object.entries(surveyQs).forEach(([k, cn]) => {
            if (zombieCols.includes(cn)) zombieKey = `survey_${k}`;
        });
        
        if (zombieKey) {
            const data = dists[zombieKey];
            const dataN = data ? calcNFromData(data) : 0;
            const zombieBadge = buildBadge(dataN, !!data, data);
            document.getElementById('dist-title').innerHTML = 'Zombie Pill' + zombieBadge;
            if (!data || Object.keys(data).length === 0) {
                legendArea.innerHTML = '';
                chartArea.innerHTML = '<p class="no-data"><em>Data not available: this sample was not presented with this question</em></p>';
                tableArea.innerHTML = '';
                return;
            }
            // Build legend with question label above (non-bold, matching Moral Considerations style)
            let legendHtml = '<div style="text-align:center;margin-bottom:0.5rem;">';
            legendHtml += '<span style="color:var(--text-secondary);font-size:1.2rem;">Would You Take the Pill?</span>';
            legendHtml += '</div>';
            legendHtml += buildCustomLegend(data, null);  // No title in legend bar
            legendArea.innerHTML = legendHtml;
            showSingleDonut(data, 'Would You Take the Pill?', false, null);  // No side legend, no title
        } else {
            document.getElementById('dist-title').textContent = 'Zombie Pill question not found';
            chartArea.innerHTML = '';
            tableArea.innerHTML = '';
        }
        return;
    }
    
    // Education - two questions (background and field)
    if (cat === 'education') {
        const vbox = document.getElementById('vbox');
        const checkedInputs = vbox ? Array.from(vbox.querySelectorAll('input:checked')) : [];
        
        // Check if free text is selected
        const ftContainer = document.getElementById('free-text-container');
        const hasFreeText = ftContainer && ftContainer.querySelectorAll('input:checked').length > 0;
        
        if (checkedInputs.length === 0) {
            if (hasFreeText) {
                // No main questions but free text selected - show only free text
                document.getElementById('dist-title').innerHTML = `Education: Free Text Responses`;
                chartArea.innerHTML = '';
                tableArea.innerHTML = '';
                showDistFreeText(filterKey);
                return;
            }
            document.getElementById('dist-title').textContent = 'Please select a question option';
            chartArea.innerHTML = '';
            tableArea.innerHTML = '';
            return;
        }
        
        // Handle each selection
        checkedInputs.forEach((cb, idx) => {
            const dataKey = cb.dataset.k;
            const isMultiselect = cb.dataset.mode === 'multiselect';
            const data = dists[dataKey];
            
            // For multiselect, use respondent count from filter (not metadata)
            let dataN;
            if (isMultiselect) {
                dataN = getRespondentCount(dataKey) || (data ? calcNFromData(data) : 0);
            } else {
                dataN = data ? calcNFromData(data) : 0;
            }
            
            const eduBadge = buildBadge(dataN, !!data, data);
            const title = cb.nextElementSibling.textContent;
            
            if (checkedInputs.length === 1) {
                document.getElementById('dist-title').innerHTML = title + eduBadge;
                legendArea.innerHTML = '';
                
                if (!data || Object.keys(data).length === 0) {
                    chartArea.innerHTML = '<p class="no-data"><em>Data not available: this sample was not presented with this question</em></p>';
                    tableArea.innerHTML = '';
                    return;
                }
                
                if (isMultiselect) {
                    showHorizontalBarChart(data, title);
                } else {
                    showSingleDonut(data, title);
                }
            }
        });
        
        // If multiple selected, show stacked vertically (full width each)
        if (checkedInputs.length > 1) {
            const firstCb = checkedInputs[0];
            const firstData = dists[firstCb.dataset.k];
            let firstN;
            if (firstCb.dataset.mode === 'multiselect') {
                firstN = getRespondentCount(firstCb.dataset.k) || (firstData ? calcNFromData(firstData) : 0);
            } else {
                firstN = firstData ? calcNFromData(firstData) : 0;
            }
            const eduBadge = buildBadge(firstN, !!firstData, firstData);
            document.getElementById('dist-title').innerHTML = 'Education' + eduBadge;
            legendArea.innerHTML = '';
            
            // Stack vertically instead of side-by-side
            let htmlContent = '';
            checkedInputs.forEach((cb, i) => {
                const dataKey = cb.dataset.k;
                const isMultiselect = cb.dataset.mode === 'multiselect';
                const data = dists[dataKey];
                const title = cb.nextElementSibling.textContent;
                
                if (!data) return;
                
                if (isMultiselect) {
                    // Calculate height based on number of items
                    const numItems = Object.keys(data).filter(k => typeof data[k] === 'number').length;
                    const chartHeight = Math.max(numItems * 32 + 80, 350);
                    htmlContent += `<div class="edu-section" style="margin-bottom:2rem;">
                        <h4 style="text-align:center;margin-bottom:0.75rem;color:var(--text-secondary);font-size:1.15rem;">${title}</h4>
                        <div class="chart-container" style="height:${chartHeight}px;"><canvas id="c-edu-${i}"></canvas></div>
                    </div>`;
                } else {
                    htmlContent += `<div class="edu-section" style="margin-bottom:2rem;">
                        <h4 style="text-align:center;margin-bottom:0.5rem;color:var(--text-secondary);font-size:1.15rem;">${title}</h4>
                        <div id="leg-edu-${i}" style="text-align:center;margin-bottom:0.5rem;"></div>
                        <div class="chart-container" style="height:350px;max-width:400px;margin:0 auto;"><canvas id="c-edu-${i}"></canvas></div>
                    </div>`;
                }
            });
            chartArea.innerHTML = htmlContent;
            
            // Create charts
            checkedInputs.forEach((cb, i) => {
                const dataKey = cb.dataset.k;
                const isMultiselect = cb.dataset.mode === 'multiselect';
                const data = dists[dataKey];
                
                if (!data) return;
                
                if (isMultiselect) {
                    const sortedEntries = Object.entries(data)
                        .filter(([k, v]) => typeof v === 'number')
                        .sort((a, b) => b[1] - a[1]);
                    const labels = sortedEntries.map(([k]) => k);
                    const values = sortedEntries.map(([, v]) => v);
                    const total = values.reduce((a, b) => a + b, 0);
                    
                    charts[`c-edu-${i}`] = new Chart(document.getElementById(`c-edu-${i}`).getContext('2d'), {
                        type: 'bar',
                        data: {labels, datasets: [{data: values, backgroundColor: '#4a9b9e', borderWidth: 0}]},
                        options: {indexAxis: 'y', responsive: true, maintainAspectRatio: false, plugins: {legend: {display: false}, tooltip: {callbacks: {label: ctx => `${ctx.raw} (${((ctx.raw/total)*100).toFixed(1)}%)`}}}, scales: {x: {beginAtZero: true, grid: {color: '#30363d'}, ticks: {color: '#e6edf3', font: {size: 12}}}, y: {grid: {display: false}, ticks: {color: '#e6edf3', autoSkip: false, font: {size: 12}}}}}
                    });
                } else {
                    // Add legend - larger when both education questions selected
                    const legEl = document.getElementById(`leg-edu-${i}`);
                    if (legEl) {
                        // Use education order for sorting
                        let keys = getCanonicalKeyOrder(Object.keys(data));
                        const colors = getColors(keys);
                        let legHtml = '';
                        keys.forEach((k, idx) => {
                            const cleanLabel = k.replace(/\s*\([^)]*\)/g, '').trim();
                            legHtml += `<span style="display:inline-flex;align-items:center;gap:0.4rem;margin:0.2rem 0.4rem;"><span style="width:16px;height:16px;background:${colors[idx]};border-radius:3px;flex-shrink:0;"></span><span style="font-size:1rem;">${cleanLabel}</span></span>`;
                        });
                        legEl.innerHTML = legHtml;
                    }
                    
                    // Use education order for chart
                    let keys = getCanonicalKeyOrder(Object.keys(data));
                    const values = keys.map(k => typeof data[k] === 'number' ? data[k] : 0);
                    const total = values.reduce((a, b) => a + b, 0);
                    
                    charts[`c-edu-${i}`] = new Chart(document.getElementById(`c-edu-${i}`).getContext('2d'), {
                        type: 'doughnut',
                        data: {labels: keys, datasets: [{data: values, backgroundColor: getColors(keys), borderWidth: 0}]},
                        options: {responsive: true, maintainAspectRatio: false, plugins: {legend: {display: false}, tooltip: {callbacks: {label: ctx => `${stripTooltipParens(ctx.label)}: ${ctx.raw} (${((ctx.raw/total)*100).toFixed(1)}%)`}}}}
                    });
                }
            });
            
            tableArea.innerHTML = '<p class="no-data">Select individual questions for detailed tables</p>';
        }
        showDistFreeText(filterKey);
        return;
    }
    
    // Demographics - checkbox group with special handling for country/employment
    if (cat === 'demo') {
        const vbox = document.getElementById('vbox');
        const checkedInputs = vbox ? Array.from(vbox.querySelectorAll('input:checked:not(#v-all)')) : [];
        
        // Check if free text is selected
        const ftContainer = document.getElementById('free-text-container');
        const hasFreeText = ftContainer && ftContainer.querySelectorAll('input:checked').length > 0;
        
        if (checkedInputs.length === 0) {
            if (hasFreeText) {
                // No main questions but free text selected - show only free text
                document.getElementById('dist-title').innerHTML = `Demographics: Free Text Responses`;
                chartArea.innerHTML = '';
                tableArea.innerHTML = '';
                showDistFreeText(filterKey);
                return;
            }
            document.getElementById('dist-title').textContent = 'Please select at least one demographic';
            chartArea.innerHTML = '';
            tableArea.innerHTML = '';
            return;
        }
        
        // Get first data for N calculation
        const firstKey = checkedInputs[0].dataset.k;
        const firstData = dists[firstKey];
        const actualN = firstData ? calcNFromData(firstData) : 0;
        const demoBadge = buildBadge(actualN, !!firstData, firstData);
        
        // Single selection - show as full chart
        if (checkedInputs.length === 1) {
            const cb = checkedInputs[0];
            const data = dists[cb.dataset.k];
            const title = cb.nextElementSibling.textContent;
            
            // Add note for education topic
            const isEducationTopic = cb.dataset.k === 'multiselect_education_topic';
            let titleNote = isEducationTopic ? '<span class="filter-note note-block">NOTE: Education topic only includes respondents who reported post-secondary/graduate education</span>' : '';
            document.getElementById('dist-title').innerHTML = title + demoBadge + titleNote;
            
            if (!data || Object.keys(data).length === 0) {
                chartArea.innerHTML = '<p class="no-data"><em>Data not available: this sample was not presented with this question</em></p>';
                tableArea.innerHTML = '';
                legendArea.innerHTML = '';
                return;
            }
            
            // Check if this is country/employment/education_topic (many values) - use horizontal bar chart
            const isCountry = cb.dataset.k.includes('country');
            const isEmployment = cb.dataset.k.includes('employment');
            
            if (isCountry || isEmployment || isEducationTopic) {
                legendArea.innerHTML = '';
                showHorizontalBarChart(data, title);
            } else {
                showSingleDonut(data, title);
            }
            showDistFreeText(filterKey);
            return;
        }
        
        // Multiple selections - show in grid
        // Check if education topic is selected - add note to title
        const hasEducationTopic = checkedInputs.some(cb => cb.dataset.k === 'multiselect_education_topic');
        let titleNote = hasEducationTopic ? '<span class="filter-note note-block">NOTE: Education topic only includes respondents who reported post-secondary/graduate education</span>' : '';
        document.getElementById('dist-title').innerHTML = `Demographics: ${checkedInputs.length} Variables${demoBadge}${titleNote}`;
        
        // Separate country/employment/education_topic from others (they need special handling as horizontal bars)
        const specialItems = checkedInputs.filter(cb => 
            cb.dataset.k.includes('country') || cb.dataset.k.includes('employment') || cb.dataset.k === 'multiselect_education_topic');
        const regularItems = checkedInputs.filter(cb => 
            !cb.dataset.k.includes('country') && !cb.dataset.k.includes('employment') && cb.dataset.k !== 'multiselect_education_topic');
        
        let htmlParts = [];
        
        // Regular demographics as grid of donuts (including Education background - just like Gender/Age)
        if (regularItems.length > 0) {
            const hasSpecialItems = specialItems.length > 0;
            // When single donut with Employment/Country below, use cols-1 to center it
            // Max cols-3 for Gender/Age/Education (only 3 possible items)
            let gridClass = regularItems.length === 1 ? 'cols-1' : (regularItems.length <= 2 ? 'cols-2' : 'cols-3');
            
            let gridHtml = `<div class="chart-grid ${gridClass}" id="cgrid-regular">`;
            regularItems.forEach((cb, i) => {
                const title = cb.nextElementSibling.textContent;
                
                if (hasSpecialItems && regularItems.length === 1) {
                    // Single donut (Gender/Age/Education) with Employment/Country/Education Topic below - same size as standalone but with title
                    gridHtml += `<div class="chart-cell"><h4 style="font-size:1.15rem;">${title}</h4><div class="chart-cell-legend" id="leg-r-${i}" style="font-size:1rem;"></div><canvas id="c-r-${i}"></canvas></div>`;
                } else if (hasSpecialItems) {
                    // Multiple donuts (Gender+Age+Education) with special items below - use larger legend boxes
                    gridHtml += `<div class="chart-cell" data-larger-legend="true"><h4 style="font-size:1.15rem;">${title}</h4><div class="chart-cell-legend" id="leg-r-${i}" style="font-size:1rem;"></div><canvas id="c-r-${i}"></canvas></div>`;
                } else {
                    // Regular donut, no special items below - standard styling
                    gridHtml += `<div class="chart-cell"><h4 style="font-size:1.15rem;">${title}</h4><div class="chart-cell-legend" id="leg-r-${i}" style="font-size:1rem;"></div><canvas id="c-r-${i}"></canvas></div>`;
                }
            });
            gridHtml += '</div>';
            htmlParts.push(gridHtml);
        }
        
        // Country, employment, and education topic as separate horizontal bar charts
        // Calculate height based on number of items for proper spacing
        const MAX_SPECIAL_ITEMS = 10;
        specialItems.forEach((cb, i) => {
            const title = cb.nextElementSibling.textContent;
            const data = dists[cb.dataset.k];
            const numItems = data ? Object.keys(data).filter(k => typeof data[k] === 'number').length : 10;
            const displayItems = Math.min(numItems, MAX_SPECIAL_ITEMS);
            const hasMoreItems = numItems > MAX_SPECIAL_ITEMS;
            const itemHeight = 36; // pixels per bar
            const chartHeight = Math.max(displayItems * itemHeight + 80, 300);
            
            let toggleHtml = '';
            if (hasMoreItems) {
                toggleHtml = `<div style="text-align:left;margin-top:-0.25rem;margin-bottom:0.5rem;">
                    <span style="color:var(--text-muted);font-size:0.85rem;">Showing top ${MAX_SPECIAL_ITEMS} of ${numItems}</span>
                    <span style="color:#8b949e;font-size:0.9rem;font-weight:600;cursor:pointer;text-decoration:underline;margin-left:0.75rem;" onclick="toggleSpecialChart(${i}, true)" id="toggle-special-${i}">Show all</span>
                </div>`;
            }
            
            htmlParts.push(`<div class="special-demo-section" id="special-section-${i}" data-key="${cb.dataset.k}" data-title="${title}" data-num-items="${numItems}"><h4 style="text-align:center;margin:1.5rem 0 0.75rem;color:var(--text-secondary);font-size:1.15rem;">${title}</h4><div class="chart-container" id="chart-container-s-${i}" style="height:${chartHeight}px"><canvas id="c-s-${i}"></canvas></div>${toggleHtml}</div>`);
        });
        
        chartArea.innerHTML = htmlParts.join('');
        legendArea.innerHTML = '';
        
        // Create regular donut charts
        regularItems.forEach((cb, i) => {
            const data = dists[cb.dataset.k];
            if (!data) return;
            
            // Sort keys: alphabetically for gender, by first number for age ranges
            // For education, use specific order from EDU_ORDER
            let keys = Object.keys(data);
            const isEduBackground = cb.dataset.k === 'demo_education';
            
            if (isEduBackground) {
                // Use EDU_ORDER constant for education background (from none to graduate)
                keys = EDU_ORDER.filter(k => keys.includes(k)).concat(keys.filter(k => !EDU_ORDER.includes(k)));
            } else if (keys.some(k => k.includes('-'))) {
                // Age ranges - sort by first number
                keys = keys.sort((a, b) => parseInt(a) - parseInt(b));
            } else {
                // Alphabetical (for gender, etc.)
                keys = keys.sort();
            }
            const values = keys.map(k => typeof data[k] === 'number' ? data[k] : 0);
            const total = values.reduce((a, b) => a + b, 0);
            const colors = getColors(keys);
            
            // Add per-cell legend
            const legEl = document.getElementById(`leg-r-${i}`);
            // Check if this cell has larger-legend flag (multiple donuts with Employment/Country below)
            const cellEl = document.getElementById(`leg-r-${i}`)?.parentElement;
            const useLargerLegend = cellEl?.dataset.largerLegend === 'true';
            
            if (legEl) {
                if (useLargerLegend || regularItems.length > 1) {
                    // Multiple demographics items OR with special items below - use larger legend boxes
                    const boxSize = useLargerLegend ? 16 : 14;
                    let legHtml = '';
                    keys.forEach((k, idx) => {
                        const cleanLabel = k.replace(/\s*\([^)]*\)/g, '').trim();
                        legHtml += `<span style="display:flex;align-items:center;gap:0.35rem;"><span style="width:${boxSize}px;height:${boxSize}px;background:${colors[idx]};border-radius:2px;flex-shrink:0;"></span>${cleanLabel}</span>`;
                    });
                    legEl.innerHTML = legHtml;
                } else {
                    // Single donut - standard legend 
                    let legHtml = '';
                    keys.forEach((k, idx) => {
                        const cleanLabel = k.replace(/\s*\([^)]*\)/g, '').trim();
                        legHtml += `<span style="display:flex;align-items:center;gap:0.3rem;"><span style="width:12px;height:12px;background:${colors[idx]};border-radius:2px;flex-shrink:0;"></span>${cleanLabel}</span>`;
                    });
                    legEl.innerHTML = legHtml;
                }
            }
            
            charts[`c-r-${i}`] = new Chart(document.getElementById(`c-r-${i}`).getContext('2d'), {
                type: 'doughnut',
                data: {labels: keys, datasets: [{data: values, backgroundColor: colors, borderWidth: 0}]},
                options: {responsive: true, plugins: {legend: {display: false}, tooltip: {callbacks: {label: ctx => `${stripTooltipParens(ctx.label)}: ${ctx.raw} (${((ctx.raw/total)*100).toFixed(1)}%)`}}}}
            });
        });
        
        // Create horizontal bar charts for country/employment (show limited items initially)
        // MAX_SPECIAL_ITEMS already declared above
        window._specialChartData = {};  // Store data for toggle
        
        specialItems.forEach((cb, i) => {
            const data = dists[cb.dataset.k];
            if (!data) return;
            
            const sortedEntries = Object.entries(data)
                .filter(([k, v]) => typeof v === 'number')
                .sort((a, b) => b[1] - a[1]);
            
            const allLabels = sortedEntries.map(([k]) => k);
            const allValues = sortedEntries.map(([, v]) => v);
            const total = allValues.reduce((a, b) => a + b, 0);
            
            // Store data for toggle
            window._specialChartData[i] = { allLabels, allValues, total, key: cb.dataset.k };
            
            // Show limited items initially
            const displayCount = Math.min(allLabels.length, MAX_SPECIAL_ITEMS);
            const labels = allLabels.slice(0, displayCount);
            const values = allValues.slice(0, displayCount);
            const maxVal = Math.max(...values);
            
            charts[`c-s-${i}`] = new Chart(document.getElementById(`c-s-${i}`).getContext('2d'), {
                type: 'bar',
                data: {labels, datasets: [{data: values, backgroundColor: '#4a9b9e', borderWidth: 0}]},
                options: {
                    indexAxis: 'y',
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {legend: {display: false}, tooltip: {callbacks: {label: ctx => `${ctx.raw} (${((ctx.raw/total)*100).toFixed(1)}%)`}}},
                    scales: {x: {beginAtZero: true, max: Math.ceil(maxVal * 1.1 / 50) * 50, grid: {color: '#30363d'}, ticks: {color: '#e6edf3', font: {size: 15}, stepSize: 50}}, y: {grid: {display: false}, ticks: {color: '#e6edf3', autoSkip: false, font: {size: 15}}}}
                }
            });
        });
        
        tableArea.innerHTML = '<p class="no-data">Select individual demographics for detailed tables</p>';
        showDistFreeText(filterKey);
        return;
    }
    
    // Single select dropdown
    const varSel = document.getElementById('dist-variable');
    const v = varSel?.value;
    if (!v) { document.getElementById('dist-title').textContent = 'Please select a question'; chartArea.innerHTML = ''; tableArea.innerHTML = ''; return; }
    
    const data = dists[v];
    const dataN = data ? calcNFromData(data) : 0;
    const dropdownBadge = buildBadge(dataN, !!data, data);
    const title = varSel.selectedOptions[0]?.dataset?.c ? DN(varSel.selectedOptions[0].dataset.c).f : varSel.selectedOptions[0]?.textContent || v;
    document.getElementById('dist-title').innerHTML = title + dropdownBadge;
    
    if (!data) { chartArea.innerHTML = '<p class="no-data">Data not available (may be restricted for privacy or not pre-computed)</p>'; tableArea.innerHTML = ''; return; }
    
    // Use bar chart for multiselect/experience source categories with many non-numeric options
    const isMultiselect = cat === 'multiselect' || cat === 'expsrc';
    const hasMultipleCategories = Object.keys(data).length > 2;
    const isNonNumeric = !Object.keys(data).every(k => ['1','2','3','4','5'].includes(String(parseInt(parseFloat(k)))));
    
    if (isMultiselect && hasMultipleCategories && isNonNumeric) {
        // Determine colorKey based on variable
        const colorKey = v.includes('animal_types') ? 'animal_types' : null;
        showBarChart(data, varSel.selectedOptions[0]?.textContent || v, colorKey);
    } else {
        showSingleDonut(data, varSel.selectedOptions[0]?.textContent || v);
    }
    
    // Update download button visibility
    setTimeout(updateDownloadButton, 100);
}

// Split view rendering - shows data split by sample phase and/or recruitment
function showDistSplit(cat) {
    const chartArea = document.getElementById('dist-chart-area');
    const tableArea = document.getElementById('dist-table-container');
    const legendArea = document.getElementById('dist-legend-area');
    const ftArea = document.getElementById('dist-freetext-area');
    
    console.log('[showDistSplit] Category:', cat);
    
    if (ftArea) {
        ftArea.style.display = 'none';
        ftArea.innerHTML = '';
    }
    
    legendArea.innerHTML = '';
    
    if (!cat) {
        document.getElementById('dist-title').textContent = 'Please select a topic';
        chartArea.innerHTML = '';
        tableArea.innerHTML = '';
        return;
    }
    
    // Check if follow-up is selected and category not in follow-up
    const box = document.getElementById('sample-filter-box');
    const isAllSelected = document.getElementById('f-none')?.checked;
    const followUpCheckbox = box?.querySelector('input[data-v="follow-up"]');
    const isFollowUpChecked = followUpCheckbox?.checked || false;
    const notInFollowup = DATA.metadata.not_in_followup || [];
    const categoryNotInFollowup = notInFollowup.includes(cat);
    
    // Get split datasets - pass categoryNotInFollowup to exclude Follow-up from calculations
    const splitDatasets = getSplitData(categoryNotInFollowup);
    
    console.log('[showDistSplit] Split datasets:', splitDatasets.length);
    
    // Build title with split info
    let splitLabel = '';
    const { splitBySample, splitBySource, splitByCluster } = getSplitConfig();
    const splitParts = [];
    if (splitBySample) splitParts.push('Sample Phase');
    if (splitBySource) splitParts.push('Recruitment');
    if (splitByCluster) splitParts.push('Cluster');
    if (splitParts.length > 0) splitLabel = ` (Split by ${splitParts.join(' & ')})`;
    
    // Get category display name
    const catSel = document.getElementById('dist-category');
    const catName = getTitleName(catSel?.selectedOptions[0]?.textContent || cat);
    
    // Generate follow-up note if relevant
    let followUpNote = '';
    if (categoryNotInFollowup && (isAllSelected || isFollowUpChecked)) {
        followUpNote = `<span class="filter-note note-block">${NOTE_FOLLOWUP_EXCLUDED}</span>`;
    }
    
    // No need to filter datasets again - getSplitData already excluded Follow-up
    let filteredDatasets = splitDatasets;
    
    // Handle special case: zombie_pill has no question selection
    if (cat === 'zombie_pill') {
        const qGroups = DATA.metadata.question_groups || {};
        const surveyQs = DATA.metadata.survey_questions || {};
        const zombieCols = qGroups['Zombie Pill'] || [];
        let zombieKey = null;
        Object.entries(surveyQs).forEach(([k, cn]) => {
            if (zombieCols.includes(cn)) zombieKey = `survey_${k}`;
        });
        
        if (zombieKey) {
            const totalN = filteredDatasets.reduce((sum, ds) => sum + (ds.data.n || 0), 0);
            document.getElementById('dist-title').innerHTML = `Zombie Pill${splitLabel} <span class="filter-badge">Total N=${totalN}</span>${followUpNote}`;
            showSingleDistSplit(zombieKey, filteredDatasets, catName, '', followUpNote);
            setTimeout(updateDownloadButton, 100);
            return;
        }
    }
    
    // Check what kind of selection UI exists
    const vbox = document.getElementById('vbox');
    const varSel = document.getElementById('dist-variable');
    
    // Special handling for entity attributions (ms_attr, c_attr, combined_attr)
    // These use vbox but with data-entity instead of data-k
    if (cat === 'ms_attr' || cat === 'c_attr' || cat === 'combined_attr') {
        const checkedInputs = vbox ? Array.from(vbox.querySelectorAll('input:checked:not(#v-all)')) : [];
        if (checkedInputs.length === 0) {
            document.getElementById('dist-title').textContent = 'Please select at least one entity';
            chartArea.innerHTML = '';
            tableArea.innerHTML = '';
            return;
        }
        
        // For now, show message that entity attributions split view is coming soon
        const prefix = cat === 'ms_attr' ? 'Moral Status' : cat === 'c_attr' ? 'Consciousness' : 'Combined';
        const totalN = filteredDatasets.reduce((sum, ds) => sum + (ds.data.n || 0), 0);
        document.getElementById('dist-title').innerHTML = `${prefix} Attributions${splitLabel} <span class="filter-badge">Total N=${totalN}</span>${followUpNote}`;
        
        showEntityDistSplit(cat, filteredDatasets, checkedInputs);
        setTimeout(updateDownloadButton, 100);
        return;
    }
    
    // Categories that use vbox checkboxes
    if (vbox) {
        const checkedInputs = Array.from(vbox.querySelectorAll('input:checked:not(#v-all):not(#v-kpt-all)'));
        
        // Check for nokill checkbox (for kill_test)
        let hasNokillSelected = false;
        if (cat === 'kill_test') {
            const nokillCb = document.getElementById('v-nokill');
            hasNokillSelected = nokillCb?.checked || false;
        }
        
        // Check for calculated value checkboxes
        let hasCalculatedSelected = false;
        if (cat === 'ics') {
            const icsGroupCb = document.getElementById('v-calc-ics-group');
            hasCalculatedSelected = icsGroupCb?.checked || false;
        } else if (cat === 'earth_danger') {
            const eidClusterCb = document.getElementById('v-calc-eid-cluster');
            hasCalculatedSelected = eidClusterCb?.checked || false;
        }
        
        // Check for free text checkboxes in free-text-container
        const ftContainer = document.getElementById('free-text-container');
        const ftCheckboxes = ftContainer ? ftContainer.querySelectorAll('input[data-ft-key]:checked') : [];
        const hasFreeTextSelected = ftCheckboxes.length > 0;
        
        console.log('[showDistSplit] vbox category, checked inputs:', checkedInputs.length, 'hasNokillSelected:', hasNokillSelected, 'hasCalculatedSelected:', hasCalculatedSelected, 'hasFreeTextSelected:', hasFreeTextSelected);
        console.log('[showDistSplit] ftContainer exists:', !!ftContainer, 'ftCheckboxes found:', ftCheckboxes.length);
        if (ftContainer) {
            console.log('[showDistSplit] ftContainer children:', ftContainer.querySelectorAll('input').length);
            console.log('[showDistSplit] ftContainer checked inputs:', ftContainer.querySelectorAll('input:checked').length);
        }
        
        if (checkedInputs.length === 0 && !hasNokillSelected && !hasCalculatedSelected && !hasFreeTextSelected) {
            document.getElementById('dist-title').textContent = 'Please select at least one question';
            chartArea.innerHTML = '';
            tableArea.innerHTML = '';
            return;
        }
        
        // If only free text is selected, show split free text view
        if (checkedInputs.length === 0 && !hasNokillSelected && !hasCalculatedSelected && hasFreeTextSelected) {
            document.getElementById('dist-title').innerHTML = `${catName}: Free Text Responses${splitLabel}`;
            chartArea.innerHTML = '';
            tableArea.innerHTML = '';
            showDistFreeText('');  // Split mode handles its own keys
            return;
        }
        
        showMultiDistSplit(cat, filteredDatasets, followUpNote);
        setTimeout(updateDownloadButton, 100);
        return;
    }
    
    // Categories that use select dropdown
    if (varSel) {
        const v = varSel.value;
        
        if (!v) {
            document.getElementById('dist-title').textContent = 'Please select at least one question';
            chartArea.innerHTML = '';
            tableArea.innerHTML = '';
            return;
        }
        
        // Single question split view
        const totalN = filteredDatasets.reduce((sum, ds) => sum + (ds.data.n || 0), 0);
        document.getElementById('dist-title').innerHTML = `${catName}${splitLabel} <span class="filter-badge">Total N=${totalN}</span>${followUpNote}`;
        showSingleDistSplit(v, filteredDatasets, catName, '');
        setTimeout(updateDownloadButton, 100);
        return;
    }
    
    // Fallback
    document.getElementById('dist-title').textContent = 'Please select at least one question';
    chartArea.innerHTML = '';
    tableArea.innerHTML = '';
}

// Show split view for multi-question categories
function showMultiDistSplit(cat, splitDatasets, followUpNote = '') {
    const chartArea = document.getElementById('dist-chart-area');
    const tableArea = document.getElementById('dist-table-container');
    const legendArea = document.getElementById('dist-legend-area');
    
    console.log('[showMultiDistSplit] cat:', cat, 'splitDatasets:', splitDatasets.length, 'followUpNote:', followUpNote);
    console.log('[showMultiDistSplit] Dataset Ns:', splitDatasets.map(ds => ({ label: ds.label, n: ds.data.n })));
    
    // Get selected questions from vbox (checkbox group) - same as non-split mode
    const vbox = document.getElementById('vbox');
    const checkedInputs = vbox ? Array.from(vbox.querySelectorAll('input:checked:not(#v-all):not(#v-kpt-all)')) : [];
    // Filter out any items without a proper data-k (like "Select All" row if somehow checked)
    // Also strip asterisks from labels (asterisks are only for checkbox display, not plot titles)
    let sel = checkedInputs
        .filter(cb => cb.dataset.k)  // Must have data-k attribute
        .map(cb => ({
            k: cb.dataset.k,
            c: cb.dataset.c,
            l: (cb.nextElementSibling?.textContent || cb.dataset.k).replace(/\s*\*\s*$/, '').trim()
        }));
    
    // Special handling for moral_features "Combined" option - treat it as a regular horizontal bar but with stacked data
    if (cat === 'moral_features') {
        const stackedRadio = document.getElementById('v-mf-stacked');
        if (stackedRadio?.checked) {
            // Combined mode - add to sel as a special stacked question
            sel = [{
                k: 'multiselect_moral_considerations_important',
                c: 'multiselect_moral_considerations_important',
                l: 'Combined (Important + Most Important)',
                isStacked: true  // Flag for stacked rendering
            }];
        }
    }
    
    // For kill_test, also include the nokill checkbox if selected
    if (cat === 'kill_test') {
        const nokillCb = document.getElementById('v-nokill');
        if (nokillCb?.checked) {
            sel.push({
                k: 'multiselect_no_kill_reason',
                c: 'multiselect_no_kill_reason',
                l: "You wouldn't eliminate any of the creatures; why?"
            });
        }
    }
    
    // For ics, include the ICS Group calculated value if selected
    if (cat === 'ics') {
        const icsGroupCb = document.getElementById('v-calc-ics-group');
        if (icsGroupCb?.checked) {
            sel.push({
                k: 'survey_group',
                c: 'group',
                l: 'Grouping by conceptions of consciousness'
            });
        }
    }
    
    // For earth_danger, include the EiD Cluster calculated value if selected
    if (cat === 'earth_danger') {
        const eidClusterCb = document.getElementById('v-calc-eid-cluster');
        if (eidClusterCb?.checked) {
            sel.push({
                k: 'survey_Cluster',
                c: 'Cluster',
                l: 'Clustering analysis results'
            });
        }
    }
    
    console.log('[showMultiDistSplit] Selected questions:', sel.length);
    console.log('[showMultiDistSplit] Split datasets:', splitDatasets.map(ds => ({
        label: ds.label,
        n: ds.data.n,
        distKeys: Object.keys(ds.data.d || {}).slice(0, 5)
    })));
    
    if (sel.length === 0) {
        document.getElementById('dist-title').textContent = 'Please select at least one question';
        chartArea.innerHTML = '';
        tableArea.innerHTML = '';
        return;
    }
    
    // Check if any selected questions are not in follow-up (per-question filtering)
    const questionsNotInFollowup = DATA.metadata.questions_not_in_followup || [];
    console.log('[showMultiDistSplit] questionsNotInFollowup:', questionsNotInFollowup);
    console.log('[showMultiDistSplit] Question labels:', sel.map(q => q.l));
    
    const allQuestionsNotInFollowup = sel.every(q => {
        // Check if question label includes any of the not_in_followup strings (case-insensitive)
        const labelLower = q.l?.toLowerCase() || '';
        const colLower = q.c?.toLowerCase() || '';
        const match = questionsNotInFollowup.some(notQ => {
            const notQLower = notQ.toLowerCase();
            return labelLower.includes(notQLower) || colLower.includes(notQLower);
        });
        console.log('[showMultiDistSplit] Question', q.l, 'notInFollowup:', match);
        return match;
    });
    
    console.log('[showMultiDistSplit] allQuestionsNotInFollowup:', allQuestionsNotInFollowup);
    
    // Filter out Follow-up if all selected questions are not in follow-up
    let filteredDatasets = splitDatasets;
    let perQuestionNote = '';
    if (allQuestionsNotInFollowup && sel.length > 0) {
        const hadFollowUp = splitDatasets.some(ds => {
            const isFollowUp = ds.sampleKey?.toLowerCase().includes('follow') || ds.label?.toLowerCase().includes('follow');
            return isFollowUp;
        });
        
        filteredDatasets = splitDatasets.filter(ds => {
            const isFollowUp = ds.sampleKey?.toLowerCase().includes('follow') || ds.label?.toLowerCase().includes('follow');
            return !isFollowUp;
        });
        
        if (hadFollowUp) {
            perQuestionNote = `<span class="filter-note note-block">${NOTE_FOLLOWUP_EXCLUDED}</span>`;
        }
    }
    
    // Use perQuestionNote if set, otherwise use the passed followUpNote
    let finalNote = perQuestionNote || followUpNote;
    
    // Build notes array for proper stacking (follow-up note first, then other notes)
    let notesHtml = '';
    
    // Follow-up exclusion note comes first (using consistent phrasing)
    if (finalNote && finalNote.includes('Follow-up')) {
        notesHtml = finalNote;  // Already properly formatted
        finalNote = '';  // Clear it since we've handled it
    }
    
    // Add note for nokill question (comes after follow-up note)
    const hasNokillSelected = sel.some(q => q.k === 'multiselect_no_kill_reason');
    if (hasNokillSelected) {
        notesHtml += `<span class="filter-note note-block">${NOTE_NOKILL_REASON}</span>`;
    }
    
    // Add note for moral features Most Important question (need both follow-up and multiple features notes)
    const hasMostImportantSelected = sel.some(q => q.k === 'multiselect_moral_considerations_most');
    if (hasMostImportantSelected) {
        // Add follow-up exclusion note first if not already added
        if (!notesHtml.includes('Follow-up')) {
            notesHtml += `<span class="filter-note note-block">${NOTE_FOLLOWUP_EXCLUDED}</span>`;
        }
        notesHtml += `<span class="filter-note note-block">NOTE: Only asked if multiple features were marked as "Important for Moral Considerations"</span>`;
    }
    
    // Add note for moral features Combined (Most Important only asked if multiple features marked as Important)
    const hasMoralFeaturesStackedNote = sel.some(q => q.isStacked);
    if (hasMoralFeaturesStackedNote) {
        notesHtml += `<span class="filter-note note-block">NOTE: "Most Important" only asked if multiple features were marked as "Important"</span>`;
    }
    
    // Add note for experience source questions (they are only shown for those who rated 3+ on that experience)
    const hasExpSourceSelected = sel.some(q => q.k.includes('expsrc_'));
    if (hasExpSourceSelected) {
        notesHtml += `<span class="filter-note note-block">${NOTE_EXP_SOURCE}</span>`;
    }
    
    // Add note for education topic (only shown to those with post-secondary/graduate education)
    const hasEducationTopicSelected = sel.some(q => q.k === 'multiselect_education_topic');
    if (hasEducationTopicSelected) {
        notesHtml += `<span class="filter-note note-block">NOTE: Education topic only includes respondents who reported post-secondary/graduate education</span>`;
    }
    
    // Helper to check if a question is multi-select (where distribution sums to more than N)
    const isMultiSelectQuestion = (questionKey, catName) => {
        // Multi-select categories/questions where each respondent can select multiple options
        const multiSelectCategories = ['moral_features'];
        const multiSelectKeys = [
            'multiselect_no_kill_reason',  // KPT "why wouldn't you eliminate"
            'topic'  // Education topic
        ];
        
        if (multiSelectCategories.includes(catName)) return true;
        if (multiSelectKeys.some(k => questionKey.includes(k))) return true;
        if (catName === 'g_Education' && questionKey.includes('topic')) return true;
        if (questionKey.includes('multiselect_')) return true;
        if (questionKey.includes('expsrc_')) return true;
        
        return false;
    };
    
    // Helper to get respondent count key for a distribution key
    const getRespondentCountKey = (questionKey) => {
        // The respondent count keys match the distribution keys for multi-select
        // e.g., 'multiselect_moral_considerations_important' -> 'multiselect_moral_considerations_important'
        return questionKey;
    };
    
    // Helper to calculate N from distribution data (only for single-select questions)
    const calcNFromDist = (data) => {
        if (!data) return 0;
        return Object.values(data).reduce((sum, v) => sum + (typeof v === 'number' ? v : 0), 0);
    };
    
    // Calculate N for each split based on the first selected question's actual data
    // For multi-select questions, use respondent counts if available; otherwise sample N
    // For single-select questions, sum the distribution
    const splitNs = filteredDatasets.map(ds => {
        const firstQ = sel[0];
        if (!firstQ) return ds.data.n;
        
        const firstQData = ds.data.d?.[firstQ.k];
        const hasData = firstQData && Object.keys(firstQData).filter(k => typeof firstQData[k] === 'number').length > 0;
        
        // If no data exists for this question in this split, return 0
        if (!hasData) return 0;
        
        // For multi-select questions, use respondent counts if available
        if (isMultiSelectQuestion(firstQ.k, cat)) {
            const rcKey = getRespondentCountKey(firstQ.k);
            const rc = ds.data.rc?.[rcKey];
            console.log('[splitNs] Multi-select question:', firstQ.k, 'rcKey:', rcKey, 'rc:', rc, 'sample n:', ds.data.n, 'ds.data.rc keys:', Object.keys(ds.data.rc || {}));
            if (rc && typeof rc === 'number') {
                return rc;
            }
            // Fallback to sample N if no respondent count available
            return ds.data.n;
        }
        
        // For single-select questions, calculate from distribution
        return calcNFromDist(firstQData);
    });
    
    console.log('[showMultiDistSplit] splitNs:', splitNs);
    
    // Build title
    const { splitBySample: titleSplitSample, splitBySource: titleSplitSource, splitByCluster: titleSplitCluster } = getSplitConfig();
    let splitLabel = '';
    const titleSplitParts = [];
    if (titleSplitSample) titleSplitParts.push('Sample');
    if (titleSplitSource) titleSplitParts.push('Recruitment');
    if (titleSplitCluster) titleSplitParts.push('Cluster');
    if (titleSplitParts.length > 0) splitLabel = ` (Split by ${titleSplitParts.join(' & ')})`;
    
    // Calculate total N from actual question data, not sample totals
    const totalN = splitNs.reduce((sum, n) => sum + n, 0);
    const catSel = document.getElementById('dist-category');
    const catName = getTitleName(catSel?.selectedOptions[0]?.textContent || cat);
    
    document.getElementById('dist-title').innerHTML = `${catName}: ${sel.length} Question${sel.length > 1 ? 's' : ''} Selected${splitLabel} <span class="filter-badge">Total N=${totalN}</span>${notesHtml}`;
    
    // Determine chart type based on category and question
    // Horizontal bars with shared Y-axis: Demographics (Employment, Country, Gender), Education topic, C&I "How?", Moral Features, Experience sources, KPT no-kill reasons
    const sharedAxisCategories = ['moral_features'];
    const horizontalBarQuestions = ['employment', 'country', 'gender', 'topic', 'how'];
    
    const getChartType = (cat, questionLabel, questionKey = '') => {
        const labelLower = questionLabel.toLowerCase();
        const keyLower = questionKey.toLowerCase();
        // Moral features uses horizontal bars (not vertical)
        if (cat === 'moral_features' || sharedAxisCategories.includes(cat)) return 'horizontal-bar-shared';
        if (horizontalBarQuestions.some(q => labelLower.includes(q))) return 'horizontal-bar-shared';
        if (cat === 'demog' && (labelLower.includes('employment') || labelLower.includes('country') || labelLower.includes('gender'))) return 'horizontal-bar-shared';
        if (cat === 'c_intel' && labelLower.includes('how')) return 'horizontal-bar-shared';
        if ((cat === 'g_Education' || cat === 'education') && labelLower.includes('topic')) return 'horizontal-bar-shared';
        // Education background should also be horizontal
        if ((cat === 'g_Education' || cat === 'education') && (labelLower.includes('background') || keyLower.includes('education'))) return 'horizontal-bar-shared';
        // Experience source questions (animal types, etc)
        if (keyLower.includes('expsrc_')) return 'horizontal-bar-shared';
        // KPT no-kill reasons
        if (keyLower.includes('multiselect_no_kill_reason')) return 'horizontal-bar-shared';
        return 'doughnut';
    };
    
    // Create grid: one row per question, one column per split
    const numSplits = filteredDatasets.length;
    
    let html = '<div class="split-container">';
    
    // Check if any question uses horizontal-bar-shared to determine grid structure
    const hasHorizontalBars = sel.some(q => getChartType(cat, q.l, q.k) === 'horizontal-bar-shared');
    
    // Check if KPT "why" question is selected (needs stacked bar legend)
    const hasKptWhy = sel.some(q => q.k.includes('no_kill_reason'));
    // Check if moral features Combined (stacked) is selected
    const hasMoralFeaturesStacked = sel.some(q => q.isStacked);
    
    // Add stacked bar legend for KPT "why" question
    if (hasKptWhy) {
        legendArea.innerHTML = `
            <div style="display:flex;gap:1.5rem;justify-content:center;align-items:center;padding:0.5rem 1rem;background:var(--bg-tertiary);border-radius:6px;margin-bottom:0.5rem;">
                <span style="font-size:0.85rem;color:var(--text-muted);font-weight:500;">Stacking:</span>
                <div style="display:flex;align-items:center;gap:0.4rem;">
                    <div style="width:16px;height:16px;background:#6e7681;border-radius:2px;"></div>
                    <span style="font-size:0.85rem;color:#c9d1d9;">Selected this option only</span>
                </div>
                <div style="display:flex;align-items:center;gap:0.4rem;">
                    <div style="width:16px;height:16px;background:rgba(110,118,129,0.4);border-radius:2px;"></div>
                    <span style="font-size:0.85rem;color:#c9d1d9;">Selected with other options</span>
                </div>
            </div>`;
    } else if (hasMoralFeaturesStacked) {
        legendArea.innerHTML = `
            <div style="display:flex;gap:1.5rem;justify-content:center;align-items:center;padding:0.5rem 1rem;background:var(--bg-tertiary);border-radius:6px;margin-bottom:0.5rem;">
                <span style="font-size:0.85rem;color:var(--text-muted);font-weight:500;">Stacking:</span>
                <div style="display:flex;align-items:center;gap:0.4rem;">
                    <div style="width:16px;height:16px;background:#6e7681;border-radius:2px;"></div>
                    <span style="font-size:0.85rem;color:#c9d1d9;">Most Important</span>
                </div>
                <div style="display:flex;align-items:center;gap:0.4rem;">
                    <div style="width:16px;height:16px;background:rgba(110,118,129,0.4);border-radius:2px;"></div>
                    <span style="font-size:0.85rem;color:#c9d1d9;">Important (not most)</span>
                </div>
            </div>`;
    }
    
    // Pre-calculate max tick column width needed
    let maxTickColWidth = '200px';
    if (hasHorizontalBars) {
        const hasKptWhy = sel.some(q => q.k.includes('no_kill_reason'));
        const hasCIHow = sel.some(q => cat === 'c_intel' && q.l.toLowerCase().includes('how'));
        const hasMoralFeatures = sel.some(q => q.k.includes('moral_considerations_important') || q.k.includes('moral_considerations_most'));
        const hasEmployment = sel.some(q => q.k.includes('employment'));
        const hasExpSource = sel.some(q => q.k.includes('expsrc_') || q.k.includes('_source'));
        const hasCountry = sel.some(q => q.k.includes('country'));
        if (hasKptWhy) {
            maxTickColWidth = '260px';
        } else if (hasMoralFeatures) {
            maxTickColWidth = '240px';
        } else if (hasCIHow || hasEmployment || hasExpSource || hasCountry) {
            maxTickColWidth = '220px';
        }
    }
    
    // For many columns (6+), reduce donut size; for 4+, also reduce slightly
    const baseDonutSize = numSplits >= 6 ? 130 : (numSplits >= 4 ? 155 : 170);
    const baseLegendHeight = numSplits >= 6 ? 36 : 42;
    const baseCellHeight = numSplits >= 6 ? 200 : (numSplits >= 4 ? 225 : 245);
    const tickColWidth = maxTickColWidth;
    
    // Header row with split labels - include tick column for horizontal bars
    if (hasHorizontalBars) {
        html += `<div class="split-header-row" style="display:grid; grid-template-columns: 130px ${tickColWidth} repeat(${numSplits}, 1fr); gap:0.25rem; margin-bottom:1rem;">`;
        html += '<div></div>';  // Question label column
        html += '<div></div>';  // Tick labels column (empty in header)
    } else {
        html += `<div class="split-header-row" style="display:grid; grid-template-columns: 180px repeat(${numSplits}, 1fr); gap:0.25rem; margin-bottom:1rem;">`;
        html += '<div></div>';  // Question label column
    }
    filteredDatasets.forEach((ds, idx) => {
        html += `<div class="split-column-header" style="background:${ds.baseColor}; color:white; font-size:${numSplits >= 6 ? '0.75rem' : '0.85rem'};">${ds.label}<br><small>N=${splitNs[idx]}</small></div>`;
    });
    html += '</div>';
    
    // For horizontal-bar-shared charts, pre-compute sorted labels from largest sample
    const getSharedLabelsForQuestion = (qKey) => {
        // Find the dataset with the most data points for this question
        let maxCount = 0;
        let bestData = null;
        filteredDatasets.forEach(ds => {
            const data = ds.data.d?.[qKey];
            if (data) {
                const count = Object.values(data).filter(v => typeof v === 'number').reduce((a, b) => a + b, 0);
                if (count > maxCount) {
                    maxCount = count;
                    bestData = data;
                }
            }
        });
        if (!bestData) return [];
        // Sort by count descending
        return Object.entries(bestData)
            .filter(([k, v]) => typeof v === 'number')
            .sort((a, b) => b[1] - a[1])
            .map(([k]) => k);
    };
    
    // Question rows
    sel.forEach((q, qIdx) => {
        const chartType = getChartType(cat, q.l, q.k);
        const isSharedAxis = chartType === 'horizontal-bar-shared';
        const sharedLabels = isSharedAxis ? getSharedLabelsForQuestion(q.k) : [];
        
        // Determine if this question needs wider tick column and/or 2-line labels
        const isKptWhy = q.k.includes('no_kill_reason');
        const isCIHow = cat === 'c_intel' && q.l.toLowerCase().includes('how');
        const isMoralFeatures = q.k.includes('moral_considerations_important') || q.k.includes('moral_considerations_most');
        const isEmployment = q.k.includes('employment');
        
        // Get display label (with ICS prefix if needed)
        let displayLabel = q.l;
        if (cat === 'ics' && !q.l.toLowerCase().includes('grouping')) {
            displayLabel = 'Do you think a creature/system can ' + q.l;
        }
        // Add prefix for KPT entity descriptions (but not for the "why" question)
        if (cat === 'kill_test' && !q.k.includes('no_kill_reason')) {
            displayLabel = 'A creature/system that ' + displayLabel;
        }
        
        // Calculate bar height based on number of labels
        // Questions with long labels need more height per label for 2-line text
        const perLabelHeight = (isKptWhy || isMoralFeatures) ? 55 : (isCIHow || isEmployment ? 50 : 45);
        const barHeight = isSharedAxis ? Math.max(260, sharedLabels.length * perLabelHeight) : 240;
        
        // For many columns (6+), reduce donut size; for 4+, also reduce slightly
        const donutSize = numSplits >= 6 ? 130 : (numSplits >= 4 ? 155 : 170);
        const legendHeight = numSplits >= 6 ? 36 : 42;
        const cellHeight = numSplits >= 6 ? 195 : (numSplits >= 4 ? 220 : 240);
        // Larger legend font and box sizes when fewer splits
        const legendFontSize = numSplits >= 6 ? '0.7rem' : (numSplits >= 4 ? '0.75rem' : '0.85rem');
        const legendBoxSize = numSplits >= 6 ? 10 : (numSplits >= 4 ? 12 : 14);
        
        if (isSharedAxis) {
            // Horizontal bar row - use consistent tickColWidth for all rows
            html += `<div class="split-question-row" style="display:grid; grid-template-columns: 130px ${tickColWidth} repeat(${numSplits}, 1fr); gap:0.25rem; margin-bottom:1rem; align-items:stretch;">`;
            
            // Question label - larger font, can span multiple rows
            html += `<div class="split-question-label" style="font-size:0.95rem; padding:0.5rem; color:var(--text-secondary); display:flex; align-items:center; line-height:1.3;">${displayLabel}</div>`;
            
            // External Y-tick labels column - calculate layout to match Chart.js horizontal bar
            // Chart.js horizontal bar uses: top padding + (bar area) + bottom axis
            // Bar area is divided equally among categories with bars centered in each slot
            const xAxisHeight = 28;  // Height of x-axis labels at bottom
            const chartTopPad = 10;   // Chart.js top padding
            const chartBottomPad = 2; // Small bottom padding before axis
            const plotAreaHeight = barHeight - xAxisHeight - chartTopPad - chartBottomPad;
            const categoryHeight = plotAreaHeight / sharedLabels.length;
            // Bar is 85% of category height, centered - so offset by half the remaining space
            const barOffsetInCategory = (categoryHeight * 0.15) / 2;
            
            // Helper to strip parenthetical content for cleaner labels
            const shouldStripParens = q.k.includes('education') || q.k.includes('expsrc_') || q.k.includes('Source');
            const stripParens = (txt) => shouldStripParens ? txt.replace(/\s*\([^)]*\)/g, '').trim() : txt;
            
            // Determine if we should allow 2-line labels (for long text questions or country names)
            const isExpSource = q.k.includes('expsrc_') || q.k.includes('_source');
            const isCountry = q.k.includes('country');
            const allow2Lines = isKptWhy || isCIHow || isMoralFeatures || isEmployment || isExpSource || isCountry;
            
            // Each label div's height equals one category slot height
            html += `<div class="split-tick-labels" style="display:flex; flex-direction:column; justify-content:flex-start; padding-top:${chartTopPad + barOffsetInCategory}px; height:${barHeight}px; box-sizing:border-box; padding-left:4px;">`;
            sharedLabels.forEach(label => {
                const cleanLabel = stripParens(label);
                // Capitalize first letter if needed
                const displayLabel = cleanLabel.charAt(0).toUpperCase() + cleanLabel.slice(1);
                if (allow2Lines) {
                    // Allow 2-line labels with word wrap, vertically centered - larger font for readability
                    html += `<div style="font-size:0.85rem; color:#c9d1d9; text-align:right; height:${categoryHeight}px; display:flex; align-items:center; justify-content:flex-end; overflow:hidden; padding-right:6px; line-height:1.3; white-space:normal; word-wrap:break-word; text-overflow:clip;" title="${label.replace(/"/g, '&quot;')}">${displayLabel}</div>`;
                } else {
                    // Single line, truncate if needed
                    const maxLen = 55;
                    const truncatedLabel = displayLabel.length > maxLen ? displayLabel.substring(0, maxLen - 2) + '...' : displayLabel;
                    html += `<div style="font-size:0.88rem; color:#c9d1d9; text-align:right; height:${categoryHeight}px; display:flex; align-items:center; justify-content:flex-end; overflow:hidden; padding-right:6px; line-height:1.2; white-space:nowrap; text-overflow:clip;" title="${label.replace(/"/g, '&quot;')}">${truncatedLabel}</div>`;
                }
            });
            html += '</div>';
            
            // Charts for each split (no Y labels shown)
            filteredDatasets.forEach((ds, sIdx) => {
                const data = ds.data.d?.[q.k];
                const hasData = data && Object.keys(data).filter(k => typeof data[k] === 'number').length > 0;
                const cellId = `split-${qIdx}-${sIdx}`;
                const splitN = ds.data.n || 0;  // Get the split's respondent count
                
                // Encode sharedLabels safely for HTML attribute
                const encodedLabels = btoa(JSON.stringify(sharedLabels));
                const isStackedAttr = q.isStacked ? ' data-is-stacked="true"' : '';
                html += `<div class="chart-cell" style="width:100%;height:${barHeight}px;" data-chart-type="${chartType}" data-has-data="${hasData}" data-shared-labels-b64="${encodedLabels}" data-bar-height="${barHeight}" data-split-n="${splitN}" data-question-key="${q.k}"${isStackedAttr}>`;
                if (!hasData) {
                    html += `<div class="no-data-message" style="display:flex;align-items:center;justify-content:center;height:${barHeight}px;color:var(--text-muted);font-size:0.85rem;text-align:center;padding:1rem;">Data not available:<br>this sample was not presented with this question</div>`;
                } else {
                    html += `<div class="hbar-canvas-wrapper" style="width:100%;height:${barHeight}px;position:relative;"><canvas id="${cellId}" style="position:absolute;top:0;left:0;width:100%;height:100%;"></canvas></div>`;
                }
                html += `</div>`;
            });
        } else if (hasHorizontalBars) {
            // Donut in a grid that has horizontal bars - include empty tick column for alignment
            html += `<div class="split-question-row" style="display:grid; grid-template-columns: 130px ${tickColWidth} repeat(${numSplits}, 1fr); gap:0.25rem; margin-bottom:1rem; align-items:stretch;">`;
            
            // Question label - vertically centered, uniform font size
            html += `<div class="split-question-label" style="font-size:0.95rem; padding:0.5rem; color:var(--text-secondary); display:flex; align-items:center; line-height:1.3;">${displayLabel}</div>`;
            
            // Empty tick column for alignment
            html += '<div></div>';
            
            // Charts for each split
            filteredDatasets.forEach((ds, sIdx) => {
                const data = ds.data.d?.[q.k];
                const hasData = data && Object.keys(data).filter(k => typeof data[k] === 'number').length > 0;
                const cellId = `split-${qIdx}-${sIdx}`;
                
                html += `<div class="chart-cell" style="display:flex;flex-direction:column;align-items:center;padding:0.5rem;height:${cellHeight}px;" data-chart-type="${chartType}" data-has-data="${hasData}" data-legend-box-size="${legendBoxSize}">`;
                if (!hasData) {
                    html += `<div class="no-data-message" style="display:flex;align-items:center;justify-content:center;flex:1;width:100%;color:var(--text-muted);font-size:0.85rem;text-align:center;padding:1rem;">Data not available:<br>this sample was not presented with this question</div>`;
                } else {
                    html += `<div class="split-chart-legend" id="legend-${cellId}" style="font-size:${legendFontSize}; height:${legendHeight}px; min-height:${legendHeight}px; max-height:${legendHeight}px; overflow:hidden; display:flex; flex-wrap:wrap; gap:0.3rem; justify-content:center; align-items:flex-start;"></div>`;
                    html += `<div style="width:${donutSize}px;height:${donutSize}px;flex-shrink:0;margin-top:6px;"><canvas id="${cellId}"></canvas></div>`;
                }
                html += `</div>`;
            });
        } else {
            // Pure donut grid (no horizontal bars in selection)
            html += `<div class="split-question-row" style="display:grid; grid-template-columns: 180px repeat(${numSplits}, 1fr); gap:0.25rem; margin-bottom:1rem; align-items:stretch;">`;
            
            // Question label - vertically centered, uniform font size
            html += `<div class="split-question-label" style="font-size:0.95rem; padding:0.5rem; color:var(--text-secondary); display:flex; align-items:center; line-height:1.3;">${displayLabel}</div>`;
            
            // Charts for each split
            filteredDatasets.forEach((ds, sIdx) => {
                const data = ds.data.d?.[q.k];
                const hasData = data && Object.keys(data).filter(k => typeof data[k] === 'number').length > 0;
                const cellId = `split-${qIdx}-${sIdx}`;
                
                // Doughnut - centered with fixed size, all cells same height
                html += `<div class="chart-cell" style="display:flex;flex-direction:column;align-items:center;padding:0.5rem;height:${cellHeight}px;" data-chart-type="${chartType}" data-has-data="${hasData}" data-legend-box-size="${legendBoxSize}">`;
                if (!hasData) {
                    html += `<div class="no-data-message" style="display:flex;align-items:center;justify-content:center;flex:1;width:100%;color:var(--text-muted);font-size:0.85rem;text-align:center;padding:1rem;">Data not available:<br>this sample was not presented with this question</div>`;
                } else {
                    html += `<div class="split-chart-legend" id="legend-${cellId}" style="font-size:${legendFontSize}; height:${legendHeight}px; min-height:${legendHeight}px; max-height:${legendHeight}px; overflow:hidden; display:flex; flex-wrap:wrap; gap:0.3rem; justify-content:center; align-items:flex-start;"></div>`;
                    html += `<div style="width:${donutSize}px;height:${donutSize}px;flex-shrink:0;margin-top:6px;"><canvas id="${cellId}"></canvas></div>`;
                }
                html += `</div>`;
            });
        }
        
        html += '</div>';
    });
    
    html += '</div>';
    chartArea.innerHTML = html;
    
    // Render charts
    sel.forEach((q, qIdx) => {
        const chartType = getChartType(cat, q.l, q.k);
        
        filteredDatasets.forEach((ds, sIdx) => {
            const data = ds.data.d?.[q.k];
            const cellId = `split-${qIdx}-${sIdx}`;
            const canvas = document.getElementById(cellId);
            if (!canvas || !data) return;
            
            // Filter out suppressed values
            const filteredData = {};
            for (const [k, v] of Object.entries(data)) {
                if (typeof v === 'number') filteredData[k] = v;
            }
            
            // Get shared labels from data attribute if horizontal-bar-shared
            const cell = canvas.closest('.chart-cell');
            let sortedKeys, displayLabels, values;
            
            if (chartType === 'horizontal-bar-shared') {
                // Use shared labels (sorted by largest sample) - decode from base64
                let sharedLabels = [];
                try {
                    const b64 = cell?.dataset.sharedLabelsB64;
                    if (b64) {
                        sharedLabels = JSON.parse(atob(b64));
                    }
                } catch (e) {
                    console.warn('Failed to decode shared labels:', e);
                }
                sortedKeys = sharedLabels.length > 0 ? sharedLabels : Object.keys(filteredData);
                displayLabels = sortedKeys.map(k => {
                    // First strip any parenthetical content
                    let label = k.replace(/\s*\([^)]*\)/g, '').trim();
                    // Preserve age ranges (18-25, 76+, etc.)
                    if (/^\d+-\d+$/.test(label) || /^\d+\+$/.test(label)) return label;
                    const numVal = parseFloat(label);
                    if (!isNaN(numVal) && numVal === Math.floor(numVal) && label === String(numVal)) {
                        return Math.floor(numVal).toString();
                    }
                    return label;
                });
                values = sortedKeys.map(k => filteredData[k] || 0);
                
                // Get split N and question key for correct percentage calculation
                const splitN = parseInt(cell?.dataset.splitN) || 0;
                const questionKey = cell?.dataset.questionKey || '';
                
                // Detect multi-select questions that should use N as denominator
                const isMultiSelect = questionKey.includes('multiselect_') || 
                                     questionKey.includes('expsrc_') || 
                                     questionKey.includes('animal') ||
                                     questionKey.includes('Source');
                
                // Check for exclusive data (no_kill_reason and experience sources stacked bars)
                const isNoKillReason = questionKey === 'multiselect_no_kill_reason';
                const isExperienceSource = questionKey.startsWith('expsrc_');
                const isMoralFeaturesStacked = cell?.dataset.isStacked === 'true';
                let exclusiveData = {};
                if (isNoKillReason) {
                    exclusiveData = ds.data.d?.['multiselect_no_kill_reason_exclusive'] || {};
                } else if (isExperienceSource) {
                    exclusiveData = ds.data.d?.[`${questionKey}_exclusive`] || {};
                }
                const hasExclusiveData = (isNoKillReason || isExperienceSource) && 
                    Object.keys(exclusiveData).length > 0 && 
                    Object.values(exclusiveData).some(v => typeof v === 'number' && v > 0);
                
                console.log('[Split Chart] cellId:', cellId, 'splitN:', splitN, 'questionKey:', questionKey, 'isMultiSelect:', isMultiSelect, 'hasExclusiveData:', hasExclusiveData, 'isMoralFeaturesStacked:', isMoralFeaturesStacked);
                
                if (isMoralFeaturesStacked) {
                    // Moral features Combined - stacked bar with Most Important + Important Only
                    const mostData = ds.data.d?.['multiselect_moral_considerations_combined_most'] || 
                                    ds.data.d?.['multiselect_moral_considerations_most'] || {};
                    const mostValues = sortedKeys.map(k => mostData[k] || 0);
                    const importantOnlyValues = values.map((v, i) => Math.max(0, v - mostValues[i]));
                    const respondentN = ds.data.rc?.['multiselect_moral_considerations_important'] || splitN;
                    
                    charts[cellId] = new Chart(canvas.getContext('2d'), {
                        type: 'bar',
                        data: {
                            labels: displayLabels,
                            datasets: [
                                {
                                    label: 'Most Important',
                                    data: mostValues,
                                    backgroundColor: ds.baseColor,
                                    borderWidth: 0,
                                    barPercentage: 0.85,
                                    categoryPercentage: 1.0
                                },
                                {
                                    label: 'Important (not most)',
                                    data: importantOnlyValues,
                                    backgroundColor: ds.baseColor + '55',  // Lighter
                                    borderWidth: 0,
                                    barPercentage: 0.85,
                                    categoryPercentage: 1.0
                                }
                            ]
                        },
                        options: {
                            indexAxis: 'y',
                            responsive: true,
                            maintainAspectRatio: false,
                            layout: {
                                padding: { top: 10, bottom: 2, left: 0, right: 10 }
                            },
                            plugins: {
                                legend: { display: false },
                                tooltip: {
                                    callbacks: {
                                        title: ctx => stripTooltipParens(sortedKeys[ctx[0].dataIndex]),
                                        label: ctx => {
                                            const pct = respondentN > 0 ? ((ctx.raw / respondentN) * 100).toFixed(1) : '0.0';
                                            // Multi-line format for narrow columns: label on first line, count on second
                                            return [ctx.dataset.label + ':', ctx.raw + ' (' + pct + '%)'];
                                        }
                                    }
                                }
                            },
                            scales: {
                                x: { 
                                    stacked: true,
                                    grid: { color: 'rgba(255,255,255,0.1)' }, 
                                    ticks: { color: '#b8c4d0', font: { size: 12, weight: '500' } },
                                    beginAtZero: true
                                },
                                y: { 
                                    stacked: true,
                                    grid: { display: false }, 
                                    ticks: { display: false }
                                }
                            }
                        }
                    });
                } else if (hasExclusiveData) {
                    // Create stacked bar chart for no_kill_reason
                    const exclusiveValues = sortedKeys.map(k => exclusiveData[k] || 0);
                    const nonExclusiveValues = values.map((v, i) => Math.max(0, v - exclusiveValues[i]));
                    
                    charts[cellId] = new Chart(canvas.getContext('2d'), {
                        type: 'bar',
                        data: {
                            labels: displayLabels,
                            datasets: [
                                {
                                    label: 'Only this',
                                    data: exclusiveValues,
                                    backgroundColor: ds.baseColor,
                                    borderWidth: 0,
                                    barPercentage: 0.85,
                                    categoryPercentage: 1.0
                                },
                                {
                                    label: 'With others',
                                    data: nonExclusiveValues,
                                    backgroundColor: ds.baseColor + '55',  // Lighter
                                    borderWidth: 0,
                                    barPercentage: 0.85,
                                    categoryPercentage: 1.0
                                }
                            ]
                        },
                        options: {
                            indexAxis: 'y',
                            responsive: true,
                            maintainAspectRatio: false,
                            layout: {
                                padding: { top: 10, bottom: 2, left: 0, right: 10 }
                            },
                            plugins: {
                                legend: { display: false },
                                tooltip: {
                                    callbacks: {
                                        title: ctx => stripTooltipParens(sortedKeys[ctx[0].dataIndex]),
                                        label: ctx => {
                                            const total = values[ctx.dataIndex];
                                            const exclusive = exclusiveValues[ctx.dataIndex];
                                            const pct = splitN > 0 ? ((ctx.raw / splitN) * 100).toFixed(1) : '0.0';
                                            if (ctx.datasetIndex === 0) {
                                                return `Only this: ${exclusive} (${pct}%)`;
                                            } else {
                                                return `With others: ${total - exclusive} (${pct}%)`;
                                            }
                                        },
                                        afterBody: ctx => {
                                            const total = values[ctx[0].dataIndex];
                                            const pct = splitN > 0 ? ((total / splitN) * 100).toFixed(1) : '0.0';
                                            return `Total: ${total} (${pct}%)`;
                                        }
                                    }
                                }
                            },
                            scales: {
                                x: { 
                                    stacked: true,
                                    grid: { color: 'rgba(255,255,255,0.1)' }, 
                                    ticks: { color: '#b8c4d0', font: { size: 12, weight: '500' } },
                                    beginAtZero: true
                                },
                                y: { 
                                    stacked: true,
                                    grid: { display: false }, 
                                    ticks: { display: false }
                                }
                            }
                        }
                    });
                } else {
                    // Standard non-stacked horizontal bar
                    charts[cellId] = new Chart(canvas.getContext('2d'), {
                        type: 'bar',
                        data: {
                            labels: displayLabels,
                            datasets: [{ 
                                data: values, 
                                backgroundColor: ds.baseColor, 
                                borderWidth: 0,
                                barPercentage: 0.85,
                                categoryPercentage: 1.0
                            }]
                        },
                        options: {
                            indexAxis: 'y',
                            responsive: true,
                            maintainAspectRatio: false,
                            layout: {
                                padding: { top: 10, bottom: 2, left: 0, right: 10 }
                            },
                            plugins: {
                                legend: { display: false },
                                tooltip: {
                                    callbacks: {
                                        label: ctx => {
                                            // For multi-select: use N (respondents); for single-select: use total
                                            const denominator = isMultiSelect && splitN > 0 ? splitN : ctx.dataset.data.reduce((a, b) => a + b, 0);
                                            const pct = denominator > 0 ? ((ctx.raw / denominator) * 100).toFixed(1) : '0.0';
                                            return `${ctx.raw} (${pct}%)`;
                                        }
                                    }
                                }
                            },
                            scales: {
                                x: { 
                                    grid: { color: 'rgba(255,255,255,0.1)' }, 
                                    ticks: { color: '#b8c4d0', font: { size: 12, weight: '500' } },
                                    beginAtZero: true
                                },
                                y: { 
                                    grid: { display: false }, 
                                    ticks: { 
                                        display: false  // Y labels are external now
                                    }
                                }
                            }
                        }
                    });
                }
            } else if (chartType === 'horizontal-bar') {
                // Old horizontal bar (fallback) - shouldn't be used in split view anymore
                const sortedKeys = getCanonicalKeyOrder(Object.keys(filteredData));
                const displayLabels = sortedKeys.map(k => {
                    // First strip any parenthetical content
                    let label = k.replace(/\s*\([^)]*\)/g, '').trim();
                    // Preserve age ranges (18-25, 76+, etc.)
                    if (/^\d+-\d+$/.test(label) || /^\d+\+$/.test(label)) return label;
                    const numVal = parseFloat(label);
                    if (!isNaN(numVal) && numVal === Math.floor(numVal) && label === String(numVal)) return Math.floor(numVal).toString();
                    return label;
                });
                const values = sortedKeys.map(k => filteredData[k]);
                
                charts[cellId] = new Chart(canvas.getContext('2d'), {
                    type: 'bar',
                    data: {
                        labels: displayLabels,
                        datasets: [{ data: values, backgroundColor: ds.baseColor, borderWidth: 0 }]
                    },
                    options: {
                        indexAxis: 'y',
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { display: false },
                            tooltip: {
                                callbacks: {
                                    label: ctx => {
                                        const total = ctx.dataset.data.reduce((a, b) => a + b, 0);
                                        const pct = ((ctx.raw / total) * 100).toFixed(1);
                                        return `${ctx.raw} (${pct}%)`;
                                    }
                                }
                            }
                        },
                        scales: {
                            x: { grid: { color: 'rgba(255,255,255,0.1)' }, ticks: { color: '#8b949e' } },
                            y: { grid: { display: false }, ticks: { color: '#c9d1d9', font: { size: 10 } } }
                        }
                    }
                });
            } else if (chartType === 'vertical-bar') {
                // Vertical bar chart - single color (base color)
                const sortedKeys = getCanonicalKeyOrder(Object.keys(filteredData));
                const displayLabels = sortedKeys.map(k => {
                    // First strip any parenthetical content
                    let label = k.replace(/\s*\([^)]*\)/g, '').trim();
                    // Preserve age ranges (18-25, 76+, etc.)
                    if (/^\d+-\d+$/.test(label) || /^\d+\+$/.test(label)) return label;
                    const numVal = parseFloat(label);
                    if (!isNaN(numVal) && numVal === Math.floor(numVal) && label === String(numVal)) return Math.floor(numVal).toString();
                    return label;
                });
                const values = sortedKeys.map(k => filteredData[k]);
                
                charts[cellId] = new Chart(canvas.getContext('2d'), {
                    type: 'bar',
                    data: {
                        labels: displayLabels,
                        datasets: [{ data: values, backgroundColor: ds.baseColor, borderWidth: 0 }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { display: false },
                            tooltip: {
                                callbacks: {
                                    label: ctx => {
                                        const total = ctx.dataset.data.reduce((a, b) => a + b, 0);
                                        const pct = ((ctx.raw / total) * 100).toFixed(1);
                                        return `${ctx.raw} (${pct}%)`;
                                    }
                                }
                            }
                        },
                        scales: {
                            y: { grid: { color: 'rgba(255,255,255,0.1)' }, ticks: { color: '#8b949e' } },
                            x: { grid: { display: false }, ticks: { color: '#c9d1d9', font: { size: 9 }, maxRotation: 45, minRotation: 45 } }
                        }
                    }
                });
            } else {
                // Doughnut chart
                const sortedKeys = getCanonicalKeyOrder(Object.keys(filteredData));
                // Check if labels need capitalization (EiD Cluster, ICS Group)
                const needsCapitalize = shouldCapitalizeLabels(sortedKeys);
                
                // Check if two splits are active (for UWS abbreviation)
                const twoSplitsActive = (titleSplitSample && titleSplitSource) || 
                                       (titleSplitSource && titleSplitCluster) || 
                                       (titleSplitSample && titleSplitCluster);
                
                const displayLabels = sortedKeys.map(k => {
                    // First strip any parenthetical content
                    let label = k.replace(/\s*\([^)]*\)/g, '').trim();
                    // Preserve age ranges (18-25, 76+, etc.)
                    if (/^\d+-\d+$/.test(label) || /^\d+\+$/.test(label)) return label;
                    // For pure numeric keys (including floats like "1.0"), convert to integer string
                    const numVal = parseFloat(label);
                    if (!isNaN(numVal) && numVal === Math.floor(numVal)) {
                        return Math.floor(numVal).toString();
                    }
                    // Abbreviate UWS when two splits are active (Earth in Danger)
                    if (twoSplitsActive && label.toLowerCase().includes('unresponsive wakefulness syndrome')) {
                        label = label.replace(/unresponsive wakefulness syndrome/gi, 'UWS');
                    }
                    // Capitalize EiD Cluster, ICS Group labels
                    return needsCapitalize ? capitalizeLabel(label) : label;
                });
                const values = sortedKeys.map(k => filteredData[k]);
                const colors = generateScaleColors(ds.baseColor, sortedKeys.length);
                
                // Check if this is a Yes/No binary question - if so, rotate so Yes CENTER is on the LEFT of donut
                const isYesNo = sortedKeys.length === 2 && 
                    sortedKeys.some(k => k.toLowerCase().startsWith('yes')) && 
                    sortedKeys.some(k => k.toLowerCase().startsWith('no'));
                let chartRotation = 0;
                if (isYesNo) {
                    const total = values.reduce((a, b) => a + b, 0);
                    const yesPct = values[0] / total;
                    chartRotation = -90 - (yesPct * 180);
                }
                
                charts[cellId] = new Chart(canvas.getContext('2d'), {
                    type: 'doughnut',
                    data: {
                        labels: displayLabels,
                        datasets: [{ data: values, backgroundColor: colors, borderWidth: 0 }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: true,
                        cutout: '55%',
                        rotation: chartRotation,
                        plugins: {
                            legend: { display: false },
                            tooltip: {
                                callbacks: {
                                    label: ctx => {
                                        const total = ctx.dataset.data.reduce((a, b) => a + b, 0);
                                        const pct = ((ctx.raw / total) * 100).toFixed(1);
                                        // Strip parenthetical content from tooltip label
                                        const cleanLabel = stripTooltipParens(ctx.label);
                                        return `${cleanLabel}: ${ctx.raw} (${pct}%)`;
                                    }
                                }
                            }
                        }
                    }
                });
                
                // Populate legend for doughnut chart
                const legendEl = document.getElementById(`legend-${cellId}`);
                if (legendEl) {
                    // Get legend box size from cell data attribute
                    const boxSize = cell?.dataset.legendBoxSize || 10;
                    let legendHtml = '';
                    displayLabels.forEach((label, idx) => {
                        legendHtml += `<span style="display:inline-flex;align-items:center;gap:2px;"><span style="width:${boxSize}px;height:${boxSize}px;background:${colors[idx]};border-radius:2px;"></span>${label}</span>`;
                    });
                    legendEl.innerHTML = legendHtml;
                }
            }
        });
    });
    
    // Build table with separate columns for Sample Phase, Recruitment, and Cluster
    const { splitBySample: tableSplitSample, splitBySource: tableSplitSource, splitByCluster: tableSplitCluster } = getSplitConfig();
    let tableHeaders = '<th>Question</th>';
    if (tableSplitSample) tableHeaders += '<th>Sample Phase</th>';
    if (tableSplitSource) tableHeaders += '<th>Recruitment</th>';
    if (tableSplitCluster) tableHeaders += '<th>Cluster</th>';
    tableHeaders += '<th>Value</th><th>Count</th><th>%</th>';
    
    let tableHtml = `<table><thead><tr>${tableHeaders}</tr></thead><tbody>`;
    let allRows = [];
    sel.forEach(q => {
        // Get display label (with ICS prefix if needed)
        let tableDisplayLabel = q.l;
        if (cat === 'ics' && !q.l.toLowerCase().includes('grouping')) {
            tableDisplayLabel = 'Do you think a creature/system can ' + q.l;
        }
        
        filteredDatasets.forEach(ds => {
            const data = ds.data.d?.[q.k];
            if (!data) return;
            const total = Object.values(data).filter(v => typeof v === 'number').reduce((a, b) => a + b, 0);
            const sortedKeys = Object.keys(data).filter(k => typeof data[k] === 'number');
            // Check if labels need capitalization (EiD Cluster, ICS Group)
            const needsCapitalize = shouldCapitalizeLabels(sortedKeys);
            for (const [val, count] of Object.entries(data)) {
                if (typeof count !== 'number') continue;
                const pct = total > 0 ? ((count / total) * 100).toFixed(1) : '0.0';
                // Format value - if it's a number-like string, show as integer
                let displayVal = val;
                const numVal = parseFloat(val);
                if (!isNaN(numVal) && numVal === Math.floor(numVal)) {
                    displayVal = Math.floor(numVal).toString();
                } else if (needsCapitalize) {
                    displayVal = capitalizeLabel(val);
                }
                // Build row with separate columns
                let rowHtml = `<tr><td>${tableDisplayLabel}</td>`;
                if (tableSplitSample) rowHtml += `<td>${ds.sampleKey ? capitalizePhase(ds.sampleKey) : '-'}</td>`;
                if (tableSplitSource) rowHtml += `<td>${ds.sourceKey || '-'}</td>`;
                if (tableSplitCluster) rowHtml += `<td>${ds.clusterKey ? capitalizeLabel(ds.clusterKey) : '-'}</td>`;
                rowHtml += `<td>${displayVal}</td><td>${count}</td><td>${pct}%</td></tr>`;
                allRows.push(rowHtml);
            }
        });
    });
    
    // Show first 10 rows if more than 10, with toggle
    const MAX_ROWS = 10;
    const totalRows = allRows.length;
    if (totalRows > MAX_ROWS) {
        tableHtml += allRows.slice(0, MAX_ROWS).join('');
        tableHtml += '</tbody></table>';
        tableHtml += `<div class="table-pagination" style="margin-top:0.5rem;display:flex;align-items:center;gap:0.75rem;">`;
        tableHtml += `<span style="color:var(--text-muted);font-size:0.9rem;" id="table-row-count">Showing ${MAX_ROWS} of ${totalRows} rows</span>`;
        tableHtml += `<span style="color:#8b949e;font-size:0.9rem;font-weight:600;cursor:pointer;text-decoration:underline;" onclick="toggleTableRows(this, ${totalRows}, 'show-all')" data-action="show-all" data-all-rows='${JSON.stringify(allRows).replace(/'/g, "&#39;")}'>Show all</span>`;
        tableHtml += `<span style="color:#6e7681;">|</span>`;
        tableHtml += `<span style="color:#8b949e;font-size:0.9rem;font-weight:600;cursor:pointer;text-decoration:underline;" onclick="toggleTableRows(this.previousElementSibling.previousElementSibling, ${totalRows}, 'hide-all')">Hide all</span>`;
        tableHtml += `</div>`;
    } else {
        tableHtml += allRows.join('');
        tableHtml += '</tbody></table>';
    }
    tableArea.innerHTML = tableHtml;
    
    // Show free text responses if any are selected (non-split view for now)
    const ftContainer = document.getElementById('free-text-container');
    const ftChecked = ftContainer ? ftContainer.querySelectorAll('input[data-ft-key]:checked').length : 0;
    if (ftChecked > 0) {
        const filter = getFilter();
        showDistFreeText(filter.k);
    }
    
    // Trigger resize for all charts after a brief delay to ensure DOM is ready
    setTimeout(() => {
        Object.values(charts).forEach(chart => {
            if (chart) chart.resize();
        });
    }, 100);
}

// Show split view for entity attributions (ms_attr, c_attr, combined_attr)
function showEntityDistSplit(cat, splitDatasets, checkedInputs) {
    const chartArea = document.getElementById('dist-chart-area');
    const tableArea = document.getElementById('dist-table-container');
    const legendArea = document.getElementById('dist-legend-area');
    
    // Check if this is a double-split (both Sample Phase AND Recruitment)
    const { splitBySample, splitBySource } = getSplitConfig();
    const isDoubleSplit = splitBySample && splitBySource;
    
    // Combined attributions - show side-by-side scatter plots
    if (cat === 'combined_attr') {
        showCombinedAttrSplit(splitDatasets, checkedInputs);
        return;
    }
    
    // Get selected entities
    const sel = checkedInputs.map(cb => ({
        entity: cb.dataset.entity,
        short: cb.nextElementSibling?.textContent || cb.dataset.entity
    }));
    
    const type = cat === 'ms_attr' ? 'ms' : 'c';
    const numSplits = splitDatasets.length;
    
    // Helper to get distribution key for an entity
    const getDistKey = (entity) => {
        const colKey = `${type}_${entity}`;
        const surveyEntry = Object.entries(DATA.metadata.survey_questions).find(([k, v]) => v === colKey);
        console.log('[showEntityDistSplit] Looking up entity:', entity, 'colKey:', colKey, 'found:', surveyEntry);
        const surveyKey = surveyEntry?.[0];
        return surveyKey ? `survey_${surveyKey}` : null;
    };
    
    // Debug: log first dataset keys
    if (splitDatasets.length > 0) {
        const firstDs = splitDatasets[0];
        const availableKeys = Object.keys(firstDs.data.d || {}).filter(k => k.includes('survey_') && (k.includes('_ms_') || k.includes('ms_') || k.includes('_c_') || k.includes('c_'))).slice(0, 10);
        console.log('[showEntityDistSplit] Sample available keys with ms/c:', availableKeys);
        console.log('[showEntityDistSplit] All survey_questions:', Object.entries(DATA.metadata.survey_questions).slice(0, 10));
    }
    
    // Build legend with non-bold title and grayscale colors (since each split has its own color scheme)
    const legendTitle = cat === 'ms_attr' ? 'Does it Have Moral Status?' : 'Does it Have Consciousness?';
    const ratingLabels = {1: 'Does Not Have', 2: "Probably Doesn't Have", 3: 'Probably Has', 4: 'Has'};
    // Use grayscale colors for the main legend since per-split legends use the split's color scheme
    const grayColors = ['#6e6e6e', '#8a8a8a', '#a6a6a6', '#c2c2c2'];
    let legendHtml = '<div class="legend-bar">';
    legendHtml += `<span class="legend-title" style="font-weight:normal;">${legendTitle}</span>`;
    [1, 2, 3, 4].forEach((k, i) => {
        legendHtml += `<span class="legend-item"><span class="legend-color" style="background:${grayColors[i]}"></span>${k}: ${ratingLabels[k]}</span>`;
    });
    legendHtml += '</div>';
    legendArea.innerHTML = legendHtml;
    
    // Calculate donut size based on number of splits - reduced heights
    const donutSize = numSplits >= 6 ? 110 : (numSplits >= 4 ? 130 : 150);
    const cellHeight = numSplits >= 6 ? 200 : (numSplits >= 4 ? 220 : 240);
    const legendFontSize = numSplits >= 6 ? '0.7rem' : (numSplits >= 4 ? '0.75rem' : '0.8rem');
    const legendBoxSize = numSplits >= 6 ? 9 : (numSplits >= 4 ? 10 : 11);
    
    // Create grid: one row per entity, one column per split
    let html = '<div class="split-container">';
    
    // Header row with split labels
    html += '<div class="split-header-row" style="display:grid; grid-template-columns: 140px repeat(' + numSplits + ', 1fr); gap:0.5rem; margin-bottom:1rem;">';
    html += '<div></div>';  // Empty corner
    splitDatasets.forEach(ds => {
        html += `<div class="split-column-header" style="background:${ds.baseColor}; color:white;">${ds.label}<br><small>N=${ds.data.n}</small></div>`;
    });
    html += '</div>';
    
    // Entity rows
    sel.forEach((e, eIdx) => {
        html += `<div class="split-question-row" style="display:grid; grid-template-columns: 140px repeat(${numSplits}, 1fr); gap:0.5rem; margin-bottom:1rem; align-items:center;">`;
        
        // Entity label - larger font to match chart titles
        html += `<div class="split-question-label" style="font-size:1.1rem; font-weight:500; padding:0.5rem; color:var(--text-primary); line-height:1.3;">${e.short}</div>`;
        
        // Charts for each split
        const distKey = getDistKey(e.entity);
        splitDatasets.forEach((ds, sIdx) => {
            const data = distKey ? ds.data.d?.[distKey] : null;
            const cellId = `split-entity-${eIdx}-${sIdx}`;
            
            const hasData = data && Object.values(data).some(v => typeof v === 'number' && v > 0);
            
            html += `<div class="chart-cell" style="height:${cellHeight}px; display:flex; flex-direction:column; align-items:center; justify-content:flex-start; overflow:visible;">`;
            if (!hasData) {
                html += `<div class="no-data-message" style="display:flex;align-items:center;justify-content:center;flex:1;width:100%;color:var(--text-muted);font-size:0.85rem;text-align:center;padding:1rem;">Data not available:<br>this sample was not presented with this question</div>`;
            } else {
                html += `<div class="split-chart-legend" id="legend-${cellId}" style="font-size:${legendFontSize}; min-height:50px; display:flex; flex-wrap:wrap; gap:0.3rem; justify-content:center; align-items:center; margin-bottom:8px; padding:0 4px;"></div>`;
                html += `<div style="width:${donutSize}px;height:${donutSize}px;flex-shrink:0;"><canvas id="${cellId}"></canvas></div>`;
            }
            html += `</div>`;
        });
        
        html += '</div>';
    });
    
    html += '</div>';
    chartArea.innerHTML = html;
    
    // Render charts with shade-based colors per split
    sel.forEach((e, eIdx) => {
        const distKey = getDistKey(e.entity);
        splitDatasets.forEach((ds, sIdx) => {
            const data = distKey ? ds.data.d?.[distKey] : null;
            const cellId = `split-entity-${eIdx}-${sIdx}`;
            const canvas = document.getElementById(cellId);
            if (!canvas || !data) return;
            
            // Filter and sort by rating (1-4)
            const filteredData = {};
            for (const [k, v] of Object.entries(data)) {
                if (typeof v === 'number') filteredData[k] = v;
            }
            
            const sortedKeys = ['1', '2', '3', '4'].filter(k => filteredData[k] !== undefined);
            // Also check for float keys like '1.0', '2.0', etc.
            if (sortedKeys.length === 0) {
                ['1.0', '2.0', '3.0', '4.0'].forEach(fk => {
                    if (filteredData[fk] !== undefined) {
                        sortedKeys.push(fk);
                    }
                });
            }
            const values = sortedKeys.map(k => filteredData[k]);
            
            // Use shade-based colors from the split's base color (same as Graded Consciousness)
            const colors = generateScaleColors(ds.baseColor, 4);
            const chartColors = sortedKeys.map(k => colors[parseInt(parseFloat(k)) - 1]);
            
            charts[cellId] = new Chart(canvas.getContext('2d'), {
                type: 'doughnut',
                data: {
                    labels: sortedKeys.map(k => String(parseInt(parseFloat(k)))),
                    datasets: [{ data: values, backgroundColor: chartColors, borderWidth: 0 }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    cutout: '55%',
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                title: ctx => {
                                    // Show label name at top of tooltip
                                    const ratingLabels = {1: 'Does Not Have', 2: "Probably Doesn't Have", 3: 'Probably Has', 4: 'Has'};
                                    return ratingLabels[parseInt(ctx[0].label)] || ctx[0].label;
                                },
                                label: ctx => {
                                    // Show "N: count (pct%)"
                                    const total = ctx.dataset.data.reduce((a, b) => a + b, 0);
                                    const pct = ((ctx.raw / total) * 100).toFixed(1);
                                    return `${ctx.label}: ${ctx.raw} (${pct}%)`;
                                }
                            }
                        }
                    }
                }
            });
            
            // Populate legend for this cell with shade-based colors
            // In double-split case, show only numbers; otherwise show full labels
            const legendEl = document.getElementById(`legend-${cellId}`);
            if (legendEl) {
                console.log('[showEntityDistSplit] Legend element found:', cellId, 'sortedKeys:', sortedKeys, 'chartColors:', chartColors, 'isDoubleSplit:', isDoubleSplit);
                let legendHtml = '';
                sortedKeys.forEach((k, idx) => {
                    const intKey = parseInt(parseFloat(k));
                    if (isDoubleSplit) {
                        // Double split: show only numbers
                        legendHtml += `<span style="display:inline-flex;align-items:center;gap:3px;margin:2px 3px;"><span style="width:${legendBoxSize}px;height:${legendBoxSize}px;background:${chartColors[idx]};border-radius:2px;display:inline-block;flex-shrink:0;"></span><span>${intKey}</span></span>`;
                    } else {
                        // Single split: show full labels
                        const labelText = ratingLabels[intKey] || intKey;
                        legendHtml += `<span style="display:inline-flex;align-items:center;gap:3px;margin:2px 3px;white-space:nowrap;"><span style="width:${legendBoxSize}px;height:${legendBoxSize}px;background:${chartColors[idx]};border-radius:2px;display:inline-block;flex-shrink:0;"></span><span>${intKey}: ${labelText}</span></span>`;
                    }
                });
                legendEl.innerHTML = legendHtml;
            }
        });
    });
    
    // Build table with separate columns
    const { splitBySample: tableSplitSample, splitBySource: tableSplitSource, splitByCluster: tableSplitCluster } = getSplitConfig();
    let tableHeaders = '<th>Entity</th>';
    if (tableSplitSample) tableHeaders += '<th>Sample Phase</th>';
    if (tableSplitSource) tableHeaders += '<th>Recruitment</th>';
    if (tableSplitCluster) tableHeaders += '<th>Cluster</th>';
    tableHeaders += '<th>Rating</th><th>Count</th><th>%</th>';
    
    let tableHtml = `<table><thead><tr>${tableHeaders}</tr></thead><tbody>`;
    let allRows = [];
    
    sel.forEach(e => {
        const distKey = getDistKey(e.entity);
        splitDatasets.forEach(ds => {
            const data = distKey ? ds.data.d?.[distKey] : null;
            if (!data) return;
            const total = Object.values(data).filter(v => typeof v === 'number').reduce((a, b) => a + b, 0);
            ['1', '2', '3', '4', '1.0', '2.0', '3.0', '4.0'].forEach(rating => {
                const count = data[rating];
                if (typeof count !== 'number') return;
                const intRating = parseInt(parseFloat(rating));
                const pct = total > 0 ? ((count / total) * 100).toFixed(1) : '0.0';
                let rowHtml = `<tr><td>${e.short}</td>`;
                if (tableSplitSample) rowHtml += `<td>${ds.sampleKey ? capitalizePhase(ds.sampleKey) : '-'}</td>`;
                if (tableSplitSource) rowHtml += `<td>${ds.sourceKey || '-'}</td>`;
                if (tableSplitCluster) rowHtml += `<td>${ds.clusterKey ? capitalizeLabel(ds.clusterKey) : '-'}</td>`;
                rowHtml += `<td>${ratingLabels[intRating]}</td><td>${count}</td><td>${pct}%</td></tr>`;
                allRows.push(rowHtml);
            });
        });
    });
    
    // Show first 10 rows if more than 10, with toggle
    const MAX_ROWS = 10;
    const totalRows = allRows.length;
    if (totalRows > MAX_ROWS) {
        tableHtml += allRows.slice(0, MAX_ROWS).join('');
        tableHtml += '</tbody></table>';
        tableHtml += `<div class="table-pagination" style="margin-top:0.5rem;display:flex;align-items:center;gap:0.75rem;">`;
        tableHtml += `<span style="color:var(--text-muted);font-size:0.9rem;" id="table-row-count">Showing ${MAX_ROWS} of ${totalRows} rows</span>`;
        tableHtml += `<span style="color:#8b949e;font-size:0.9rem;font-weight:600;cursor:pointer;text-decoration:underline;" onclick="toggleTableRows(this, ${totalRows}, 'show-all')" data-action="show-all" data-all-rows='${JSON.stringify(allRows).replace(/'/g, "&#39;")}'>Show all</span>`;
        tableHtml += `<span style="color:#6e7681;">|</span>`;
        tableHtml += `<span style="color:#8b949e;font-size:0.9rem;font-weight:600;cursor:pointer;text-decoration:underline;" onclick="toggleTableRows(this.previousElementSibling.previousElementSibling, ${totalRows}, 'hide-all')">Hide all</span>`;
        tableHtml += `</div>`;
    } else {
        tableHtml += allRows.join('');
        tableHtml += '</tbody></table>';
    }
    tableArea.innerHTML = tableHtml;
    
    // Trigger resize for all charts after a brief delay to ensure DOM is ready
    setTimeout(() => {
        Object.values(charts).forEach(chart => {
            if (chart) chart.resize();
        });
    }, 100);
}

// Show split view for combined entity attributions (scatter plots)
function showCombinedAttrSplit(splitDatasets, checkedInputs) {
    const chartArea = document.getElementById('dist-chart-area');
    const tableArea = document.getElementById('dist-table-container');
    const legendArea = document.getElementById('dist-legend-area');
    
    // Get selected entities
    const entities = checkedInputs.map(cb => ({
        entity: cb.dataset.entity,
        short: cb.nextElementSibling?.textContent || cb.dataset.entity
    }));
    
    // Get display mode from radio buttons
    const displayModeRadio = document.querySelector('input[name="display-mode"]:checked');
    const displayMode = displayModeRadio?.value || 'both';
    
    const numSplits = splitDatasets.length;
    const totalN = splitDatasets.reduce((sum, ds) => sum + (ds.data.n || 0), 0);
    
    // Determine split type for title
    const splitType = splitDatasets[0]?.label?.includes('/') ? 'Sample Phase & Recruitment' : (splitDatasets[0]?.sampleKey ? 'Sample Phase' : 'Recruitment');
    
    // Build entity color map
    const entityColors = {};
    DATA.metadata.entity_list?.forEach(e => { entityColors[e.key] = e.color; });
    
    // Rating labels for tick labels (same as non-split)
    const RL = {1: 'Does Not Have', 2: "Probably Doesn't Have", 3: 'Probably Has', 4: 'Has'};
    
    document.getElementById('dist-title').innerHTML = `Entity Combined Attributions (Split by ${splitType}) <span class="filter-badge">Total N=${totalN}</span>`;
    
    // ============================================================
    // MEAN MODE: Side-by-side panels like other split views
    // ============================================================
    if (displayMode === 'mean') {
        // Build entity legend (entity colors)
        let legendHtml = '<div class="legend-bar">';
        entities.forEach(e => {
            const color = entityColors[e.entity] || '#58a6ff';
            legendHtml += `<span class="legend-item"><span class="legend-color" style="background:${color}"></span>${e.short}</span>`;
        });
        legendHtml += '</div>';
        legendArea.innerHTML = legendHtml;
        
        // For double-split (5 panels), use 2 rows: 3 on top, 2 on bottom
        const isDoubleSplit = numSplits >= 5;
        
        let html = '<div class="split-container">';
        
        if (isDoubleSplit) {
            // Row 1: First 3 panels (Pre-registered + Follow-up)
            html += '<div style="display:grid; grid-template-columns: repeat(3, 1fr); gap:0.5rem; margin-bottom:0.75rem;">';
            [0, 1, 4].forEach(idx => {  // Pre-reg/Free, Pre-reg/Prolific, Follow-up/Prolific
                if (splitDatasets[idx]) {
                    const ds = splitDatasets[idx];
                    html += `<div>`;
                    html += `<div class="split-column-header" style="background:${ds.baseColor}; color:white; padding:0.5rem; text-align:center; border-radius:6px 6px 0 0;">${ds.label}<br><small>N=${ds.data.n}</small></div>`;
                    html += `<div class="chart-cell" style="background:var(--bg-tertiary); border-radius:0 0 8px 8px; padding:0.4rem;">`;
                    html += `<canvas id="split-scatter-${idx}"></canvas>`;
                    html += `</div></div>`;
                }
            });
            html += '</div>';
            
            // Row 2: Exploratory panels - left-aligned with first 2 columns
            html += '<div style="display:grid; grid-template-columns: repeat(3, 1fr); gap:0.5rem;">';
            [2, 3].forEach(idx => {  // Exploratory/Free, Exploratory/Prolific
                if (splitDatasets[idx]) {
                    const ds = splitDatasets[idx];
                    html += `<div>`;
                    html += `<div class="split-column-header" style="background:${ds.baseColor}; color:white; padding:0.5rem; text-align:center; border-radius:6px 6px 0 0;">${ds.label}<br><small>N=${ds.data.n}</small></div>`;
                    html += `<div class="chart-cell" style="background:var(--bg-tertiary); border-radius:0 0 8px 8px; padding:0.4rem;">`;
                    html += `<canvas id="split-scatter-${idx}"></canvas>`;
                    html += `</div></div>`;
                }
            });
            html += '<div></div>';  // Empty third column
            html += '</div>';
        } else {
            // Single row layout for 2-3 splits
            html += '<div style="display:grid; grid-template-columns: repeat(' + numSplits + ', 1fr); gap:0.5rem;">';
            splitDatasets.forEach((ds, sIdx) => {
                html += `<div>`;
                html += `<div class="split-column-header" style="background:${ds.baseColor}; color:white; padding:0.5rem; text-align:center; border-radius:6px 6px 0 0;">${ds.label}<br><small>N=${ds.data.n}</small></div>`;
                html += `<div class="chart-cell" style="background:var(--bg-tertiary); border-radius:0 0 8px 8px; padding:0.4rem;">`;
                html += `<canvas id="split-scatter-${sIdx}"></canvas>`;
                html += `</div></div>`;
            });
            html += '</div>';
        }
        
        html += '</div>';
        chartArea.innerHTML = html;
        
        // Abbreviated labels for X-axis (no tilt, use short forms)
        const xTickLabels = {
            1: numSplits >= 3 ? "Doesn't\nHave" : 'Does Not Have',
            2: numSplits >= 3 ? "Prob.\nDoesn't" : "Probably Doesn't Have",
            3: numSplits >= 3 ? 'Prob.\nHas' : 'Probably Has',
            4: 'Has'
        };
        
        // Render scatter charts for Mean mode
        splitDatasets.forEach((ds, sIdx) => {
            const canvas = document.getElementById(`split-scatter-${sIdx}`);
            if (!canvas) return;
            
            // Use the entity stats from the split data (already merged by getDataForFilter)
            const entityStats = ds.data.e || {};
            const datasets = [];
            
            // Mean points for all entities in entity colors - adjust dot size based on splits
            const dotSize = numSplits <= 2 ? 10 : (numSplits <= 3 ? 9 : 8);
            entities.forEach(e => {
                const stats = entityStats[e.entity];
                if (stats?.c_mean != null && stats?.ms_mean != null) {
                    const color = entityColors[e.entity] || '#58a6ff';
                    const darkerBorder = color.replace(/^#/, '');
                    const r = Math.max(0, parseInt(darkerBorder.substr(0,2), 16) - 60);
                    const g = Math.max(0, parseInt(darkerBorder.substr(2,2), 16) - 60);
                    const b = Math.max(0, parseInt(darkerBorder.substr(4,2), 16) - 60);
                    const darkBorderColor = `#${r.toString(16).padStart(2,'0')}${g.toString(16).padStart(2,'0')}${b.toString(16).padStart(2,'0')}`;
                    
                    datasets.push({
                        label: e.short,
                        data: [{
                            x: stats.c_mean, y: stats.ms_mean,
                            entity: e.short, entityKey: e.entity,
                            cMean: stats.c_mean, msMean: stats.ms_mean,
                            cSem: stats.c_sem, msSem: stats.ms_sem, n: stats.paired_n
                        }],
                        backgroundColor: color,
                        borderColor: darkBorderColor,
                        borderWidth: 1.5,
                        pointRadius: dotSize,
                        pointStyle: 'circle'
                    });
                }
            });
            
            charts[`split-scatter-${sIdx}`] = new Chart(canvas.getContext('2d'), {
                type: 'scatter',
                data: {datasets},
                options: {
                    responsive: true, 
                    maintainAspectRatio: true,
                    aspectRatio: 1.1,  // Slightly wider than tall to account for x-axis labels
                    layout: { padding: { top: 5, right: 5, bottom: 0, left: 0 } },
                    plugins: {
                        legend: {display: false},
                        tooltip: {
                            callbacks: {
                                title: items => items[0]?.raw?.entity || '',
                                label: ctx => {
                                    const pt = ctx.raw;
                                    return [
                                        `Consciousness: M=${pt.cMean.toFixed(2)} ± ${pt.cSem?.toFixed(3) || '—'}`,
                                        `Moral Status: M=${pt.msMean.toFixed(2)} ± ${pt.msSem?.toFixed(3) || '—'}`,
                                        `N: ${pt.n || '—'}`
                                    ];
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            min: 0.7, max: 4.3,
                            title: {display: true, text: 'Consciousness', color: '#e6edf3', font: {size: 12, weight: '500'}},
                            ticks: {
                                stepSize: 1, color: '#e6edf3', 
                                font: {size: 10},
                                maxRotation: 0, minRotation: 0,
                                callback: v => (v >= 1 && v <= 4 && Number.isInteger(v)) ? xTickLabels[v] : ''
                            },
                            grid: {color: '#30363d'},
                            afterBuildTicks: axis => { axis.ticks = [1,2,3,4].map(v => ({value: v})); }
                        },
                        y: {
                            min: 0.7, max: 4.3,
                            title: {display: true, text: 'Moral Status', color: '#e6edf3', font: {size: 12, weight: '500'}},
                            ticks: {
                                stepSize: 1, color: '#e6edf3', 
                                font: {size: 10},
                                callback: v => (v >= 1 && v <= 4 && Number.isInteger(v)) ? RL[v] : ''
                            },
                            grid: {color: '#30363d'},
                            afterBuildTicks: axis => { axis.ticks = [1,2,3,4].map(v => ({value: v})); }
                        }
                    }
                }
            });
        });
    }
    // ============================================================
    // INDIVIDUAL or BOTH MODE: One full-size scatter per entity
    // ============================================================
    else {
        // No global legend - each entity scatter has its own split legend
        legendArea.innerHTML = '';
        
        // Determine split type for filename
        const splitFilenamePart = splitType.includes('&') ? 'split-both' : (splitDatasets[0]?.sampleKey ? 'split-sample' : 'split-recruitment');
        
        // Adjust chart height based on number of splits - larger when fewer
        const scatterHeight = numSplits <= 2 ? 500 : (numSplits <= 3 ? 450 : 400);
        
        // Create one full-size scatter per entity, stacked vertically
        let html = '';
        entities.forEach((e, eIdx) => {
            // Build split legend for this entity
            let splitLegendHtml = '<div class="legend-bar" style="margin-bottom:0.5rem;">';
            splitDatasets.forEach(ds => {
                splitLegendHtml += `<span class="legend-item"><span class="legend-color" style="background:${ds.baseColor}"></span>${ds.label}</span>`;
            });
            splitLegendHtml += '</div>';
            
            html += `<div class="entity-scatter-section" data-entity="${e.entity}" data-entity-short="${e.short}" style="margin-bottom:2rem; background:var(--bg-tertiary); border-radius:10px; padding:1rem;">`;
            html += `<div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:0.5rem;">`;
            html += `<h4 style="font-size:1.15rem; margin:0; color:var(--text-secondary);">${e.short}</h4>`;
            html += `<button class="download-entity-btn btn" data-entity-idx="${eIdx}" style="padding:0.3rem 0.6rem; font-size:0.8rem;">⬇ Download PNG</button>`;
            html += `</div>`;
            html += splitLegendHtml;
            html += `<div class="chart-container" style="height:${scatterHeight}px;"><canvas id="entity-scatter-${eIdx}"></canvas></div>`;
            html += `</div>`;
        });
        chartArea.innerHTML = html;
        
        // Add click handlers for per-entity download buttons
        chartArea.querySelectorAll('.download-entity-btn').forEach(btn => {
            btn.addEventListener('click', function() {
                const idx = this.dataset.entityIdx;
                const section = this.closest('.entity-scatter-section');
                const entityShort = section?.dataset?.entityShort || 'entity';
                downloadEntityScatter(idx, entityShort, splitFilenamePart);
            });
        });
        
        // Render scatter chart for each entity
        entities.forEach((e, eIdx) => {
            const canvas = document.getElementById(`entity-scatter-${eIdx}`);
            if (!canvas) return;
            
            const datasets = [];
            const countMap = {};
            const splitNMap = {};
            
            // Collect position counts for jitter calculation
            const positionCounts = {};
            splitDatasets.forEach(ds => {
                // Use entity stats from split data (already merged by getDataForFilter)
                const entityStats = ds.data.e || {};
                const stats = entityStats[e.entity];
                if (stats?.scatter_data?.length) {
                    stats.scatter_data.forEach(([c, ms]) => {
                        const cInt = Math.round(parseFloat(c));
                        const msInt = Math.round(parseFloat(ms));
                        const key = `${ds.label}_${cInt}_${msInt}`;
                        positionCounts[key] = (positionCounts[key] || 0) + 1;
                    });
                }
            });
            
            const getJitter = count => {
                if (count <= 1) return 0;
                if (count <= 5) return 0.08;
                if (count <= 15) return 0.12;
                if (count <= 40) return 0.18;
                return 0.22;
            };
            
            // Individual data points colored by split
            splitDatasets.forEach(ds => {
                // Use entity stats from split data
                const entityStats = ds.data.e || {};
                const stats = entityStats[e.entity];
                if (!stats?.scatter_data?.length) return;
                
                splitNMap[ds.label] = stats.scatter_data.length;
                const points = [];
                
                stats.scatter_data.forEach(([c, ms]) => {
                    const cInt = Math.round(parseFloat(c));
                    const msInt = Math.round(parseFloat(ms));
                    const key = `${ds.label}_${cInt}_${msInt}`;
                    countMap[key] = (countMap[key] || 0) + 1;
                    
                    const countAtPosition = positionCounts[key] || 1;
                    const jitterRadius = getJitter(countAtPosition);
                    let jitterX = 0, jitterY = 0;
                    if (jitterRadius > 0) {
                        const angle = Math.random() * 2 * Math.PI;
                        const r = Math.sqrt(Math.random()) * jitterRadius;
                        jitterX = r * Math.cos(angle) * 1.1;
                        jitterY = r * Math.sin(angle) * 0.9;
                    }
                    
                    points.push({
                        x: cInt + jitterX, y: msInt + jitterY,
                        splitLabel: ds.label, cOrig: cInt, msOrig: msInt, isMean: false
                    });
                });
                
                datasets.push({
                    label: ds.label,
                    data: points,
                    backgroundColor: ds.baseColor + (displayMode === 'both' ? '55' : '99'),
                    borderColor: ds.baseColor,
                    pointRadius: 4,
                    order: 2
                });
            });
            
            // Mean points colored by split (for 'both' mode)
            if (displayMode === 'both') {
                splitDatasets.forEach(ds => {
                    // Use entity stats from split data
                    const entityStats = ds.data.e || {};
                    const stats = entityStats[e.entity];
                    if (stats?.c_mean != null && stats?.ms_mean != null) {
                        const darkerBorder = ds.baseColor.replace(/^#/, '');
                        const r = Math.max(0, parseInt(darkerBorder.substr(0,2), 16) - 60);
                        const g = Math.max(0, parseInt(darkerBorder.substr(2,2), 16) - 60);
                        const b = Math.max(0, parseInt(darkerBorder.substr(4,2), 16) - 60);
                        const darkBorderColor = `#${r.toString(16).padStart(2,'0')}${g.toString(16).padStart(2,'0')}${b.toString(16).padStart(2,'0')}`;
                        
                        datasets.push({
                            label: ds.label + ' (Mean)',
                            data: [{
                                x: stats.c_mean, y: stats.ms_mean,
                                splitLabel: ds.label, isMean: true,
                                cMean: stats.c_mean, msMean: stats.ms_mean,
                                cSem: stats.c_sem, msSem: stats.ms_sem, n: stats.paired_n
                            }],
                            backgroundColor: ds.baseColor,
                            borderColor: darkBorderColor,
                            borderWidth: 2,
                            pointRadius: 12,
                            pointStyle: 'circle',
                            order: 1
                        });
                    }
                });
            }
            
            charts[`entity-scatter-${eIdx}`] = new Chart(canvas.getContext('2d'), {
                type: 'scatter',
                data: {datasets},
                options: {
                    responsive: true, maintainAspectRatio: false,
                    plugins: {
                        legend: {display: false},
                        tooltip: {
                            mode: 'point',
                            callbacks: {
                                title: items => {
                                    if (!items.length) return '';
                                    const pt = items[0].raw;
                                    if (pt.isMean) return pt.splitLabel;
                                    const cLabels = {1: 'Does not have consciousness', 2: "Probably doesn't have consciousness", 3: 'Probably has consciousness', 4: 'Has consciousness'};
                                    const msLabels = {1: 'Does not have moral status', 2: "Probably doesn't have moral status", 3: 'Probably has moral status', 4: 'Has moral status'};
                                    return `${cLabels[pt.cOrig]} & ${msLabels[pt.msOrig]}`;
                                },
                                label: ctx => {
                                    const pt = ctx.raw;
                                    if (pt.isMean) {
                                        return [
                                            `Consciousness: M=${pt.cMean.toFixed(2)} ± ${pt.cSem?.toFixed(3) || '—'}`,
                                            `Moral Status: M=${pt.msMean.toFixed(2)} ± ${pt.msSem?.toFixed(3) || '—'}`,
                                            `N: ${pt.n || '—'}`
                                        ];
                                    }
                                    const count = countMap[`${pt.splitLabel}_${pt.cOrig}_${pt.msOrig}`] || 1;
                                    const splitTotal = splitNMap[pt.splitLabel] || count;
                                    const pct = ((count / splitTotal) * 100).toFixed(1);
                                    return `${pt.splitLabel}: ${count} (${pct}%)`;
                                }
                            },
                            filter: (item, index, items) => {
                                const pt = item.raw;
                                if (pt.isMean) return true;
                                const key = `${pt.splitLabel}_${pt.cOrig}_${pt.msOrig}`;
                                for (let i = 0; i < index; i++) {
                                    const prevPt = items[i].raw;
                                    if (!prevPt.isMean && `${prevPt.splitLabel}_${prevPt.cOrig}_${prevPt.msOrig}` === key) return false;
                                }
                                return true;
                            }
                        }
                    },
                    scales: {
                        x: {
                            min: 0.5, max: 4.5,
                            title: {display: true, text: 'Consciousness', color: '#e6edf3', font: {size: 16, weight: '500'}},
                            ticks: {
                                stepSize: 1, color: '#e6edf3', font: {size: 14},
                                callback: v => (v >= 1 && v <= 4 && Number.isInteger(v)) ? RL[v] : ''
                            },
                            grid: {color: '#30363d'},
                            afterBuildTicks: axis => { axis.ticks = [1,2,3,4].map(v => ({value: v})); }
                        },
                        y: {
                            min: 0.5, max: 4.5,
                            title: {display: true, text: 'Moral Status', color: '#e6edf3', font: {size: 16, weight: '500'}},
                            ticks: {
                                stepSize: 1, color: '#e6edf3', font: {size: 14},
                                callback: v => (v >= 1 && v <= 4 && Number.isInteger(v)) ? RL[v] : ''
                            },
                            grid: {color: '#30363d'},
                            afterBuildTicks: axis => { axis.ticks = [1,2,3,4].map(v => ({value: v})); }
                        }
                    }
                }
            });
        });
    }
    
    // Build comparison table with pagination
    const { splitBySample: tableSplitSample, splitBySource: tableSplitSource, splitByCluster: tableSplitCluster } = getSplitConfig();
    let tableHeaders = '<th>Entity</th>';
    if (tableSplitSample) tableHeaders += '<th>Sample Phase</th>';
    if (tableSplitSource) tableHeaders += '<th>Recruitment</th>';
    if (tableSplitCluster) tableHeaders += '<th>Cluster</th>';
    tableHeaders += '<th>C Mean</th><th>C SEM</th><th>MS Mean</th><th>MS SEM</th><th>N</th>';
    
    let tableHtml = `<div style="margin-top:1.5rem;"><table><thead><tr>${tableHeaders}</tr></thead><tbody>`;
    
    const allRows = [];
    entities.forEach(e => {
        splitDatasets.forEach(ds => {
            // Use entity stats from split data
            const entityStats = ds.data.e || {};
            const stats = entityStats[e.entity];
            if (!stats) return;
            
            let row = `<tr><td>${e.short}</td>`;
            if (tableSplitSample) row += `<td>${ds.sampleKey ? capitalizePhase(ds.sampleKey) : '-'}</td>`;
            if (tableSplitSource) row += `<td>${ds.sourceKey || '-'}</td>`;
            if (tableSplitCluster) row += `<td>${ds.clusterKey ? capitalizeLabel(ds.clusterKey) : '-'}</td>`;
            row += `<td>${stats.c_mean?.toFixed(2) || '—'}</td>`;
            row += `<td>${stats.c_sem?.toFixed(3) || '—'}</td>`;
            row += `<td>${stats.ms_mean?.toFixed(2) || '—'}</td>`;
            row += `<td>${stats.ms_sem?.toFixed(3) || '—'}</td>`;
            row += `<td>${stats.paired_n || '—'}</td></tr>`;
            allRows.push(row);
        });
    });
    
    // Show first 10 rows if more than 10, with toggle
    const MAX_ROWS = 10;
    const totalRows = allRows.length;
    if (totalRows > MAX_ROWS) {
        tableHtml += allRows.slice(0, MAX_ROWS).join('');
        tableHtml += '</tbody></table>';
        tableHtml += `<div class="table-pagination" style="margin-top:0.5rem;display:flex;align-items:center;gap:0.75rem;">`;
        tableHtml += `<span style="color:var(--text-muted);font-size:0.9rem;" id="table-row-count">Showing ${MAX_ROWS} of ${totalRows} rows</span>`;
        tableHtml += `<span style="color:#8b949e;font-size:0.9rem;font-weight:600;cursor:pointer;text-decoration:underline;" onclick="toggleTableRows(this, ${totalRows}, 'show-all')" data-action="show-all" data-all-rows='${JSON.stringify(allRows).replace(/'/g, "&#39;")}'>Show all</span>`;
        tableHtml += `<span style="color:#6e7681;">|</span>`;
        tableHtml += `<span style="color:#8b949e;font-size:0.9rem;font-weight:600;cursor:pointer;text-decoration:underline;" onclick="toggleTableRows(this.previousElementSibling.previousElementSibling, ${totalRows}, 'hide-all')">Hide all</span>`;
        tableHtml += `</div></div>`;
    } else {
        tableHtml += allRows.join('');
        tableHtml += '</tbody></table></div>';
    }
    tableArea.innerHTML = tableHtml;
    
    // Update download button visibility
    setTimeout(updateDownloadButton, 100);
}

// Show split view for single question
function showSingleDistSplit(v, splitDatasets, catName, splitLabel, followUpNote = '') {
    const chartArea = document.getElementById('dist-chart-area');
    const tableArea = document.getElementById('dist-table-container');
    const legendArea = document.getElementById('dist-legend-area');
    
    const totalN = splitDatasets.reduce((sum, ds) => sum + (ds.data.n || 0), 0);
    
    document.getElementById('dist-title').innerHTML = `${catName}${splitLabel} <span class="filter-badge">Total N=${totalN}</span>${followUpNote}`;
    
    const numSplits = splitDatasets.length;
    const gridClass = numSplits <= 2 ? 'cols-2' : numSplits <= 3 ? 'cols-3' : 'cols-4';
    
    // Create grid with one cell per split
    let html = `<div class="chart-grid ${gridClass}">`;
    
    splitDatasets.forEach((ds, idx) => {
        const data = ds.data.d?.[v];
        html += `<div class="chart-cell">`;
        html += `<div class="split-column-header" style="background:${ds.baseColor}; color:white; margin-bottom:0.5rem;">${ds.label}<br><small>N=${ds.data.n}</small></div>`;
        html += `<canvas id="split-single-${idx}"></canvas>`;
        html += `</div>`;
    });
    
    html += '</div>';
    chartArea.innerHTML = html;
    
    // Render charts
    splitDatasets.forEach((ds, idx) => {
        const data = ds.data.d?.[v];
        const canvas = document.getElementById(`split-single-${idx}`);
        if (!canvas || !data) return;
        
        // Filter out suppressed values
        const filteredData = {};
        for (const [k, val] of Object.entries(data)) {
            if (typeof val === 'number') filteredData[k] = val;
        }
        
        const sortedKeys = getCanonicalKeyOrder(Object.keys(filteredData));
        
        // Format keys as integers if they are numeric (but preserve age ranges), and strip parentheses
        const displayLabels = sortedKeys.map(k => {
            // First strip any parenthetical content
            let label = k.replace(/\s*\([^)]*\)/g, '').trim();
            // Preserve age ranges (18-25, 76+, etc.)
            if (/^\d+-\d+$/.test(label) || /^\d+\+$/.test(label)) return label;
            const numVal = parseFloat(label);
            if (!isNaN(numVal) && numVal === Math.floor(numVal) && label === String(numVal)) {
                return Math.floor(numVal).toString();
            }
            return label;
        });
        
        const values = sortedKeys.map(k => filteredData[k]);
        const colors = generateScaleColors(ds.baseColor, sortedKeys.length);
        
        // Check if this is a Yes/No binary question - if so, rotate so Yes CENTER is on the LEFT of donut
        const isYesNo = sortedKeys.length === 2 && 
            sortedKeys.some(k => k.toLowerCase().startsWith('yes')) && 
            sortedKeys.some(k => k.toLowerCase().startsWith('no'));
        let chartRotation = 0;
        if (isYesNo) {
            const total = values.reduce((a, b) => a + b, 0);
            const yesPct = values[0] / total;
            chartRotation = -90 - (yesPct * 180);
        }
        
        charts[`split-single-${idx}`] = new Chart(canvas.getContext('2d'), {
            type: 'doughnut',
            data: {
                labels: displayLabels,
                datasets: [{ data: values, backgroundColor: colors, borderWidth: 0 }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: true,
                cutout: '55%',
                rotation: chartRotation,
                plugins: {
                    legend: { display: true, position: 'top', labels: { font: { size: 11 }, boxWidth: 14, padding: 8 } },
                    tooltip: {
                        callbacks: {
                            label: ctx => {
                                const total = ctx.dataset.data.reduce((a, b) => a + b, 0);
                                const pct = ((ctx.raw / total) * 100).toFixed(1);
                                // Strip parenthetical content from tooltip label
                                const cleanLabel = stripTooltipParens(ctx.label);
                                return `${cleanLabel}: ${ctx.raw} (${pct}%)`;
                            }
                        }
                    }
                }
            }
        });
    });
    
    // Build table with separate columns
    const { splitBySample: tableSplitSample, splitBySource: tableSplitSource } = getSplitConfig();
    let tableHeaders = '';
    if (tableSplitSample) tableHeaders += '<th>Sample Phase</th>';
    if (tableSplitSource) tableHeaders += '<th>Recruitment</th>';
    tableHeaders += '<th>Value</th><th>Count</th><th>%</th>';
    
    let tableHtml = `<table><thead><tr>${tableHeaders}</tr></thead><tbody>`;
    let allRows = [];
    splitDatasets.forEach(ds => {
        const data = ds.data.d?.[v];
        if (!data) return;
        const total = Object.values(data).filter(val => typeof val === 'number').reduce((a, b) => a + b, 0);
        for (const [val, count] of Object.entries(data)) {
            if (typeof count !== 'number') continue;
            const pct = total > 0 ? ((count / total) * 100).toFixed(1) : '0.0';
            // Format value as integer if applicable
            let displayVal = val;
            const numVal = parseFloat(val);
            if (!isNaN(numVal) && numVal === Math.floor(numVal)) {
                displayVal = Math.floor(numVal).toString();
            }
            let rowHtml = '<tr>';
            if (tableSplitSample) rowHtml += `<td>${ds.sampleKey ? capitalizePhase(ds.sampleKey) : '-'}</td>`;
            if (tableSplitSource) rowHtml += `<td>${ds.sourceKey || '-'}</td>`;
            rowHtml += `<td>${displayVal}</td><td>${count}</td><td>${pct}%</td></tr>`;
            allRows.push(rowHtml);
        }
    });
    
    // Show first 10 rows if more than 10, with toggle
    const MAX_ROWS = 10;
    const totalRows = allRows.length;
    if (totalRows > MAX_ROWS) {
        tableHtml += allRows.slice(0, MAX_ROWS).join('');
        tableHtml += '</tbody></table>';
        tableHtml += `<div class="table-pagination" style="margin-top:0.5rem;display:flex;align-items:center;gap:0.75rem;">`;
        tableHtml += `<span style="color:var(--text-muted);font-size:0.9rem;" id="table-row-count">Showing ${MAX_ROWS} of ${totalRows} rows</span>`;
        tableHtml += `<span style="color:#8b949e;font-size:0.9rem;font-weight:600;cursor:pointer;text-decoration:underline;" onclick="toggleTableRows(this, ${totalRows}, 'show-all')" data-action="show-all" data-all-rows='${JSON.stringify(allRows).replace(/'/g, "&#39;")}'>Show all</span>`;
        tableHtml += `<span style="color:#6e7681;">|</span>`;
        tableHtml += `<span style="color:#8b949e;font-size:0.9rem;font-weight:600;cursor:pointer;text-decoration:underline;" onclick="toggleTableRows(this.previousElementSibling.previousElementSibling, ${totalRows}, 'hide-all')">Hide all</span>`;
        tableHtml += `</div>`;
    } else {
        tableHtml += allRows.join('');
        tableHtml += '</tbody></table>';
    }
    tableArea.innerHTML = tableHtml;
    
    // Trigger resize for all charts after a brief delay to ensure DOM is ready
    setTimeout(() => {
        Object.values(charts).forEach(chart => {
            if (chart) chart.resize();
        });
    }, 100);
}

function getSelectedEntities(type) {
    const vbox = document.getElementById('vbox');
    if (!vbox) return [];
    return Array.from(vbox.querySelectorAll('input:checked:not(#v-all)')).map(cb => {
        const entity = cb.dataset.entity;
        const entityInfo = DATA.metadata.entity_list?.find(e => e.key === entity);
        return {
            entity: entity,
            short: cb.nextElementSibling.textContent,
            color: entityInfo?.color || '#58a6ff',
            l: cb.nextElementSibling.textContent
        };
    });
}

function showEntityDonuts(entities, type, dists, badge, legendArea) {
    const prefix = type === 'ms' ? 'Moral Status' : 'Consciousness';
    const legendTitle = type === 'ms' ? 'Does it Have Moral Status?' : 'Does it Have Consciousness?';
    document.getElementById('dist-title').innerHTML = `${prefix} Attributions: ${entities.length} ${entities.length === 1 ? 'Entity' : 'Entities'}${badge}`;
    
    const chartArea = document.getElementById('dist-chart-area');
    const tableArea = document.getElementById('dist-table-container');
    
    // Helper to convert to integer string (handles floats)
    const toIntStr = l => String(parseInt(parseFloat(l)));
    
    // Check if any entity has data
    const hasAnyData = entities.some(e => {
        const colKey = `${type}_${e.entity}`;
        const surveyKey = Object.entries(DATA.metadata.survey_questions).find(([k, v]) => v === colKey)?.[0];
        const data = surveyKey ? dists[`survey_${surveyKey}`] : null;
        return data && Object.keys(data).length > 0;
    });
    
    if (!hasAnyData) {
        legendArea.innerHTML = '';
        chartArea.innerHTML = '<p class="no-data"><em>Data not available: this sample was not presented with these questions</em></p>';
        tableArea.innerHTML = '';
        return;
    }
    
    // Show title above legend (centered, gray, larger) then legend without title
    legendArea.innerHTML = `<div style="text-align:center;color:var(--text-muted);font-size:1.15rem;margin-bottom:0.75rem;">${legendTitle}</div>` + buildRatingLegend('rating', '');
    
    if (entities.length === 1) {
        const e = entities[0];
        const colKey = `${type}_${e.entity}`;
        const surveyKey = Object.entries(DATA.metadata.survey_questions).find(([k, v]) => v === colKey)?.[0];
        const data = surveyKey ? dists[`survey_${surveyKey}`] : null;
        
        if (!data) { chartArea.innerHTML = '<p class="no-data"><em>Data not available: this sample was not presented with this question</em></p>'; tableArea.innerHTML = ''; legendArea.innerHTML = ''; return; }
        showSingleDonut(data, e.short, false);  // false = don't show side legend
    } else {
        const gridClass = entities.length <= 4 ? 'cols-4' : 'cols-4';
        chartArea.innerHTML = `<div class="chart-grid ${gridClass}" id="cgrid"></div>`;
        const grid = document.getElementById('cgrid');
        
        // Collect all rows for sorting
        let rows = [];
        
        entities.forEach((e, i) => {
            const colKey = `${type}_${e.entity}`;
            const surveyKey = Object.entries(DATA.metadata.survey_questions).find(([k, v]) => v === colKey)?.[0];
            const data = surveyKey ? dists[`survey_${surveyKey}`] : null;
            if (!data) return;
            
            const cell = document.createElement('div'); cell.className = 'chart-cell';
            // Reduce spacing: smaller min-height on h4, tighter padding
            cell.innerHTML = `<h4 style="font-size:1.1rem;min-height:auto;margin-bottom:0.25rem;">${e.short}</h4><canvas id="c-${i}"></canvas>`;
            cell.style.padding = '0.5rem';
            grid.appendChild(cell);
            
            // Sort keys numerically for rating scale (1,2,3,4) - handles floats
            const sortedKeys = Object.keys(data).sort((a, b) => parseFloat(a) - parseFloat(b));
            const labels = sortedKeys.map(l => RLab(toIntStr(l)));
            const values = sortedKeys.map(k => typeof data[k] === 'number' ? data[k] : 0);
            const total = values.reduce((a, b) => a + b, 0);
            
            charts[`c-${i}`] = new Chart(document.getElementById(`c-${i}`).getContext('2d'), {
                type: 'doughnut', data: {labels, datasets: [{data: values, backgroundColor: getColors(sortedKeys), borderWidth: 0}]},
                options: {responsive: true, plugins: {legend: {display: false}, tooltip: {callbacks: {label: ctx => `${ctx.label}: ${ctx.raw} (${((ctx.raw/total)*100).toFixed(1)}%)`}}}}
            });
            
            // Store data for table (one row per entity)
            const entityData = {entity: e.short, total: total, ratings: {}};
            sortedKeys.forEach(l => {
                const v = data[l];
                const valueNum = parseInt(parseFloat(l)) || 0;
                entityData.ratings[valueNum] = {
                    count: v,
                    sup: typeof v === 'string',
                    pct: typeof v === 'string' ? '—' : ((v/total)*100).toFixed(1)+'%'
                };
            });
            rows.push(entityData);
        });
        
        // Build table with one row per entity, columns for each rating
        // Use same labels as RL constant for consistency
        let tbl = '<table><thead><tr><th>Entity</th>';
        [1, 2, 3, 4].forEach(r => {
            tbl += `<th>${r}: ${RL[String(r)]}</th><th>% ${r}: ${RL[String(r)]}</th>`;
        });
        tbl += '</tr></thead><tbody>';
        
        rows.forEach(r => {
            tbl += `<tr><td>${r.entity}</td>`;
            [1, 2, 3, 4].forEach(rating => {
                const rd = r.ratings[rating] || {count: '—', pct: '—', sup: false};
                tbl += `<td class="${rd.sup?'suppressed':''}">${rd.count}</td><td class="${rd.sup?'suppressed':''}">${rd.pct}</td>`;
            });
            tbl += '</tr>';
        });
        tableArea.innerHTML = tbl + '</tbody></table>';
    }
}

function showCombinedScatter(entities, entityStats, badge, legendArea, displayMode = 'both') {
    const modeLabels = {'mean': 'Mean ± SE', 'individual': 'Individual Data', 'both': 'Both'};
    document.getElementById('dist-title').innerHTML = `Entity Combined Attributions: ${entities.length} ${entities.length === 1 ? 'Entity' : 'Entities'}${badge}`;
    
    const chartArea = document.getElementById('dist-chart-area');
    const tableArea = document.getElementById('dist-table-container');
    
    if (!entityStats || Object.keys(entityStats).length === 0) {
        chartArea.innerHTML = '<p class="no-data">Data not available</p>';
        tableArea.innerHTML = '';
        return;
    }
    
    // Build entity color map
    const entityColors = {};
    DATA.metadata.entity_list?.forEach(e => { entityColors[e.key] = e.color; });
    
    // Build legend for entities
    let legendHtml = '<div class="legend-bar">';
    entities.forEach(e => {
        const color = entityColors[e.entity] || '#58a6ff';
        legendHtml += `<span class="legend-item"><span class="legend-color" style="background:${color}"></span>${e.short}</span>`;
    });
    legendHtml += '</div>';
    legendArea.innerHTML = legendHtml;
    
    // Collect datasets based on display mode
    const countMap = {};
    const entityNMap = {};  // Track total N per entity
    const datasets = [];
    
    // Individual data points (for 'individual' and 'both' modes)
    if (displayMode === 'individual' || displayMode === 'both') {
        // First pass: count points at each position for each entity
        const positionCounts = {};
        entities.forEach(e => {
            const stats = entityStats[e.entity];
            if (stats?.scatter_data?.length) {
                // Store total N for this entity
                entityNMap[e.entity] = stats.scatter_data.length;
                stats.scatter_data.forEach(([c, ms]) => {
                    const cInt = Math.round(parseFloat(c));
                    const msInt = Math.round(parseFloat(ms));
                    const key = `${e.entity}_${cInt}_${msInt}`;
                    positionCounts[key] = (positionCounts[key] || 0) + 1;
                });
            }
        });
        
        // Adaptive jitter based on count at each position
        const getJitter = (count) => {
            if (count <= 1) return 0;
            if (count <= 5) return 0.08;
            if (count <= 15) return 0.12;
            if (count <= 40) return 0.18;
            return 0.22;  // max jitter (reduced from 0.4)
        };
        
        entities.forEach((e, idx) => {
            const stats = entityStats[e.entity];
            if (stats?.scatter_data?.length) {
                const color = entityColors[e.entity] || '#58a6ff';
                const points = [];
                
                // Track which position index we're at for each position
                const positionIndex = {};
                
                stats.scatter_data.forEach(([c, ms]) => {
                    const cInt = Math.round(parseFloat(c));
                    const msInt = Math.round(parseFloat(ms));
                    const key = `${e.entity}_${cInt}_${msInt}`;
                    countMap[key] = (countMap[key] || 0) + 1;
                    
                    // Get count at this position for jitter calculation
                    const countAtPosition = positionCounts[key] || 1;
                    const jitterRadius = getJitter(countAtPosition);
                    
                    // Ellipse jitter (slightly wider horizontally)
                    let jitterX = 0, jitterY = 0;
                    if (jitterRadius > 0) {
                        const angle = Math.random() * 2 * Math.PI;
                        const r = Math.sqrt(Math.random()) * jitterRadius;
                        jitterX = r * Math.cos(angle) * 1.1;  // Slight horizontal bias
                        jitterY = r * Math.sin(angle) * 0.9;
                    }
                    
                    points.push({
                        x: cInt + jitterX,
                        y: msInt + jitterY,
                        entity: e.short,
                        entityKey: e.entity,
                        cOrig: cInt,
                        msOrig: msInt,
                        isMean: false
                    });
                });
                datasets.push({
                    label: e.short,
                    data: points,
                    backgroundColor: color + (displayMode === 'both' ? '55' : '99'),
                    borderColor: color,
                    pointRadius: 4,
                    order: 2
                });
            }
        });
    }
    
    // Mean points (for 'mean' and 'both' modes) - SE shown only on hover via tooltip
    if (displayMode === 'mean' || displayMode === 'both') {
        entities.forEach((e, idx) => {
            const stats = entityStats[e.entity];
            if (stats?.c_mean != null && stats?.ms_mean != null) {
                const color = entityColors[e.entity] || '#58a6ff';
                
                // Mean point dataset (larger dot with darker border)
                // Darken the color for the border
                const darkerBorder = color.replace(/^#/, '');
                const r = Math.max(0, parseInt(darkerBorder.substr(0,2), 16) - 60);
                const g = Math.max(0, parseInt(darkerBorder.substr(2,2), 16) - 60);
                const b = Math.max(0, parseInt(darkerBorder.substr(4,2), 16) - 60);
                const darkBorderColor = `#${r.toString(16).padStart(2,'0')}${g.toString(16).padStart(2,'0')}${b.toString(16).padStart(2,'0')}`;
                
                datasets.push({
                    label: e.short + ' (Mean)',
                    data: [{
                        x: stats.c_mean,
                        y: stats.ms_mean,
                        entity: e.short,
                        entityKey: e.entity,
                        isMean: true,
                        cMean: stats.c_mean,
                        msMean: stats.ms_mean,
                        cSem: stats.c_sem,
                        msSem: stats.ms_sem,
                        n: stats.paired_n
                    }],
                    backgroundColor: color,
                    borderColor: darkBorderColor,
                    borderWidth: 1.5,
                    pointRadius: 12,
                    pointStyle: 'circle',
                    order: 1  // Draw means on top
                });
            }
        });
    }
    
    chartArea.innerHTML = '<div class="chart-container"><canvas id="dist-chart"></canvas></div>';
    
    charts.main = new Chart(document.getElementById('dist-chart').getContext('2d'), {
        type: 'scatter',
        data: {datasets},
        options: {
            responsive: true, maintainAspectRatio: false,
            plugins: {
                legend: {display: false},
                tooltip: {
                    mode: 'point',
                    callbacks: {
                        title: (items) => {
                            if (!items.length) return '';
                            // Check if any are mean points
                            const meanItems = items.filter(i => i.raw.isMean);
                            if (meanItems.length > 0) {
                                return meanItems.map(i => i.raw.entity).join(', ');
                            }
                            // For individual points, show descriptive position (4-point scale)
                            const pt = items[0].raw;
                            const cLabels = {
                                1: 'Does not have consciousness',
                                2: 'Probably doesn\'t have consciousness',
                                3: 'Probably has consciousness',
                                4: 'Has consciousness'
                            };
                            const msLabels = {
                                1: 'Does not have moral status',
                                2: 'Probably doesn\'t have moral status',
                                3: 'Probably has moral status',
                                4: 'Has moral status'
                            };
                            const cLabel = cLabels[pt.cOrig] || `Consciousness=${pt.cOrig}`;
                            const msLabel = msLabels[pt.msOrig] || `Moral Status=${pt.msOrig}`;
                            return `${cLabel} & ${msLabel}`;
                        },
                        label: ctx => {
                            const pt = ctx.raw;
                            if (pt.isMean) {
                                return [
                                    `Consciousness: M=${pt.cMean.toFixed(2)} ± ${pt.cSem?.toFixed(3) || '—'}`,
                                    `Moral Status: M=${pt.msMean.toFixed(2)} ± ${pt.msSem?.toFixed(3) || '—'}`,
                                    `N: ${pt.n || '—'}`
                                ];
                            }
                            const count = countMap[`${pt.entityKey}_${pt.cOrig}_${pt.msOrig}`] || 1;
                            const entityTotal = entityNMap[pt.entityKey] || count;
                            const pct = ((count / entityTotal) * 100).toFixed(1);
                            return `${pt.entity}: ${count} (${pct}%)`;
                        },
                        // Deduplicate labels for same entity at same position
                        afterBody: (items) => {
                            return [];  // Used to deduplicate via filter below
                        }
                    },
                    filter: (item, index, items) => {
                        // For individual points, deduplicate by entity + position
                        const pt = item.raw;
                        if (pt.isMean) return true;  // Always show mean points
                        const key = `${pt.entityKey}_${pt.cOrig}_${pt.msOrig}`;
                        // Check if this is the first occurrence of this entity at this position
                        for (let i = 0; i < index; i++) {
                            const prevPt = items[i].raw;
                            if (!prevPt.isMean) {
                                const prevKey = `${prevPt.entityKey}_${prevPt.cOrig}_${prevPt.msOrig}`;
                                if (prevKey === key) return false;  // Duplicate, filter out
                            }
                        }
                        return true;
                    }
                }
            },
            scales: {
                x: {
                    min: 0.5, max: 4.5,
                    title: {display: true, text: 'Consciousness', color: '#e6edf3', font: {size: 16, weight: '500'}},
                    ticks: {
                        stepSize: 1,
                        color: '#e6edf3',
                        font: {size: 14},
                        callback: function(value) {
                            if (value >= 1 && value <= 4 && Number.isInteger(value)) {
                                return RL[value] || value;
                            }
                            return '';
                        }
                    },
                    grid: {
                        color: '#30363d',
                        drawOnChartArea: true
                    },
                    afterBuildTicks: function(axis) {
                        axis.ticks = [1, 2, 3, 4].map(v => ({value: v}));
                    }
                },
                y: {
                    min: 0.5, max: 4.5,
                    title: {display: true, text: 'Moral Status', color: '#e6edf3', font: {size: 16, weight: '500'}},
                    ticks: {
                        stepSize: 1,
                        color: '#e6edf3',
                        font: {size: 14},
                        callback: function(value) {
                            if (value >= 1 && value <= 4 && Number.isInteger(value)) {
                                return RL[value] || value;
                            }
                            return '';
                        }
                    },
                    grid: {
                        color: '#30363d',
                        drawOnChartArea: true
                    },
                    afterBuildTicks: function(axis) {
                        axis.ticks = [1, 2, 3, 4].map(v => ({value: v}));
                    }
                }
            }
        }
    });
    
    // Table with stats
    let tbl = '<table><thead><tr><th>Entity</th><th>C Mean</th><th>C SD</th><th>C SEM</th><th>MS Mean</th><th>MS SD</th><th>MS SEM</th><th>N</th></tr></thead><tbody>';
    entities.forEach(e => {
        const s = entityStats[e.entity];
        if (s) {
            tbl += `<tr><td>${e.short}</td><td>${s.c_mean?.toFixed(2)||'—'}</td><td>${s.c_std?.toFixed(2)||'—'}</td><td>${s.c_sem?.toFixed(3)||'—'}</td><td>${s.ms_mean?.toFixed(2)||'—'}</td><td>${s.ms_std?.toFixed(2)||'—'}</td><td>${s.ms_sem?.toFixed(3)||'—'}</td><td>${s.paired_n||'—'}</td></tr>`;
        }
    });
    tableArea.innerHTML = tbl + '</tbody></table>';
}

function showMultiDist(sel, dists, badge, gridClass, legendArea, category = '') {
    // Get display name for category
    const catSel = document.getElementById('dist-category');
    const catName = getTitleName(catSel?.selectedOptions[0]?.textContent || category);
    document.getElementById('dist-title').innerHTML = `${catName}: ${sel.length} Question${sel.length > 1 ? 's' : ''} Selected${badge}`;
    
    // Check if any questions have data
    const hasAnyData = sel.some(o => {
        const data = dists[o.k];
        return data && Object.keys(data).length > 0;
    });
    
    if (!hasAnyData) {
        legendArea.innerHTML = '';
        document.getElementById('dist-chart-area').innerHTML = '<p class="no-data"><em>Data not available: this sample was not presented with these questions</em></p>';
        document.getElementById('dist-table-container').innerHTML = '';
        return;
    }
    
    // Check if graded_c questions are Equal/Unequal/Incomparable (use numeric GL scale)
    const isGradedNumeric = (label) => {
        const lowerLabel = (label || '').toLowerCase();
        return lowerLabel.includes('equal') || lowerLabel.includes('unequal') || lowerLabel.includes('incomparable');
    };
    
    // Determine scale type PER QUESTION for graded_c category
    const getQuestionScaleType = (o) => {
        if (category === 'graded_c') {
            return isGradedNumeric(o.l) ? 'graded' : 'agreement';
        }
        if (['c_intel'].includes(category)) return 'agreement';
        if (category === 'exp' || category === 'experience') return 'experience';
        return 'rating';
    };
    
    // Get label function for a scale type
    const getLabelFnForScale = (st) => {
        if (st === 'graded') return GLab;
        if (st === 'agreement') return ALab;
        if (st === 'experience') return ELab;
        return RLab;
    };
    
    const useExperienceScale = category === 'exp' || category === 'experience';
    
    // Helper to check if rating scale (handles floats)
    const isRatingScale = (keys) => keys.every(k => ['1','2','3','4'].includes(String(parseInt(parseFloat(k)))));
    const isExperienceScaleFn = (keys) => keys.every(k => ['1','2','3','4','5'].includes(String(parseInt(parseFloat(k)))));
    
    // Check if all questions have same scale type
    const scaleTypes = sel.map(o => getQuestionScaleType(o));
    const allSameScale = scaleTypes.every(st => st === scaleTypes[0]);
    
    // Check if all questions have same response type (for unified legend)
    const allRating = sel.every(o => {
        const data = dists[o.k];
        if (!data) return false;
        const keys = Object.keys(data);
        return useExperienceScale ? isExperienceScaleFn(keys) : isRatingScale(keys);
    });
    
    // If all same type AND same scale, show global legend
    if (allRating && allSameScale) {
        legendArea.innerHTML = buildRatingLegend(scaleTypes[0]);
    } else {
        legendArea.innerHTML = '';  // Per-chart legends will be shown
    }
    
    document.getElementById('dist-chart-area').innerHTML = `<div class="chart-grid ${gridClass}" id="cgrid"></div>`;
    const grid = document.getElementById('cgrid');
    
    // Check if single item for styling
    const isSingleItem = sel.length === 1;
    
    // Collect all rows for sorting
    let rows = [];
    
    sel.forEach((o, i) => {
        const data = dists[o.k];
        if (!data) return;
        
        // Get this question's scale type
        const qScaleType = getQuestionScaleType(o);
        const getLabelFn = getLabelFnForScale(qScaleType);
        
        const cell = document.createElement('div'); 
        cell.className = 'chart-cell' + (isSingleItem ? ' single-item' : '');
        const keys = Object.keys(data);
        const isRating = useExperienceScale ? isExperienceScaleFn(keys) : isRatingScale(keys);
        const isNumeric = keys.every(k => !isNaN(parseFloat(k)));
        
        // Sort keys numerically for rating/numeric scales, or use canonical order for Yes/No etc.
        let sortedKeys = getCanonicalKeyOrder(keys);
        
        // Per-chart legend if not all same type
        let cellLegend = '';
        if (!allRating || !allSameScale) {
            cellLegend = buildChartCellLegend(data, qScaleType);
        }
        
        // Determine plot title - for kill_test use display names (stripped tokens), otherwise use label
        let plotTitle = o.l;
        if (category === 'kill_test' && o.c) {
            plotTitle = DN(o.c).s || o.l;
            // Add prefix for KPT entity descriptions
            plotTitle = 'A creature/system that ' + plotTitle;
        }
        
        // ICS: Add prefix "Do you think a creature/system can " to questions
        if (category === 'ics' && !plotTitle.toLowerCase().includes('grouping')) {
            plotTitle = 'Do you think a creature/system can ' + plotTitle;
        }
        
        // Special handling for specific categories with alignment issues
        // Default to 1.15rem for C&I topics when multiple questions selected
        let titleStyle = '';
        if (['c_intel', 'ics'].includes(category) && sel.length >= 2 && sel.length <= 3) {
            titleStyle = 'font-size:1.15rem;';
        }
        
        // Earth in Danger: smaller font for very long UWS+AI question when 3+ items selected
        if (category === 'earth_danger' && sel.length >= 3) {
            if (plotTitle.includes('unresponsive wakefulness syndrome') && plotTitle.includes('artificial intelligence')) {
                titleStyle = 'font-size:0.85rem;';
            }
        }
        
        // ICS: larger font when all 4 selected (user request)
        if (category === 'ics' && sel.length === 4) {
            titleStyle = 'font-size:1.1rem;';  // Larger font for question titles
        }
        
        // Add consistent legend height for categories with multiple questions and per-cell legends
        let legendStyle = '';
        if ((category === 'moral_cons' || category === 'ics') && sel.length > 1 && (!allRating || !allSameScale)) {
            legendStyle = 'min-height:2.2em;display:flex;align-items:center;justify-content:center;';  // Consistent legend height
        }
        
        const legendWithStyle = cellLegend ? cellLegend.replace('class="chart-cell-legend"', `class="chart-cell-legend" style="${legendStyle}"`) : '';
        
        cell.innerHTML = `<h4 style="${titleStyle}">${plotTitle}</h4>${legendWithStyle}<canvas id="c-${i}"></canvas>`;
        grid.appendChild(cell);
        
        const toIntStr = l => String(parseInt(parseFloat(l)));
        // Check if labels need capitalization (EiD Cluster, ICS Group)
        const needsCapitalize = shouldCapitalizeLabels(sortedKeys);
        const labels = sortedKeys.map(l => {
            if (isRating) return getLabelFn(toIntStr(l));
            if (isNumeric) return toIntStr(l);
            return needsCapitalize ? capitalizeLabel(l) : l;
        });
        const values = sortedKeys.map(k => typeof data[k] === 'number' ? data[k] : 0);
        const total = values.reduce((a, b) => a + b, 0);
        
        // For binary categories (kill_test, earth_danger, ics), simplify labels by removing parenthetical content
        const isBinaryCategory = ['kill_test', 'earth_danger', 'ics', 'moral_cons'].includes(category);
        const simplifyLabel = l => isBinaryCategory ? l.replace(/\s*\([^)]*\)/g, '').trim() : l;
        
        // Check if this is a Yes/No binary question - if so, rotate so Yes CENTER is on the LEFT of donut
        const isYesNo = sortedKeys.length === 2 && 
            sortedKeys.some(k => k.toLowerCase().startsWith('yes')) && 
            sortedKeys.some(k => k.toLowerCase().startsWith('no'));
        let chartRotation = 0;
        if (isYesNo) {
            // To center the first slice (Yes) on the left (9 o'clock = -90 degrees),
            // we need to offset by half of its arc: rotation = -90 - (yesPct * 180)
            const yesPct = values[0] / total;
            chartRotation = -90 - (yesPct * 180);
        }
        console.log('[showMultiDist] Question:', o.l, 'sortedKeys:', sortedKeys, 'isYesNo:', isYesNo, 'chartRotation:', chartRotation);
        
        charts[`c-${i}`] = new Chart(document.getElementById(`c-${i}`).getContext('2d'), {
            type: 'doughnut', data: {labels, datasets: [{data: values, backgroundColor: getColors(sortedKeys, qScaleType), borderWidth: 0}]},
            options: {responsive: true, rotation: chartRotation, plugins: {legend: {display: false}, tooltip: {callbacks: {
                title: ctx => simplifyLabel(ctx[0].chart.data.labels[ctx[0].dataIndex] || ''),
                label: ctx => {
                    const sliceLabel = simplifyLabel(ctx.chart.data.labels[ctx.dataIndex] || '');
                    return `${sliceLabel}: ${ctx.raw} (${((ctx.raw/total)*100).toFixed(1)}%)`;
                }
            }}}}
        });
        
        sortedKeys.forEach((l, idx) => {
            const v = data[l];
            const sup = typeof v === 'string';
            const valueNum = parseInt(parseFloat(l)) || 0;
            rows.push({
                question: plotTitle,  // Use plotTitle which includes ICS prefix
                questionIdx: i,
                value: valueNum,
                valueLabel: labels[idx],  // Use already-processed labels array (includes capitalization)
                rawLabel: l,  // Keep raw label for binary detection
                count: v,
                total: total,
                pct: sup ? '—' : ((v/total)*100).toFixed(1)+'%',
                sup: sup
            });
        });
    });
    
    // Check if this is a binary choice category (each question has exactly 2 options)
    const questionGroups = {};
    rows.forEach(r => {
        if (!questionGroups[r.questionIdx]) questionGroups[r.questionIdx] = [];
        questionGroups[r.questionIdx].push(r);
    });
    const isBinary = Object.values(questionGroups).every(g => g.length === 2);
    const binaryCategories = ['earth_danger', 'ics', 'moral_cons', 'kill_test'];
    const useBinaryFormat = isBinary && binaryCategories.includes(category);
    
    if (useBinaryFormat) {
        // Build one-row-per-question table with category-specific headers
        let tbl = '<table><thead><tr><th>Question</th>';
        if (category === 'earth_danger') {
            tbl += '<th>Option 1</th><th>Count</th><th>%</th><th>Option 2</th><th>Count</th><th>%</th>';
        } else {
            // ICS, Moral Cons, Kill for Test use Yes/No format
            tbl += '<th>Yes</th><th>% Yes</th><th>No</th><th>% No</th>';
        }
        tbl += '</tr></thead><tbody>';
        
        Object.entries(questionGroups).forEach(([idx, group]) => {
            const q = group[0].question;
            
            if (category === 'earth_danger') {
                const opt1 = group[0];
                const opt2 = group[1];
                tbl += `<tr><td>${q}</td>`;
                tbl += `<td>${opt1.valueLabel}</td><td class="${opt1.sup?'suppressed':''}">${opt1.count}</td><td class="${opt1.sup?'suppressed':''}">${opt1.pct}</td>`;
                tbl += `<td>${opt2.valueLabel}</td><td class="${opt2.sup?'suppressed':''}">${opt2.count}</td><td class="${opt2.sup?'suppressed':''}">${opt2.pct}</td>`;
                tbl += '</tr>';
            } else {
                // Find Yes and No responses
                const yesOpt = group.find(g => g.rawLabel === 'Yes' || g.rawLabel.includes('Yes (')) || group[0];
                const noOpt = group.find(g => g.rawLabel === 'No' || g.rawLabel.includes('No (')) || group[1];
                tbl += `<tr><td>${q}</td>`;
                tbl += `<td class="${yesOpt.sup?'suppressed':''}">${yesOpt.count}</td><td class="${yesOpt.sup?'suppressed':''}">${yesOpt.pct}</td>`;
                tbl += `<td class="${noOpt.sup?'suppressed':''}">${noOpt.count}</td><td class="${noOpt.sup?'suppressed':''}">${noOpt.pct}</td>`;
                tbl += '</tr>';
            }
        });
        document.getElementById('dist-table-container').innerHTML = tbl + '</tbody></table>';
    } else {
        // Sort by question index, then by value (for rating scales) or label
        rows.sort((a, b) => {
            if (a.questionIdx !== b.questionIdx) return a.questionIdx - b.questionIdx;
            return a.value - b.value;
        });
        
        // Build standard table
        let tbl = '<table><thead><tr><th>Question</th><th>Value</th><th>Count</th><th>%</th></tr></thead><tbody>';
        rows.forEach(r => {
            tbl += `<tr><td>${r.question}</td><td>${r.valueLabel}</td><td class="${r.sup?'suppressed':''}">${r.count}</td><td class="${r.sup?'suppressed':''}">${r.pct}</td></tr>`;
        });
        document.getElementById('dist-table-container').innerHTML = tbl + '</tbody></table>';
    }
}

function showSingleDonut(data, qName, showSideLegend = true, legendTitle = null) {
    const chartArea = document.getElementById('dist-chart-area');
    const legendArea = document.getElementById('dist-legend-area');
    chartArea.innerHTML = '<div class="chart-container" style="height:400px;"><canvas id="dist-chart"></canvas></div>';
    
    // Helper to convert to integer string (handles floats like '1.0' -> '1')
    const toIntStr = l => String(parseInt(parseFloat(l)));
    const hasDash = Object.keys(data).some(k => k.includes('-'));
    const isNumeric = !hasDash && Object.keys(data).every(k => !isNaN(parseFloat(k)));
    const isR = Object.keys(data).every(k => ['1','2','3','4'].includes(toIntStr(k)));
    
    // Check if this is education data
    const eduOrder = DATA.metadata.education_order || [];
    const isEducation = eduOrder.length > 0 && Object.keys(data).some(k => eduOrder.includes(k));
    
    // Use getCanonicalKeyOrder for consistent ordering (handles Yes/No, education, age groups, etc.)
    let sortedKeys = getCanonicalKeyOrder(Object.keys(data));
    
    // Capitalize labels for EiD Cluster and ICS Group
    const needsCapitalize = shouldCapitalizeLabels(sortedKeys);
    const labels = sortedKeys.map(l => {
        if (isR) return RLab(toIntStr(l));
        if (isNumeric) return toIntStr(l);
        return needsCapitalize ? capitalizeLabel(l) : l;
    });
    const values = sortedKeys.map(k => typeof data[k] === 'number' ? data[k] : 0);
    const total = values.reduce((a, b) => a + b, 0);
    
    // Show horizontal legend (unless externally managed)
    if (showSideLegend) {
        if (isR) {
            legendArea.innerHTML = buildRatingLegend();
        } else {
            legendArea.innerHTML = buildCustomLegend(data, legendTitle);
        }
    }
    // If showSideLegend is false, legend is managed externally (caller should set legendArea.innerHTML)
    
    // Check if this is a Yes/No binary question - if so, rotate so Yes CENTER is on the LEFT of donut
    const isYesNo = sortedKeys.length === 2 && 
        sortedKeys.some(k => k.toLowerCase().startsWith('yes')) && 
        sortedKeys.some(k => k.toLowerCase().startsWith('no'));
    let chartRotation = 0;
    if (isYesNo) {
        // To center the first slice (Yes) on the left (9 o'clock = -90 degrees),
        // we need to offset by half of its arc: rotation = -90 - (yesPct * 180)
        const yesPct = values[0] / total;
        chartRotation = -90 - (yesPct * 180);
    }
    
    charts.main = new Chart(document.getElementById('dist-chart').getContext('2d'), {
        type: 'doughnut',
        data: {labels, datasets: [{data: values, backgroundColor: getColors(sortedKeys), borderWidth: 0}]},
        options: {responsive: true, maintainAspectRatio: false, rotation: chartRotation, plugins: {legend: {display: false}, tooltip: {callbacks: {label: ctx => `${stripTooltipParens(ctx.label)}: ${ctx.raw} (${((ctx.raw/total)*100).toFixed(1)}%)`}}}}
    });
    let h = `<table><thead><tr><th>${qName}</th><th>Count</th><th>%</th></tr></thead><tbody>`;
    sortedKeys.forEach((l, idx) => { 
        const v = data[l];
        const sup = typeof v === 'string';
        const displayLabel = labels[idx];  // Use the already-processed labels array
        h += `<tr><td>${displayLabel}</td><td class="${sup?'suppressed':''}">${v}</td><td class="${sup?'suppressed':''}">` + (sup ? '—' : ((v/total)*100).toFixed(1)+'%') + `</td></tr>`; 
    });
    document.getElementById('dist-table-container').innerHTML = h + '</tbody></table>';
}

function showExperienceDonut(data, qName, legendArea) {
    const chartArea = document.getElementById('dist-chart-area');
    chartArea.innerHTML = '<div class="chart-container" style="height:400px;"><canvas id="dist-chart"></canvas></div>';
    
    // Helper to convert to integer string (handles floats like '1.0' -> '1')
    const toIntStr = l => String(parseInt(parseFloat(l)));
    const isNumeric = Object.keys(data).every(k => !isNaN(parseFloat(k)));
    
    // Sort labels numerically
    let sortedKeys = Object.keys(data);
    if (isNumeric) {
        sortedKeys = sortedKeys.sort((a, b) => parseFloat(a) - parseFloat(b));
    }
    
    // Use numeric labels for display (1, 2, 3, 4, 5)
    const numericLabels = sortedKeys.map(l => toIntStr(l));
    const values = sortedKeys.map(k => typeof data[k] === 'number' ? data[k] : 0);
    const total = values.reduce((a, b) => a + b, 0);
    
    // Show experience scale legend
    legendArea.innerHTML = buildRatingLegend('experience', 'Experience Level');
    
    charts.main = new Chart(document.getElementById('dist-chart').getContext('2d'), {
        type: 'doughnut',
        data: {labels: numericLabels, datasets: [{data: values, backgroundColor: getColors(sortedKeys, 'experience'), borderWidth: 0}]},
        options: {responsive: true, maintainAspectRatio: false, plugins: {legend: {display: false}, tooltip: {callbacks: {label: ctx => `${ctx.label}: ${ctx.raw} (${((ctx.raw/total)*100).toFixed(1)}%)`}}}}
    });
    
    let h = `<table><thead><tr><th>${qName}</th><th>Count</th><th>%</th></tr></thead><tbody>`;
    sortedKeys.forEach(l => { 
        const v = data[l];
        const sup = typeof v === 'string';
        const displayLabel = ELab(toIntStr(l));
        h += `<tr><td>${displayLabel}</td><td class="${sup?'suppressed':''}">${v}</td><td class="${sup?'suppressed':''}">` + (sup ? '—' : ((v/total)*100).toFixed(1)+'%') + `</td></tr>`; 
    });
    document.getElementById('dist-table-container').innerHTML = h + '</tbody></table>';
}

function showBarChart(data, qName, colorKey = null, respondentN = null, exclusiveData = null) {
    const chartArea = document.getElementById('dist-chart-area');
    const legendArea = document.getElementById('dist-legend-area');
    
    // Sort by count (descending)
    const sortedEntries = Object.entries(data)
        .filter(([k, v]) => typeof v === 'number')
        .sort((a, b) => b[1] - a[1]);
    
    const labels = sortedEntries.map(([k]) => k);
    const values = sortedEntries.map(([, v]) => v);
    const totalSelections = values.reduce((a, b) => a + b, 0);
    // Use respondentN for percentage if provided (for multiselect), otherwise use totalSelections
    const percentBase = respondentN || totalSelections;
    
    // Check if exclusive data exists
    const hasExclusiveData = exclusiveData && Object.keys(exclusiveData).length > 0 &&
        Object.values(exclusiveData).some(v => typeof v === 'number' && v > 0);
    
    // Show stacked bar legend if exclusive data exists
    if (hasExclusiveData) {
        legendArea.innerHTML = `
            <div style="display:flex;gap:1.5rem;justify-content:center;align-items:center;padding:0.5rem 1rem;background:var(--bg-tertiary);border-radius:6px;margin-bottom:0.5rem;">
                <span style="font-size:0.85rem;color:var(--text-muted);font-weight:500;">Stacking:</span>
                <div style="display:flex;align-items:center;gap:0.4rem;">
                    <div style="width:16px;height:16px;background:#6e7681;border-radius:2px;"></div>
                    <span style="font-size:0.85rem;color:#c9d1d9;">Selected this option only</span>
                </div>
                <div style="display:flex;align-items:center;gap:0.4rem;">
                    <div style="width:16px;height:16px;background:rgba(110,118,129,0.4);border-radius:2px;"></div>
                    <span style="font-size:0.85rem;color:#c9d1d9;">Selected with other options</span>
                </div>
            </div>`;
    } else {
        legendArea.innerHTML = '';  // No legend needed for bar chart - colors are self-explanatory
    }
    
    // Get colors from metadata or use default
    const colorMap = colorKey ? (DATA.metadata.colors?.[colorKey] || {}) : {};
    const defaultColors = ['#58a6ff','#f78166','#7ee787','#d2a8ff','#ffa657','#79c0ff','#ff7b72','#a5d6ff'];
    const colors = labels.map((l, i) => colorMap[l] || defaultColors[i % defaultColors.length]);
    
    // Helper to wrap long labels into multiple lines
    // Use narrower width for animal_types to prevent label overlap
    const maxWrapWidth = colorKey === 'animal_types' ? 16 : 25;
    const wrapLabel = (label, maxWidth = maxWrapWidth) => {
        if (label.length <= maxWidth) return label;
        const words = label.split(' ');
        const lines = [];
        let currentLine = '';
        for (const word of words) {
            if ((currentLine + ' ' + word).trim().length <= maxWidth) {
                currentLine = (currentLine + ' ' + word).trim();
            } else {
                if (currentLine) lines.push(currentLine);
                currentLine = word;
            }
        }
        if (currentLine) lines.push(currentLine);
        return lines;
    };
    
    // Wrap labels for display
    const wrappedLabels = labels.map(l => wrapLabel(l, maxWrapWidth));
    
    // Use consistent font size (14) matching showStackedBarChart
    const fontSize = 14;
    
    // Calculate appropriate chart height based on number of labels
    const chartHeight = Math.max(350, Math.min(500, labels.length * 35));
    
    chartArea.innerHTML = `<div class="chart-container" style="height:${chartHeight}px;"><canvas id="dist-chart"></canvas></div>`;
    
    if (hasExclusiveData) {
        // Stacked bar chart
        const exclusiveValues = labels.map(l => exclusiveData[l] || 0);
        const nonExclusiveValues = values.map((v, i) => Math.max(0, v - exclusiveValues[i]));
        // Darken original colors for exclusive, lighten for non-exclusive
        const exclusiveColors = colors.map(c => c);
        const nonExclusiveColors = colors.map(c => c + '55');  // Add alpha for lighter shade
        
        charts.main = new Chart(document.getElementById('dist-chart').getContext('2d'), {
            type: 'bar',
            data: {
                labels: wrappedLabels,
                datasets: [
                    {label: 'Only this', data: exclusiveValues, backgroundColor: exclusiveColors, borderWidth: 0},
                    {label: 'With others', data: nonExclusiveValues, backgroundColor: nonExclusiveColors, borderWidth: 0}
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {display: false},
                    tooltip: {
                        callbacks: {
                            title: ctx => stripTooltipParens(labels[ctx[0].dataIndex]),
                            label: ctx => {
                                const total = values[ctx.dataIndex];
                                const exclusive = exclusiveValues[ctx.dataIndex];
                                const pct = percentBase > 0 ? ((ctx.raw / percentBase) * 100).toFixed(1) : '0.0';
                                if (ctx.datasetIndex === 0) {
                                    return `Only this: ${exclusive} (${pct}%)`;
                                } else {
                                    return `With others: ${total - exclusive} (${pct}%)`;
                                }
                            },
                            afterBody: ctx => {
                                const total = values[ctx[0].dataIndex];
                                const pct = percentBase > 0 ? ((total / percentBase) * 100).toFixed(1) : '0.0';
                                return `Total: ${total} (${pct}%)`;
                            }
                        }
                    }
                },
                scales: {
                    x: {
                        stacked: true,
                        grid: {display: false},
                        ticks: {color: '#e6edf3', maxRotation: 0, minRotation: 0, autoSkip: false, font: {size: fontSize}}
                    },
                    y: {
                        stacked: true,
                        beginAtZero: true,
                        grid: {color: '#30363d'},
                        ticks: {color: '#e6edf3', font: {size: 14}},
                        title: {display: true, text: 'Count', color: '#e6edf3', font: {size: 15, weight: 'bold'}}
                    }
                }
            }
        });
    } else {
        // Standard bar chart
        charts.main = new Chart(document.getElementById('dist-chart').getContext('2d'), {
            type: 'bar',
            data: {
                labels: wrappedLabels,
                datasets: [{
                    data: values,
                    backgroundColor: colors,
                    borderWidth: 0
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {display: false},
                    tooltip: {
                        callbacks: {
                            title: ctx => stripTooltipParens(labels[ctx[0].dataIndex]),  // Show full label in tooltip
                            label: ctx => `${ctx.raw} (${((ctx.raw/percentBase)*100).toFixed(1)}%)`
                        }
                    }
                },
                scales: {
                    x: {
                        grid: {display: false},
                        ticks: {
                            color: '#e6edf3',
                            maxRotation: 0,  // Keep labels straight
                            minRotation: 0,
                            autoSkip: false,  // Show all labels
                            font: {size: fontSize}
                        }
                    },
                    y: {
                        beginAtZero: true,
                        grid: {color: '#30363d'},
                        ticks: {color: '#e6edf3', font: {size: 14}},
                        title: {display: true, text: 'Count', color: '#e6edf3', font: {size: 15, weight: 'bold'}}
                    }
                }
            }
        });
    }
    
    // Build table with exclusive counts if available
    let h = `<table><thead><tr><th>${qName}</th><th>Count</th><th>%</th>`;
    if (hasExclusiveData) {
        h += '<th>Only This</th><th>With Others</th>';
    }
    h += '</tr></thead><tbody>';
    sortedEntries.forEach(([k, v]) => {
        const pct = ((v/percentBase)*100).toFixed(1);
        h += `<tr><td>${k}</td><td>${v}</td><td>${pct}%</td>`;
        if (hasExclusiveData) {
            const excl = exclusiveData[k] || 0;
            h += `<td>${excl}</td><td>${v - excl}</td>`;
        }
        h += '</tr>';
    });
    // Add suppressed values
    Object.entries(data).filter(([k, v]) => typeof v === 'string').forEach(([k, v]) => {
        h += `<tr><td>${k}</td><td class="suppressed">${v}</td><td class="suppressed">—</td>`;
        if (hasExclusiveData) {
            h += '<td class="suppressed">—</td><td class="suppressed">—</td>';
        }
        h += '</tr>';
    });
    document.getElementById('dist-table-container').innerHTML = h + '</tbody></table>';
}

function showStackedBarChart(importantData, mostImportantData, title, colorKey = 'moral_features', dists = null, respondentN = null) {
    const chartArea = document.getElementById('dist-chart-area');
    const legendArea = document.getElementById('dist-legend-area');
    
    // Use combined_most data if available (includes single-feature selections as "most important")
    const combinedMostData = dists?.['multiselect_moral_considerations_combined_most'] || mostImportantData;
    
    // Get all unique labels from both datasets
    const allLabels = [...new Set([...Object.keys(importantData || {}), ...Object.keys(combinedMostData || {})])];
    
    // Sort labels by total count (Important is the total, Most Important is a subset)
    const sortedLabels = allLabels
        .filter(l => (typeof importantData?.[l] === 'number') || (typeof combinedMostData?.[l] === 'number'))
        .sort((a, b) => {
            // Sort by total Important count (which includes Most Important selections)
            const aTotal = importantData?.[a] || 0;
            const bTotal = importantData?.[b] || 0;
            return bTotal - aTotal;
        });
    
    // Important = total selections for this feature
    // Most Important = subset of Important (people who also marked it as their single most important)
    // Important Only = Important - Most Important (people who marked it important but not most important)
    const mostValues = sortedLabels.map(l => (typeof combinedMostData?.[l] === 'number') ? combinedMostData[l] : 0);
    const totalImportantValues = sortedLabels.map(l => (typeof importantData?.[l] === 'number') ? importantData[l] : 0);
    // Important Only = Total Important - Most Important (to avoid double counting in stacked bar)
    const importantOnlyValues = sortedLabels.map((l, i) => Math.max(0, totalImportantValues[i] - mostValues[i]));
    
    // Get colors from metadata
    const colorMap = DATA.metadata.colors?.[colorKey] || {};
    const defaultColors = ['#58a6ff','#f78166','#7ee787','#d2a8ff','#ffa657','#79c0ff','#ff7b72','#a5d6ff'];
    const colors = sortedLabels.map((l, i) => colorMap[l] || defaultColors[i % defaultColors.length]);
    
    // Helper to wrap long labels into multiple lines
    const wrapLabel = (label, maxWidth = 20) => {
        if (label.length <= maxWidth) return label;
        const words = label.split(' ');
        const lines = [];
        let currentLine = '';
        for (const word of words) {
            if ((currentLine + ' ' + word).trim().length <= maxWidth) {
                currentLine = (currentLine + ' ' + word).trim();
            } else {
                if (currentLine) lines.push(currentLine);
                currentLine = word;
            }
        }
        if (currentLine) lines.push(currentLine);
        return lines;
    };
    
    // Wrap labels for display
    const wrappedLabels = sortedLabels.map(l => wrapLabel(l, 25));
    
    // Show legend - Most Important is brighter (at bottom), Important Only is more transparent (on top)
    legendArea.innerHTML = '<div class="legend-bar"><span class="legend-item"><span class="legend-color" style="background:rgba(255,255,255,0.9)"></span>Most Important</span><span class="legend-item"><span class="legend-color" style="background:rgba(255,255,255,0.4)"></span>Important (not most)</span></div>';
    
    chartArea.innerHTML = '<div class="chart-container" style="height:480px;"><canvas id="dist-chart"></canvas></div>';
    
    charts.main = new Chart(document.getElementById('dist-chart').getContext('2d'), {
        type: 'bar',
        data: {
            labels: wrappedLabels,
            datasets: [
                {
                    // Most Important at bottom (first), brighter
                    label: 'Most Important',
                    data: mostValues,
                    backgroundColor: colors.map(c => c + 'E6'),  // Brighter (more opaque)
                    borderWidth: 0
                },
                {
                    // Important Only on top (second), more transparent
                    label: 'Important (not most)',
                    data: importantOnlyValues,
                    backgroundColor: colors.map(c => c + '55'),  // More transparent
                    borderWidth: 0
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: {display: false},  // Use our custom legend instead
                tooltip: {
                    callbacks: {
                        title: ctx => sortedLabels[ctx[0].dataIndex],  // Show full label in tooltip
                        label: ctx => {
                            // Use respondentN for percentage (number of people, not sum of selections)
                            const base = respondentN || 1;
                            return `${ctx.dataset.label}: ${ctx.raw} (${((ctx.raw/base)*100).toFixed(1)}%)`;
                        }
                    }
                }
            },
            scales: {
                x: {
                    stacked: true,
                    grid: {display: false},
                    ticks: {
                        color: '#e6edf3',
                        maxRotation: 0,  // Keep labels straight
                        minRotation: 0,
                        autoSkip: false,  // Show all labels
                        font: {size: 14}
                    }
                },
                y: {
                    stacked: true,
                    beginAtZero: true,
                    grid: {color: '#30363d'},
                    ticks: {color: '#e6edf3', font: {size: 13}},
                    title: {display: true, text: 'Count', color: '#e6edf3', font: {size: 14}}
                }
            }
        }
    });
    
    // Build table with percentages
    // Total Important = number of unique people who selected this feature (cannot exceed N)
    // For percentages, use respondentN (number of people who answered, not sum of selections)
    const tableBase = respondentN || 1;  // Avoid division by zero, but respondentN should always be provided
    let h = '<table><thead><tr><th>Feature</th><th>Most Important</th><th>%</th><th>Important Only</th><th>%</th><th>Total</th><th>%</th></tr></thead><tbody>';
    sortedLabels.forEach((l, i) => {
        const impOnly = importantOnlyValues[i];
        const most = mostValues[i];
        const total = totalImportantValues[i];  // Total = Most Important + Important Only
        const mostPct = tableBase > 1 ? ((most/tableBase)*100).toFixed(1) + '%' : '—';
        const impPct = tableBase > 1 ? ((impOnly/tableBase)*100).toFixed(1) + '%' : '—';
        const totalPct = tableBase > 1 ? ((total/tableBase)*100).toFixed(1) + '%' : '—';
        h += `<tr><td>${l}</td><td>${most}</td><td>${mostPct}</td><td>${impOnly}</td><td>${impPct}</td><td>${total}</td><td>${totalPct}</td></tr>`;
    });
    document.getElementById('dist-table-container').innerHTML = h + '</tbody></table>';
}

// Stacked horizontal bars for moral features Combined in split view
function showMoralFeaturesCombinedSplit(splitDatasets, legendArea, chartArea, tableArea) {
    console.log('[showMoralFeaturesCombinedSplit] splitDatasets:', splitDatasets.length);
    
    // Get all unique feature labels across all splits
    const allLabelsSet = new Set();
    splitDatasets.forEach(ds => {
        const importantData = ds.data.d?.['multiselect_moral_considerations_important'] || {};
        Object.keys(importantData).forEach(k => {
            if (typeof importantData[k] === 'number') allLabelsSet.add(k);
        });
    });
    
    // Sort labels by total count across all splits
    const labelTotals = {};
    allLabelsSet.forEach(label => {
        labelTotals[label] = splitDatasets.reduce((sum, ds) => {
            const val = ds.data.d?.['multiselect_moral_considerations_important']?.[label];
            return sum + (typeof val === 'number' ? val : 0);
        }, 0);
    });
    const sortedLabels = [...allLabelsSet].sort((a, b) => labelTotals[b] - labelTotals[a]);
    
    if (sortedLabels.length === 0) {
        chartArea.innerHTML = '<p class="no-data"><em>No data available for the selected filters</em></p>';
        tableArea.innerHTML = '';
        legendArea.innerHTML = '';
        return;
    }
    
    // Check if any split is Follow-up (which doesn't have "Most Important" data)
    const hasFollowUp = splitDatasets.some(ds => ds.label?.toLowerCase().includes('follow'));
    
    // Build title
    const { splitBySample, splitBySource, splitByCluster } = getSplitConfig();
    const splitParts = [];
    if (splitBySample) splitParts.push('Sample Phase');
    if (splitBySource) splitParts.push('Recruitment');
    if (splitByCluster) splitParts.push('Cluster');
    const splitLabel = splitParts.length > 0 ? ` (Split by ${splitParts.join(' & ')})` : '';
    
    // Calculate respondent Ns for each split
    const splitNs = splitDatasets.map(ds => ds.data.rc?.['multiselect_moral_considerations_important'] || ds.data.n || 0);
    const totalN = splitNs.reduce((sum, n) => sum + n, 0);
    const numSplits = splitDatasets.length;
    
    let titleNote = '';
    if (hasFollowUp) {
        titleNote = '<span class="filter-note note-block">NOTE: "Most Important" not asked in Follow-up sample. Follow-up bars show "Important" only.</span>';
    }
    document.getElementById('dist-title').innerHTML = `Important Features for Moral Considerations (Combined)${splitLabel} <span class="filter-badge">Total N=${totalN}</span>${titleNote}`;
    
    // Build stacking legend
    legendArea.innerHTML = `
        <div style="display:flex;gap:1.5rem;justify-content:center;align-items:center;padding:0.5rem 1rem;background:var(--bg-tertiary);border-radius:6px;margin-bottom:0.5rem;">
            <span style="font-size:0.85rem;color:var(--text-muted);font-weight:500;">Stacking:</span>
            <div style="display:flex;align-items:center;gap:0.4rem;">
                <div style="width:16px;height:16px;background:#6e7681;border-radius:2px;"></div>
                <span style="font-size:0.85rem;color:#c9d1d9;">Most Important</span>
            </div>
            <div style="display:flex;align-items:center;gap:0.4rem;">
                <div style="width:16px;height:16px;background:rgba(110,118,129,0.4);border-radius:2px;"></div>
                <span style="font-size:0.85rem;color:#c9d1d9;">Important (not most)</span>
            </div>
        </div>`;
    
    // Match the regular split view layout exactly
    const tickColWidth = '240px';
    const questionLabelWidth = '130px';
    
    // Calculate bar height to match regular split view - must account for x-axis
    const xAxisHeight = 28;  // Height of x-axis labels at bottom
    const chartTopPad = 10;   // Chart.js top padding
    const chartBottomPad = 2; // Small bottom padding before axis
    const barHeightPerLabel = 35;  // Height per bar category
    const plotAreaHeight = sortedLabels.length * barHeightPerLabel;
    const totalBarHeight = plotAreaHeight + xAxisHeight + chartTopPad + chartBottomPad;
    const categoryHeight = plotAreaHeight / sortedLabels.length;
    const barOffsetInCategory = (categoryHeight * 0.15) / 2;  // For bar centering
    
    // Build HTML with header row + chart row (matching regular split view)
    let html = '';
    
    // Header row with split labels and N values
    html += `<div class="split-header-row" style="display:grid; grid-template-columns: ${questionLabelWidth} ${tickColWidth} repeat(${numSplits}, 1fr); gap:0.25rem; margin-bottom:0.5rem;">`;
    html += '<div></div>';  // Question label column (empty in header)
    html += '<div></div>';  // Tick labels column (empty in header)
    splitDatasets.forEach((ds, idx) => {
        html += `<div class="split-column-header" style="background:${ds.baseColor}; color:white; font-size:${numSplits >= 6 ? '0.75rem' : '0.85rem'};">${ds.label}<br><small>N=${splitNs[idx]}</small></div>`;
    });
    html += '</div>';
    
    // Chart row with question label + tick labels + chart panels
    html += `<div class="split-question-row" style="display:grid; grid-template-columns: ${questionLabelWidth} ${tickColWidth} repeat(${numSplits}, 1fr); gap:0.25rem; margin-bottom:1rem; align-items:stretch; overflow:visible;">`;
    
    // Question label
    html += `<div class="split-question-label" style="font-size:0.95rem; padding:0.5rem; color:var(--text-secondary); display:flex; align-items:center; line-height:1.3;">Combined (Important + Most Important)</div>`;
    
    // Tick labels column - match Chart.js layout exactly
    html += `<div class="split-tick-labels" style="display:flex; flex-direction:column; justify-content:flex-start; padding-top:${chartTopPad + barOffsetInCategory}px; height:${totalBarHeight}px; box-sizing:border-box; padding-left:4px;">`;
    sortedLabels.forEach(label => {
        html += `<div style="font-size:0.85rem; color:#c9d1d9; text-align:right; height:${categoryHeight}px; display:flex; align-items:center; justify-content:flex-end; overflow:hidden; padding-right:6px; line-height:1.3; white-space:normal; word-wrap:break-word; text-overflow:clip;" title="${label.replace(/"/g, '&quot;')}">${label}</div>`;
    });
    html += '</div>';
    
    // Chart panels
    splitDatasets.forEach((ds, sIdx) => {
        html += `<div class="chart-cell" style="width:100%;height:${totalBarHeight}px;overflow:visible;">`;
        html += `<div class="hbar-canvas-wrapper" style="width:100%;height:${totalBarHeight}px;position:relative;overflow:visible;"><canvas id="mf-split-${sIdx}" style="position:absolute;top:0;left:0;width:100%;height:100%;"></canvas></div>`;
        html += `</div>`;
    });
    html += '</div>';
    
    chartArea.innerHTML = html;
    
    // Create charts for each split - match regular split view options exactly
    splitDatasets.forEach((ds, sIdx) => {
        const importantData = ds.data.d?.['multiselect_moral_considerations_important'] || {};
        const mostData = ds.data.d?.['multiselect_moral_considerations_combined_most'] || 
                        ds.data.d?.['multiselect_moral_considerations_most'] || {};
        const respondentN = ds.data.rc?.['multiselect_moral_considerations_important'] || ds.data.n || 1;
        const isFollowUp = ds.label?.toLowerCase().includes('follow');
        
        const mostValues = sortedLabels.map(l => {
            if (isFollowUp) return 0;  // Follow-up doesn't have Most Important
            const val = mostData[l];
            return typeof val === 'number' ? val : 0;
        });
        const importantValues = sortedLabels.map(l => {
            const val = importantData[l];
            return typeof val === 'number' ? val : 0;
        });
        // Important Only = Total Important - Most Important
        const importantOnlyValues = sortedLabels.map((l, i) => Math.max(0, importantValues[i] - mostValues[i]));
        
        const canvas = document.getElementById(`mf-split-${sIdx}`);
        if (!canvas) return;
        
        charts[`mf-split-${sIdx}`] = new Chart(canvas.getContext('2d'), {
            type: 'bar',
            data: {
                labels: sortedLabels,
                datasets: [
                    {
                        label: 'Most Important',
                        data: mostValues,
                        backgroundColor: ds.baseColor,
                        borderWidth: 0,
                        barPercentage: 0.85,
                        categoryPercentage: 1.0
                    },
                    {
                        label: 'Important (not most)',
                        data: importantOnlyValues,
                        backgroundColor: ds.baseColor + '55',
                        borderWidth: 0,
                        barPercentage: 0.85,
                        categoryPercentage: 1.0
                    }
                ]
            },
            options: {
                indexAxis: 'y',
                responsive: true,
                maintainAspectRatio: false,
                layout: {
                    padding: { top: chartTopPad, bottom: chartBottomPad, left: 0, right: 10 }
                },
                plugins: {
                    legend: { display: false },
                    tooltip: {
                        callbacks: {
                            title: ctx => stripTooltipParens(sortedLabels[ctx[0].dataIndex]),
                            label: ctx => {
                                const pct = respondentN > 0 ? ((ctx.raw / respondentN) * 100).toFixed(1) : '0.0';
                                return `${ctx.dataset.label}: ${ctx.raw} (${pct}%)`;
                            }
                        }
                    }
                },
                scales: {
                    x: { 
                        stacked: true,
                        grid: { color: 'rgba(255,255,255,0.1)' }, 
                        ticks: { color: '#b8c4d0', font: { size: 11 } },
                        beginAtZero: true
                    },
                    y: { 
                        stacked: true,
                        display: false  // Labels are external
                    }
                }
            }
        });
    });
    
    // Build table with pagination
    const { splitBySample: tblSplitSample, splitBySource: tblSplitSource, splitByCluster: tblSplitCluster } = getSplitConfig();
    let tableHeaders = '<th>Feature</th>';
    if (tblSplitSample) tableHeaders += '<th>Sample Phase</th>';
    if (tblSplitSource) tableHeaders += '<th>Recruitment</th>';
    if (tblSplitCluster) tableHeaders += '<th>Cluster</th>';
    tableHeaders += '<th>Most Important</th><th>%</th><th>Important Only</th><th>%</th><th>Total</th><th>%</th>';
    
    const allRows = [];
    sortedLabels.forEach(label => {
        splitDatasets.forEach(ds => {
            const importantData = ds.data.d?.['multiselect_moral_considerations_important'] || {};
            const mostData = ds.data.d?.['multiselect_moral_considerations_combined_most'] || 
                            ds.data.d?.['multiselect_moral_considerations_most'] || {};
            const respondentN = ds.data.rc?.['multiselect_moral_considerations_important'] || ds.data.n || 1;
            const isFollowUp = ds.label?.toLowerCase().includes('follow');
            
            const impVal = typeof importantData[label] === 'number' ? importantData[label] : 0;
            const mostVal = isFollowUp ? 0 : (typeof mostData[label] === 'number' ? mostData[label] : 0);
            const impOnly = impVal - mostVal;
            
            const mostPct = respondentN > 0 ? ((mostVal / respondentN) * 100).toFixed(1) + '%' : '—';
            const impOnlyPct = respondentN > 0 ? ((impOnly / respondentN) * 100).toFixed(1) + '%' : '—';
            const totalPct = respondentN > 0 ? ((impVal / respondentN) * 100).toFixed(1) + '%' : '—';
            
            let rowHtml = `<tr><td>${label}</td>`;
            if (tblSplitSample) rowHtml += `<td>${ds.sampleKey ? capitalizePhase(ds.sampleKey) : '-'}</td>`;
            if (tblSplitSource) rowHtml += `<td>${ds.sourceKey || '-'}</td>`;
            if (tblSplitCluster) rowHtml += `<td>${ds.clusterKey ? capitalizeLabel(ds.clusterKey) : '-'}</td>`;
            rowHtml += `<td>${mostVal}</td><td>${mostPct}</td><td>${impOnly}</td><td>${impOnlyPct}</td><td>${impVal}</td><td>${totalPct}</td></tr>`;
            allRows.push(rowHtml);
        });
    });
    
    // Apply pagination
    const MAX_ROWS = TABLE_MAX_ROWS;
    const totalRows = allRows.length;
    let tableHtml = `<table><thead><tr>${tableHeaders}</tr></thead><tbody>`;
    if (totalRows > MAX_ROWS) {
        tableHtml += allRows.slice(0, MAX_ROWS).join('');
        tableHtml += '</tbody></table>';
        tableHtml += `<div class="table-pagination" style="margin-top:0.5rem;display:flex;align-items:center;gap:0.75rem;">`;
        tableHtml += `<span style="color:var(--text-muted);font-size:0.9rem;" id="table-row-count">Showing ${MAX_ROWS} of ${totalRows} rows</span>`;
        tableHtml += `<span style="color:#8b949e;font-size:0.9rem;font-weight:600;cursor:pointer;text-decoration:underline;" onclick="toggleTableRows(this, ${totalRows}, 'show-all')" data-action="show-all" data-all-rows='${JSON.stringify(allRows).replace(/'/g, "&#39;")}'>Show all</span>`;
        tableHtml += `<span style="color:#6e7681;">|</span>`;
        tableHtml += `<span style="color:#8b949e;font-size:0.9rem;font-weight:600;cursor:pointer;text-decoration:underline;" onclick="toggleTableRows(this.previousElementSibling.previousElementSibling, ${totalRows}, 'hide-all')">Hide all</span>`;
        tableHtml += `</div>`;
    } else {
        tableHtml += allRows.join('');
        tableHtml += '</tbody></table>';
    }
    tableArea.innerHTML = tableHtml;
}

function showHorizontalBarChart(data, qName, respondentN = null, exclusiveData = null) {
    const chartArea = document.getElementById('dist-chart-area');
    const legendArea = document.getElementById('dist-legend-area');
    
    // Sort by count (descending)
    const sortedEntries = Object.entries(data)
        .filter(([k, v]) => typeof v === 'number')
        .sort((a, b) => b[1] - a[1]);
    
    // Transform labels using EXP_SOURCE_LABEL_MAP (for AI experience source "Practical" prefix)
    const allLabels = sortedEntries.map(([k]) => transformExpSourceLabel(k));
    const allOriginalLabels = sortedEntries.map(([k]) => k);  // Keep originals for data lookup
    const allValues = sortedEntries.map(([, v]) => v);
    const totalSelections = allValues.reduce((a, b) => a + b, 0);
    // Use respondentN for percentage if provided (for multiselect), otherwise use totalSelections
    const percentBase = respondentN || totalSelections;
    
    // Show all/show less logic for chart - only for Country and Employment (more than 10 items typically)
    const MAX_CHART_ITEMS = 10;
    const totalItems = sortedEntries.length;
    const hasMoreItems = totalItems > MAX_CHART_ITEMS;
    
    // Store data globally for toggle
    window._hbarChartData = {
        allLabels, allOriginalLabels, allValues, percentBase, qName, exclusiveData, totalItems
    };
    
    // Function to render chart with given number of items
    const renderHBarChart = (showAll) => {
        const numItems = showAll ? totalItems : Math.min(MAX_CHART_ITEMS, totalItems);
        const labels = allLabels.slice(0, numItems);
        const originalLabels = allOriginalLabels.slice(0, numItems);
        const values = allValues.slice(0, numItems);
        
        // Helper to wrap long labels
        const wrapLabel = (label, maxWidth = 35) => {
            if (label.length <= maxWidth) return label;
            const words = label.split(' ');
            const lines = [];
            let currentLine = '';
            for (const word of words) {
                if ((currentLine + ' ' + word).trim().length <= maxWidth) {
                    currentLine = (currentLine + ' ' + word).trim();
                } else {
                    if (currentLine) lines.push(currentLine);
                    currentLine = word;
                }
            }
            if (currentLine) lines.push(currentLine);
            return lines;
        };
        
        const wrappedLabels = labels.map(l => wrapLabel(l));
        
        // Adjust height based on number of items
        const chartHeight = Math.max(300, numItems * 40);
        
        // Build toggle control HTML
        let toggleHtml = '';
        if (hasMoreItems) {
            if (showAll) {
                toggleHtml = `<div style="text-align:left;margin-top:-0.25rem;margin-bottom:0.5rem;">
                    <span style="color:#8b949e;font-size:0.9rem;font-weight:600;cursor:pointer;text-decoration:underline;" onclick="toggleHBarChart(false)">Show less</span>
                </div>`;
            } else {
                toggleHtml = `<div style="text-align:left;margin-top:-0.25rem;margin-bottom:0.5rem;">
                    <span style="color:var(--text-muted);font-size:0.85rem;">Showing top ${MAX_CHART_ITEMS} of ${totalItems}</span>
                    <span style="color:#8b949e;font-size:0.9rem;font-weight:600;cursor:pointer;text-decoration:underline;margin-left:0.75rem;" onclick="toggleHBarChart(true)">Show all</span>
                </div>`;
            }
        }
        
        chartArea.innerHTML = `<div class="chart-container" style="height:${chartHeight}px;"><canvas id="dist-chart"></canvas></div>${toggleHtml}`;
        
        // Check if exclusive data exists and has any non-zero values
        let hasExclusiveData = false;
        if (exclusiveData && Object.keys(exclusiveData).length > 0) {
            const exclusiveSum = Object.values(exclusiveData).reduce((sum, v) => sum + (typeof v === 'number' ? v : 0), 0);
            hasExclusiveData = exclusiveSum > 0 && originalLabels.some(k => (exclusiveData[k] || 0) > 0);
        }
        
        // If exclusive data is provided with non-zero values, create stacked bar chart
        if (hasExclusiveData) {
            const exclusiveValues = originalLabels.map(k => exclusiveData[k] || 0);
            const nonExclusiveValues = values.map((v, i) => v - exclusiveValues[i]);
            
            // Show legend for stacked bars
            legendArea.innerHTML = `
                <div style="display:flex;gap:1.5rem;justify-content:center;margin-bottom:0.5rem;flex-wrap:wrap;">
                    <div style="display:flex;align-items:center;gap:0.4rem;">
                        <div style="width:16px;height:16px;background:#4a9b9e;border-radius:2px;"></div>
                        <span style="font-size:0.85rem;color:#c9d1d9;">Selected this option only</span>
                    </div>
                    <div style="display:flex;align-items:center;gap:0.4rem;">
                        <div style="width:16px;height:16px;background:rgba(74,155,158,0.4);border-radius:2px;"></div>
                        <span style="font-size:0.85rem;color:#c9d1d9;">Selected with other options</span>
                    </div>
                </div>`;
            
            charts.main = new Chart(document.getElementById('dist-chart').getContext('2d'), {
                type: 'bar',
                data: {
                    labels: wrappedLabels,
                    datasets: [
                        {
                            label: 'Only this option',
                            data: exclusiveValues,
                            backgroundColor: '#4a9b9e',
                            borderWidth: 0
                        },
                        {
                            label: 'With other options',
                            data: nonExclusiveValues,
                            backgroundColor: 'rgba(74,155,158,0.4)',
                            borderWidth: 0
                        }
                    ]
                },
                options: {
                    indexAxis: 'y',
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {display: false},
                        tooltip: {
                            callbacks: {
                                title: ctx => stripTooltipParens(labels[ctx[0].dataIndex]),
                                label: ctx => {
                                    const total = values[ctx.dataIndex];
                                    const exclusive = exclusiveValues[ctx.dataIndex];
                                    const pct = ((total/percentBase)*100).toFixed(1);
                                    const exclusivePct = ((exclusive/percentBase)*100).toFixed(1);
                                    if (ctx.datasetIndex === 0) {
                                        return `Only this: ${exclusive} (${exclusivePct}%)`;
                                    } else {
                                        return `With others: ${total - exclusive} (${((total - exclusive)/percentBase*100).toFixed(1)}%)`;
                                    }
                                },
                                afterBody: ctx => {
                                    const total = values[ctx[0].dataIndex];
                                    const pct = ((total/percentBase)*100).toFixed(1);
                                    return `Total: ${total} (${pct}%)`;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            stacked: true,
                            beginAtZero: true,
                            grid: {color: '#30363d'},
                            ticks: {color: '#e6edf3', font: {size: 13}, maxRotation: 0, minRotation: 0},
                            title: {display: true, text: 'Count', color: '#e6edf3', font: {size: 14}}
                        },
                        y: {
                            stacked: true,
                            grid: {display: false},
                            ticks: {color: '#e6edf3', autoSkip: false, font: {size: 13}}
                        }
                    }
                }
            });
        } else {
            // Standard (non-stacked) horizontal bar chart
            legendArea.innerHTML = '';  // No legend needed
            
            charts.main = new Chart(document.getElementById('dist-chart').getContext('2d'), {
                type: 'bar',
                data: {
                    labels: wrappedLabels,
                    datasets: [{
                        data: values,
                        backgroundColor: '#4a9b9e',
                        borderWidth: 0
                    }]
                },
                options: {
                    indexAxis: 'y',  // Horizontal bars
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {display: false},
                        tooltip: {
                            callbacks: {
                                title: ctx => stripTooltipParens(labels[ctx[0].dataIndex]),
                                label: ctx => `${ctx.raw} (${((ctx.raw/percentBase)*100).toFixed(1)}%)`
                            }
                        }
                    },
                    scales: {
                        x: {
                            beginAtZero: true,
                            grid: {color: '#30363d'},
                            ticks: {color: '#e6edf3', font: {size: 13}, maxRotation: 0, minRotation: 0},
                            title: {display: true, text: 'Count', color: '#e6edf3', font: {size: 14}}
                        },
                        y: {
                            grid: {display: false},
                            ticks: {color: '#e6edf3', autoSkip: false, font: {size: 13}}
                        }
                    }
                }
            });
        }
    };
    
    // Initial render with limited items
    renderHBarChart(false);
    
    // Build table with row limit for large datasets (matching standard table styling)
    const MAX_ROWS = 10;
    const totalRows = sortedEntries.length;
    const hasMoreRows = totalRows > MAX_ROWS;
    
    // Build all rows first for toggleTableRows
    const allRows = [];
    sortedEntries.forEach(([k, v]) => {
        const displayLabel = transformExpSourceLabel(k);
        allRows.push(`<tr><td>${displayLabel}</td><td>${v}</td><td>${((v/percentBase)*100).toFixed(1)}%</td></tr>`);
    });
    Object.entries(data).filter(([k, v]) => typeof v === 'string').forEach(([k, v]) => {
        const displayLabel = transformExpSourceLabel(k);
        allRows.push(`<tr><td>${displayLabel}</td><td class="suppressed">${v}</td><td class="suppressed">—</td></tr>`);
    });
    
    let tableHtml = `<table><thead><tr><th>${qName}</th><th>Count</th><th>%</th></tr></thead><tbody>`;
    if (hasMoreRows) {
        tableHtml += allRows.slice(0, MAX_ROWS).join('');
        tableHtml += '</tbody></table>';
        tableHtml += `<div class="table-pagination" style="margin-top:0.5rem;display:flex;align-items:center;gap:0.75rem;">`;
        tableHtml += `<span style="color:var(--text-muted);font-size:0.9rem;" id="table-row-count">Showing ${MAX_ROWS} of ${totalRows} rows</span>`;
        tableHtml += `<span style="color:#8b949e;font-size:0.9rem;font-weight:600;cursor:pointer;text-decoration:underline;" onclick="toggleTableRows(this, ${totalRows}, 'show-all')" data-action="show-all" data-all-rows='${JSON.stringify(allRows).replace(/'/g, "&#39;")}'>Show all</span>`;
        tableHtml += `<span style="color:#6e7681;">|</span>`;
        tableHtml += `<span style="color:#8b949e;font-size:0.9rem;font-weight:600;cursor:pointer;text-decoration:underline;" onclick="toggleTableRows(this.previousElementSibling.previousElementSibling, ${totalRows}, 'hide-all')">Hide all</span>`;
        tableHtml += `</div>`;
    } else {
        tableHtml += allRows.join('');
        tableHtml += '</tbody></table>';
    }
    document.getElementById('dist-table-container').innerHTML = tableHtml;
}

// Toggle function for horizontal bar chart show all/show less
function toggleHBarChart(showAll) {
    const d = window._hbarChartData;
    if (!d) return;
    
    const chartArea = document.getElementById('dist-chart-area');
    const legendArea = document.getElementById('dist-legend-area');
    const MAX_CHART_ITEMS = 10;
    
    const numItems = showAll ? d.totalItems : Math.min(MAX_CHART_ITEMS, d.totalItems);
    const labels = d.allLabels.slice(0, numItems);
    const originalLabels = d.allOriginalLabels.slice(0, numItems);
    const values = d.allValues.slice(0, numItems);
    
    const wrapLabel = (label, maxWidth = 35) => {
        if (label.length <= maxWidth) return label;
        const words = label.split(' ');
        const lines = [];
        let currentLine = '';
        for (const word of words) {
            if ((currentLine + ' ' + word).trim().length <= maxWidth) {
                currentLine = (currentLine + ' ' + word).trim();
            } else {
                if (currentLine) lines.push(currentLine);
                currentLine = word;
            }
        }
        if (currentLine) lines.push(currentLine);
        return lines;
    };
    
    const wrappedLabels = labels.map(l => wrapLabel(l));
    const chartHeight = Math.max(300, numItems * 40);
    
    let toggleHtml = '';
    if (d.totalItems > MAX_CHART_ITEMS) {
        if (showAll) {
            toggleHtml = `<div style="text-align:left;margin-top:-0.25rem;margin-bottom:0.5rem;">
                <span style="color:#8b949e;font-size:0.9rem;font-weight:600;cursor:pointer;text-decoration:underline;" onclick="toggleHBarChart(false)">Show less</span>
            </div>`;
        } else {
            toggleHtml = `<div style="text-align:left;margin-top:-0.25rem;margin-bottom:0.5rem;">
                <span style="color:var(--text-muted);font-size:0.85rem;">Showing top ${MAX_CHART_ITEMS} of ${d.totalItems}</span>
                <span style="color:#8b949e;font-size:0.9rem;font-weight:600;cursor:pointer;text-decoration:underline;margin-left:0.75rem;" onclick="toggleHBarChart(true)">Show all</span>
            </div>`;
        }
    }
    
    chartArea.innerHTML = `<div class="chart-container" style="height:${chartHeight}px;"><canvas id="dist-chart"></canvas></div>${toggleHtml}`;
    
    // Check for exclusive data
    let hasExclusiveData = false;
    if (d.exclusiveData && Object.keys(d.exclusiveData).length > 0) {
        const exclusiveSum = Object.values(d.exclusiveData).reduce((sum, v) => sum + (typeof v === 'number' ? v : 0), 0);
        hasExclusiveData = exclusiveSum > 0 && originalLabels.some(k => (d.exclusiveData[k] || 0) > 0);
    }
    
    if (hasExclusiveData) {
        const exclusiveValues = originalLabels.map(k => d.exclusiveData[k] || 0);
        const nonExclusiveValues = values.map((v, i) => v - exclusiveValues[i]);
        
        charts.main = new Chart(document.getElementById('dist-chart').getContext('2d'), {
            type: 'bar',
            data: {
                labels: wrappedLabels,
                datasets: [
                    {label: 'Only this option', data: exclusiveValues, backgroundColor: '#4a9b9e', borderWidth: 0},
                    {label: 'With other options', data: nonExclusiveValues, backgroundColor: 'rgba(74,155,158,0.4)', borderWidth: 0}
                ]
            },
            options: {
                indexAxis: 'y', responsive: true, maintainAspectRatio: false,
                plugins: {legend: {display: false}, tooltip: {callbacks: {
                    title: ctx => stripTooltipParens(labels[ctx[0].dataIndex]),
                    label: ctx => {
                        const total = values[ctx.dataIndex];
                        const exclusive = exclusiveValues[ctx.dataIndex];
                        if (ctx.datasetIndex === 0) return `Only this: ${exclusive} (${((exclusive/d.percentBase)*100).toFixed(1)}%)`;
                        return `With others: ${total - exclusive} (${((total - exclusive)/d.percentBase*100).toFixed(1)}%)`;
                    },
                    afterBody: ctx => `Total: ${values[ctx[0].dataIndex]} (${((values[ctx[0].dataIndex]/d.percentBase)*100).toFixed(1)}%)`
                }}},
                scales: {
                    x: {stacked: true, beginAtZero: true, grid: {color: '#30363d'}, ticks: {color: '#e6edf3', font: {size: 13}}, title: {display: true, text: 'Count', color: '#e6edf3', font: {size: 14}}},
                    y: {stacked: true, grid: {display: false}, ticks: {color: '#e6edf3', autoSkip: false, font: {size: 13}}}
                }
            }
        });
    } else {
        charts.main = new Chart(document.getElementById('dist-chart').getContext('2d'), {
            type: 'bar',
            data: {labels: wrappedLabels, datasets: [{data: values, backgroundColor: '#4a9b9e', borderWidth: 0}]},
            options: {
                indexAxis: 'y', responsive: true, maintainAspectRatio: false,
                plugins: {legend: {display: false}, tooltip: {callbacks: {
                    title: ctx => stripTooltipParens(labels[ctx[0].dataIndex]),
                    label: ctx => `${ctx.raw} (${((ctx.raw/d.percentBase)*100).toFixed(1)}%)`
                }}},
                scales: {
                    x: {beginAtZero: true, grid: {color: '#30363d'}, ticks: {color: '#e6edf3', font: {size: 13}, maxRotation: 0, minRotation: 0}, title: {display: true, text: 'Count', color: '#e6edf3', font: {size: 14}}},
                    y: {grid: {display: false}, ticks: {color: '#e6edf3', autoSkip: false, font: {size: 13}}}
                }
            }
        });
    }
}

// Toggle function for special chart (Country/Employment in multi-demo view) show all/show less
function toggleSpecialChart(idx, showAll) {
    const d = window._specialChartData?.[idx];
    if (!d) return;
    
    const MAX_ITEMS = 10;
    const section = document.getElementById(`special-section-${idx}`);
    const chartContainer = document.getElementById(`chart-container-s-${idx}`);
    if (!section || !chartContainer) return;
    
    const numItems = showAll ? d.allLabels.length : Math.min(MAX_ITEMS, d.allLabels.length);
    const labels = d.allLabels.slice(0, numItems);
    const values = d.allValues.slice(0, numItems);
    const maxVal = Math.max(...values);
    
    // Update chart height
    const itemHeight = 36;
    const chartHeight = Math.max(numItems * itemHeight + 80, 300);
    chartContainer.style.height = chartHeight + 'px';
    
    // Destroy old chart
    if (charts[`c-s-${idx}`]) {
        charts[`c-s-${idx}`].destroy();
    }
    
    // Create new chart
    charts[`c-s-${idx}`] = new Chart(document.getElementById(`c-s-${idx}`).getContext('2d'), {
        type: 'bar',
        data: {labels, datasets: [{data: values, backgroundColor: '#4a9b9e', borderWidth: 0}]},
        options: {
            indexAxis: 'y',
            responsive: true,
            maintainAspectRatio: false,
            plugins: {legend: {display: false}, tooltip: {callbacks: {label: ctx => `${ctx.raw} (${((ctx.raw/d.total)*100).toFixed(1)}%)`}}},
            scales: {x: {beginAtZero: true, max: Math.ceil(maxVal * 1.1 / 50) * 50, grid: {color: '#30363d'}, ticks: {color: '#e6edf3', font: {size: 15}, stepSize: 50}}, y: {grid: {display: false}, ticks: {color: '#e6edf3', autoSkip: false, font: {size: 15}}}}
        }
    });
    
    // Update toggle text
    const toggleEl = document.getElementById(`toggle-special-${idx}`);
    if (toggleEl) {
        const toggleContainer = toggleEl.parentElement;
        if (showAll) {
            toggleContainer.style.textAlign = 'left';
            toggleContainer.style.marginTop = '-0.25rem';
            toggleContainer.style.marginBottom = '0.5rem';
            toggleContainer.innerHTML = `<span style="color:#8b949e;font-size:0.9rem;font-weight:600;cursor:pointer;text-decoration:underline;" onclick="toggleSpecialChart(${idx}, false)" id="toggle-special-${idx}">Show less</span>`;
        } else {
            toggleContainer.style.textAlign = 'left';
            toggleContainer.style.marginTop = '-0.25rem';
            toggleContainer.style.marginBottom = '0.5rem';
            toggleContainer.innerHTML = `<span style="color:var(--text-muted);font-size:0.85rem;">Showing top ${MAX_ITEMS} of ${d.allLabels.length}</span>
                <span style="color:#8b949e;font-size:0.9rem;font-weight:600;cursor:pointer;text-decoration:underline;margin-left:0.75rem;" onclick="toggleSpecialChart(${idx}, true)" id="toggle-special-${idx}">Show all</span>`;
        }
    }
}

function showExperienceMixed(sel, dists, badge, gridClass, legendArea, respondentCounts = {}) {
    // Categorize selections
    const levels = sel.filter(o => o.k.startsWith('exp_'));
    const sources = sel.filter(o => !o.k.startsWith('exp_'));
    const hasSources = sources.length > 0;
    
    // If mixed (levels + sources), use Experience N for the top badge
    // The badge passed in is based on all selections, but we want Experience N only
    let titleBadge = badge;
    if (hasSources && levels.length > 0) {
        // Get N from first level's data
        const firstLevelData = dists[levels[0].k];
        if (firstLevelData) {
            const expN = Object.values(firstLevelData).reduce((a, b) => typeof b === 'number' ? a + b : a, 0);
            titleBadge = ` <span class="filter-badge">N=${expN}</span>`;
            titleBadge += `<span class="filter-note note-block">${NOTE_EXP_SOURCE}</span>`;
        }
    } else if (hasSources && levels.length === 0) {
        // Sources only - add the note about 3+ rating
        const firstSource = sources[0];
        const sourceData = dists[firstSource.k];
        const sourceN = respondentCounts?.[firstSource.k] || (sourceData ? Object.values(sourceData).filter(v => typeof v === 'number').reduce((a, b) => a + b, 0) : 0);
        titleBadge = ` <span class="filter-badge">N=${sourceN}</span>`;
        titleBadge += `<span class="filter-note note-block">${NOTE_EXP_SOURCE}</span>`;
    }
    
    document.getElementById('dist-title').innerHTML = `Experience: ${sel.length} Questions Selected${titleBadge}`;
    
    // Check if any have data
    const hasAnyData = sel.some(o => {
        const data = dists[o.k];
        return data && Object.keys(data).length > 0;
    });
    
    if (!hasAnyData) {
        legendArea.innerHTML = '';
        document.getElementById('dist-chart-area').innerHTML = '<p class="no-data"><em>Data not available: this sample was not presented with these questions</em></p>';
        document.getElementById('dist-table-container').innerHTML = '';
        return;
    }
    
    // Helper to strip parenthetical content from labels (for compact display)
    const stripParens = (label) => label.replace(/\s*\([^)]*\)\s*$/, '').trim();
    
    // Check if all are experience levels (for unified legend)
    const allLevels = sources.length === 0;
    if (allLevels) {
        legendArea.innerHTML = buildRatingLegend('experience', 'Experience Level');
    } else {
        // Check if any source has exclusive data (for stacked bar legend)
        const hasExclusiveData = sources.some(s => {
            const exclusiveKey = `${s.k}_exclusive`;
            const exclusiveData = dists[exclusiveKey];
            return exclusiveData && Object.keys(exclusiveData).length > 0 && 
                Object.values(exclusiveData).some(v => typeof v === 'number' && v > 0);
        });
        
        if (hasExclusiveData) {
            legendArea.innerHTML = `
                <div style="display:flex;gap:1.5rem;justify-content:center;align-items:center;padding:0.5rem 1rem;background:var(--bg-tertiary);border-radius:6px;margin-bottom:0.5rem;">
                    <span style="font-size:0.85rem;color:var(--text-muted);font-weight:500;">Source stacking:</span>
                    <div style="display:flex;align-items:center;gap:0.4rem;">
                        <div style="width:16px;height:16px;background:#4a9b9e;border-radius:2px;"></div>
                        <span style="font-size:0.85rem;color:#c9d1d9;">Selected this option only</span>
                    </div>
                    <div style="display:flex;align-items:center;gap:0.4rem;">
                        <div style="width:16px;height:16px;background:rgba(74, 155, 158, 0.4);border-radius:2px;"></div>
                        <span style="font-size:0.85rem;color:#c9d1d9;">Selected with other options</span>
                    </div>
                </div>`;
        } else {
            legendArea.innerHTML = '';  // Per-chart legends will be shown
        }
    }
    
    // Determine layout strategy
    // Map experience keys to their corresponding source keys
    const expToSource = {
        'exp_ai_exp': 'expsrc_ai_source',
        'exp_animal_exp': 'expsrc_animal_types',
        'exp_consciousness_exp': 'expsrc_consciousness_source',
        'exp_ethics_exp': 'expsrc_ethics_source'
    };
    
    // Check which layout to use
    let layoutMode = 'simple';  // Default
    
    if (allLevels) {
        // Only levels - use cols-4 for up to 4
        layoutMode = 'levels-only';
    } else if (levels.length > 0 && sources.length > 0) {
        // Both levels and sources - check if paired
        const hasPairedItems = levels.some(l => sources.some(s => expToSource[l.k] === s.k));
        if (hasPairedItems) {
            layoutMode = 'paired';  // Experience with source below
        } else {
            layoutMode = 'mixed';  // Mixed, use simple grid
        }
    }
    
    const chartArea = document.getElementById('dist-chart-area');
    
    if (layoutMode === 'levels-only') {
        // All levels only - max 4 per row
        const gridCols = Math.min(levels.length, 4);
        chartArea.innerHTML = `<div class="chart-grid cols-${gridCols}" id="cgrid" style="gap:1.5rem;"></div>`;
        const grid = document.getElementById('cgrid');
        
        // Create charts for all levels
        levels.forEach((o, i) => {
            const cell = document.createElement('div');
            cell.className = 'chart-cell';
            cell.style.minHeight = '200px';
            cell.id = `c-cell-${i}`;
            grid.appendChild(cell);
            createExperienceChart(o, cell, dists, respondentCounts, stripParens, sel.length, allLevels);
        });
    } else if (layoutMode === 'paired') {
        // Create paired layout: levels on top, sources below
        let html = '<div id="cgrid">';
        
        // Group by experience type
        const pairs = [];
        levels.forEach(l => {
            const srcKey = expToSource[l.k];
            const src = sources.find(s => s.k === srcKey);
            pairs.push({ level: l, source: src || null });
        });
        
        // Add unpaired sources
        sources.forEach(s => {
            if (!pairs.some(p => p.source?.k === s.k)) {
                pairs.push({ level: null, source: s });
            }
        });
        
        // Calculate grid columns (max 4)
        const numPairs = pairs.length;
        const gridCols = Math.min(numPairs, 4);
        
        // Create level row
        html += `<div class="chart-grid cols-${gridCols}" style="gap:1rem;margin-bottom:0.5rem;">`;
        pairs.forEach((p, i) => {
            if (p.level) {
                html += `<div class="chart-cell" id="pair-level-${i}" style="min-height:200px;"></div>`;
            } else {
                html += `<div class="chart-cell empty-cell"></div>`;
            }
        });
        html += '</div>';
        
        // Create source row
        html += `<div class="chart-grid cols-${gridCols}" style="gap:1rem;">`;
        pairs.forEach((p, i) => {
            if (p.source) {
                html += `<div class="chart-cell" id="pair-source-${i}" style="min-height:260px;"></div>`;
            } else {
                html += `<div class="chart-cell empty-cell"></div>`;
            }
        });
        html += '</div>';
        
        html += '</div>';
        chartArea.innerHTML = html;
        
        // Now create charts in the cells
        pairs.forEach((p, i) => {
            if (p.level) {
                const cell = document.getElementById(`pair-level-${i}`);
                createExperienceChart(p.level, cell, dists, respondentCounts, stripParens, sel.length, allLevels);
            }
            if (p.source) {
                const cell = document.getElementById(`pair-source-${i}`);
                createExperienceChart(p.source, cell, dists, respondentCounts, stripParens, sel.length, allLevels);
            }
        });
    } else {
        // Simple or mixed layout - cols-3 for flexibility
        const gridCols = sel.length <= 2 ? 2 : 3;
        chartArea.innerHTML = `<div class="chart-grid cols-${gridCols}" id="cgrid" style="gap:1.5rem;"></div>`;
        const grid = document.getElementById('cgrid');
        
        sel.forEach((o, i) => {
            const cell = document.createElement('div');
            cell.className = 'chart-cell';
            cell.style.minHeight = '240px';
            cell.id = `c-cell-${i}`;
            grid.appendChild(cell);
            createExperienceChart(o, cell, dists, respondentCounts, stripParens, sel.length, allLevels);
        });
    }
    
    document.getElementById('dist-table-container').innerHTML = '<p class="no-data">Select individual questions for detailed tables</p>';
}

// Helper function to create individual experience charts
function createExperienceChart(o, cell, dists, respondentCounts, stripParens, totalSelected, allLevels) {
    const data = dists[o.k];
    if (!data) {
        cell.innerHTML = '<p class="no-data">No data</p>';
        return;
    }
    
    const isLevel = o.k.startsWith('exp_');
    const isAnimalTypes = o.k.includes('animal_types');
    const isSource = !isLevel;
    
    // Strip asterisk from display label (asterisks are in checkboxes only, not plot titles)
    const cleanLabel = o.l.replace(/\s*\*\s*$/, '').trim();
    const displayLabel = totalSelected > 1 ? stripParens(cleanLabel) : cleanLabel;
    const respN = isSource ? (respondentCounts?.[o.k] || null) : null;
    
    // Helper to wrap labels
    const wrapLabel = (label, maxWidth = 18) => {
        if (label.length <= maxWidth) return label;
        const words = label.split(' ');
        const lines = [];
        let currentLine = '';
        for (const word of words) {
            if ((currentLine + ' ' + word).trim().length <= maxWidth) {
                currentLine = (currentLine + ' ' + word).trim();
            } else {
                if (currentLine) lines.push(currentLine);
                currentLine = word;
            }
        }
        if (currentLine) lines.push(currentLine);
        return lines;
    };
    
    const chartId = `c-exp-${Math.random().toString(36).substr(2, 9)}`;
    
    if (isLevel) {
        // Donut chart for levels
        const isNumeric = Object.keys(data).every(k => !isNaN(parseFloat(k)));
        let sortedKeys = Object.keys(data);
        if (isNumeric) {
            sortedKeys = sortedKeys.sort((a, b) => parseFloat(a) - parseFloat(b));
        }
        
        const toIntStr = l => String(parseInt(parseFloat(l)));
        const labels = sortedKeys.map(l => ELab(toIntStr(l)));
        const values = sortedKeys.map(k => typeof data[k] === 'number' ? data[k] : 0);
        
        let cellLegend = '';
        if (!allLevels) {
            cellLegend = `<div class="chart-cell-legend" style="font-size:0.95rem;">${buildChartCellLegend(data, 'experience').replace('<div class="chart-cell-legend">', '').replace('</div>', '')}</div>`;
        }
        
        cell.innerHTML = `<h4 style="font-size:1.15rem;font-family:'DM Sans',sans-serif;">${displayLabel}</h4>${cellLegend}<canvas id="${chartId}"></canvas>`;
        
        const total = values.reduce((a, b) => a + b, 0);
        charts[chartId] = new Chart(document.getElementById(chartId).getContext('2d'), {
            type: 'doughnut',
            data: {labels, datasets: [{data: values, backgroundColor: getColors(sortedKeys, 'experience'), borderWidth: 0}]},
            options: {responsive: true, plugins: {legend: {display: false}, tooltip: {callbacks: {label: ctx => `${ctx.label}: ${ctx.raw} (${((ctx.raw/total)*100).toFixed(1)}%)`}}}}
        });
    } else {
        // Bar chart for sources
        const sortedEntries = Object.entries(data)
            .filter(([k, v]) => typeof v === 'number')
            .sort((a, b) => b[1] - a[1]);
        
        const rawLabels = sortedEntries.map(([k]) => k);
        // For ethics source, ALWAYS strip ALL parenthetical content (even when displayed alone)
        const isEthicsSource = o.k.includes('ethics_source');
        const stripAllParens = (label) => label.replace(/\s*\([^)]*\)/g, '').trim();
        const labels = isEthicsSource ? rawLabels.map(l => stripAllParens(l)) : 
                       (totalSelected > 1 ? rawLabels.map(l => stripParens(l)) : rawLabels);
        const wrappedLabels = labels.map(l => wrapLabel(l));
        const values = sortedEntries.map(([, v]) => v);
        const totalSelections = values.reduce((a, b) => a + b, 0);
        const maxVal = Math.max(...values);
        const percentBase = respN || totalSelections;
        
        // Calculate tight x-axis max (round up to nearest 50)
        const xMax = Math.ceil(maxVal / 50) * 50;  // No extra padding
        const numLabels = labels.length;
        
        if (isAnimalTypes) {
            const colorMap = DATA.metadata.colors?.animal_types || {};
            const defaultColors = ['#58a6ff','#f78166','#7ee787','#d2a8ff','#ffa657','#79c0ff','#ff7b72','#a5d6ff'];
            const colors = labels.map((l, idx) => colorMap[rawLabels[idx]] || defaultColors[idx % defaultColors.length]);
            
            // Match cell height to other source charts for consistent grid alignment
            const labelHeight = 28;
            const minCellHeight = Math.max(260, 6 * labelHeight);  // Same as other sources (at least 6 rows)
            cell.style.minHeight = minCellHeight + 'px';
            
            // Add N to title for animal types (like other sources)
            const animalN = respN || percentBase;
            const nDisplay = animalN ? ` (N=${animalN})` : '';
            cell.innerHTML = `<h4 style="font-size:1.15rem;font-family:'DM Sans',sans-serif;">${displayLabel}${nDisplay}</h4><canvas id="${chartId}"></canvas>`;
            
            const shouldTilt = totalSelected > 1;
            const xTickFontSize = totalSelected > 1 ? 10 : 11;
            
            // Wrap long labels like "Primates (including apes)" to multiple lines
            // Use maxWidth of 18 to keep "Other marine life" (17 chars) on one line
            const wrapXLabel = (label, maxWidth = 18) => {
                if (label.length <= maxWidth) return label;
                // Special handling for parenthetical content
                const parenMatch = label.match(/^(.+?)\s*(\([^)]+\))$/);
                if (parenMatch) {
                    return [parenMatch[1].trim(), parenMatch[2]];
                }
                // General word wrapping
                const words = label.split(' ');
                const lines = [];
                let currentLine = '';
                for (const word of words) {
                    if ((currentLine + ' ' + word).trim().length <= maxWidth) {
                        currentLine = (currentLine + ' ' + word).trim();
                    } else {
                        if (currentLine) lines.push(currentLine);
                        currentLine = word;
                    }
                }
                if (currentLine) lines.push(currentLine);
                return lines.length > 1 ? lines : label;
            };
            
            const xTickLabels = labels.map(l => wrapXLabel(l));
            
            // Check for exclusive data (stacked bars) - Animal Types should always be stacked when data available
            const exclusiveKey = `${o.k}_exclusive`;
            const exclusiveData = dists[exclusiveKey] || {};
            const hasExclusiveData = Object.keys(exclusiveData).length > 0 && 
                Object.values(exclusiveData).some(v => typeof v === 'number' && v > 0);
            
            if (hasExclusiveData) {
                // Stacked vertical bar chart for Animal Types
                const exclusiveValues = rawLabels.map(k => exclusiveData[k] || 0);
                const nonExclusiveValues = values.map((v, i) => Math.max(0, v - exclusiveValues[i]));
                
                charts[chartId] = new Chart(document.getElementById(chartId).getContext('2d'), {
                    type: 'bar',
                    data: {
                        labels: xTickLabels, 
                        datasets: [
                            {label: 'Only this', data: exclusiveValues, backgroundColor: colors.map(c => c), borderWidth: 0},
                            {label: 'With others', data: nonExclusiveValues, backgroundColor: colors.map(c => c + '66'), borderWidth: 0}
                        ]
                    },
                    options: {
                        responsive: true, 
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {display: false}, 
                            tooltip: {
                                callbacks: {
                                    title: ctx => stripTooltipParens(rawLabels[ctx[0].dataIndex]), 
                                    label: ctx => {
                                        const total = values[ctx.dataIndex];
                                        const exclusive = exclusiveValues[ctx.dataIndex];
                                        const pct = percentBase > 0 ? ((ctx.raw / percentBase) * 100).toFixed(1) : '0.0';
                                        if (ctx.datasetIndex === 0) {
                                            return `Only this: ${exclusive} (${pct}%)`;
                                        } else {
                                            return `With others: ${total - exclusive} (${pct}%)`;
                                        }
                                    },
                                    afterBody: ctx => {
                                        const total = values[ctx[0].dataIndex];
                                        const pct = percentBase > 0 ? ((total / percentBase) * 100).toFixed(1) : '0.0';
                                        return `Total: ${total} (${pct}%)`;
                                    }
                                }
                            }
                        }, 
                        scales: {
                            x: {stacked: true, grid: {display: false}, ticks: {color: '#e6edf3', maxRotation: shouldTilt ? 45 : 0, minRotation: shouldTilt ? 30 : 0, autoSkip: false, font: {size: xTickFontSize}}}, 
                            y: {stacked: true, beginAtZero: true, max: xMax, grid: {color: '#30363d'}, ticks: {color: '#e6edf3', font: {size: 12}, stepSize: Math.ceil(xMax / 4)}}
                        }
                    }
                });
            } else {
                // Standard vertical bar chart (fallback)
                charts[chartId] = new Chart(document.getElementById(chartId).getContext('2d'), {
                    type: 'bar',
                    data: {labels: xTickLabels, datasets: [{data: values, backgroundColor: colors, borderWidth: 0}]},
                    options: {
                        responsive: true, 
                        maintainAspectRatio: false,
                        plugins: {legend: {display: false}, tooltip: {callbacks: {title: ctx => stripTooltipParens(rawLabels[ctx[0].dataIndex]), label: ctx => `${ctx.raw} (${((ctx.raw/percentBase)*100).toFixed(1)}%)`}}}, 
                        scales: {
                            x: {grid: {display: false}, ticks: {color: '#e6edf3', maxRotation: shouldTilt ? 45 : 0, minRotation: shouldTilt ? 30 : 0, autoSkip: false, font: {size: xTickFontSize}}}, 
                            y: {beginAtZero: true, max: xMax, grid: {color: '#30363d'}, ticks: {color: '#e6edf3', font: {size: 12}, stepSize: Math.ceil(xMax / 4)}}
                        }
                    }
                });
            }
        } else {
            // For horizontal bar charts (sources), ensure proper height based on labels
            const isEthicsSource = o.k.includes('ethics_source');
            const baseFontSize = isEthicsSource ? 11 : 13;
            const sourceFontSize = numLabels > 8 ? 10 : (totalSelected > 1 ? Math.min(baseFontSize, 12) : baseFontSize);
            
            // Set cell height based on number of labels - always do this for horizontal bars
            const labelHeight = isEthicsSource ? 32 : 28;  // Ethics needs more space per label
            const minCellHeight = Math.max(260, numLabels * labelHeight);
            cell.style.minHeight = minCellHeight + 'px';
            
            // Check for exclusive data (stacked bars)
            const exclusiveKey = `${o.k}_exclusive`;
            const exclusiveData = dists[exclusiveKey] || {};
            const hasExclusiveData = Object.keys(exclusiveData).length > 0 && 
                Object.values(exclusiveData).some(v => typeof v === 'number' && v > 0);
            
            // Add N to title for sources
            const nDisplay = respN ? ` (N=${respN})` : '';
            cell.innerHTML = `<h4 style="font-size:1.15rem;font-family:'DM Sans',sans-serif;">${displayLabel}${nDisplay}</h4><canvas id="${chartId}"></canvas>`;
            
            if (hasExclusiveData) {
                // Stacked horizontal bar chart
                const exclusiveValues = rawLabels.map(k => exclusiveData[k] || 0);
                const nonExclusiveValues = values.map((v, i) => Math.max(0, v - exclusiveValues[i]));
                
                charts[chartId] = new Chart(document.getElementById(chartId).getContext('2d'), {
                    type: 'bar',
                    data: {
                        labels: wrappedLabels, 
                        datasets: [
                            {label: 'Only this', data: exclusiveValues, backgroundColor: '#4a9b9e', borderWidth: 0},
                            {label: 'With others', data: nonExclusiveValues, backgroundColor: 'rgba(74, 155, 158, 0.4)', borderWidth: 0}
                        ]
                    },
                    options: {
                        indexAxis: 'y', 
                        responsive: true, 
                        maintainAspectRatio: false, 
                        plugins: {
                            legend: {display: false}, 
                            tooltip: {
                                callbacks: {
                                    title: ctx => stripTooltipParens(rawLabels[ctx[0].dataIndex]), 
                                    label: ctx => {
                                        const total = values[ctx.dataIndex];
                                        const exclusive = exclusiveValues[ctx.dataIndex];
                                        const pct = percentBase > 0 ? ((ctx.raw / percentBase) * 100).toFixed(1) : '0.0';
                                        if (ctx.datasetIndex === 0) {
                                            return `Only this: ${exclusive} (${pct}%)`;
                                        } else {
                                            return `With others: ${total - exclusive} (${pct}%)`;
                                        }
                                    },
                                    afterBody: ctx => {
                                        const total = values[ctx[0].dataIndex];
                                        const pct = percentBase > 0 ? ((total / percentBase) * 100).toFixed(1) : '0.0';
                                        return `Total: ${total} (${pct}%)`;
                                    }
                                }
                            }
                        }, 
                        scales: {
                            x: {stacked: true, beginAtZero: true, max: xMax, grid: {color: '#30363d'}, ticks: {color: '#e6edf3', font: {size: 12}, stepSize: 50, maxRotation: 0, minRotation: 0}}, 
                            y: {stacked: true, grid: {display: false}, ticks: {color: '#e6edf3', autoSkip: false, font: {size: sourceFontSize}}}
                        }
                    }
                });
            } else {
                // Standard horizontal bar chart
                charts[chartId] = new Chart(document.getElementById(chartId).getContext('2d'), {
                    type: 'bar',
                    data: {labels: wrappedLabels, datasets: [{data: values, backgroundColor: '#4a9b9e', borderWidth: 0}]},
                    options: {indexAxis: 'y', responsive: true, maintainAspectRatio: false, plugins: {legend: {display: false}, tooltip: {callbacks: {title: ctx => stripTooltipParens(rawLabels[ctx[0].dataIndex]), label: ctx => `${ctx.raw} (${((ctx.raw/percentBase)*100).toFixed(1)}%)`}}}, scales: {x: {beginAtZero: true, max: xMax, grid: {color: '#30363d'}, ticks: {color: '#e6edf3', font: {size: 12}, stepSize: 50, maxRotation: 0, minRotation: 0}}, y: {grid: {display: false}, ticks: {color: '#e6edf3', autoSkip: false, font: {size: sourceFontSize}}}}}
                });
            }
        }
    }
}

function showCross() {
    destroyCharts();
    const v1 = document.getElementById('cross-var1').value, v2 = document.getElementById('cross-var2').value;
    document.getElementById('cross-chart-container').style.display = 'none';
    document.getElementById('cross-table-container').innerHTML = '';
    if (!v1 || !v2) { document.getElementById('cross-title').textContent = 'Please select both variables'; return; }
    if (v1 === v2) { document.getElementById('cross-title').textContent = 'Please select two different variables'; return; }
    const o1 = document.getElementById('cross-var1').selectedOptions[0], o2 = document.getElementById('cross-var2').selectedOptions[0];
    document.getElementById('cross-title').textContent = `${o1.dataset.f || o1.textContent} × ${o2.dataset.f || o2.textContent}`;
    let key = `${v1}__${v2}`, data = DATA.crosstabs[key], sw = false;
    if (!data) { key = `${v2}__${v1}`; data = DATA.crosstabs[key]; sw = true; }
    if (!data) { document.getElementById('cross-table-container').innerHTML = '<p class="no-data">Data not available (may be restricted for privacy or not pre-computed)</p>'; return; }
    const rk = Object.keys(data), ck = [...new Set(rk.flatMap(r => Object.keys(data[r])))];
    const isRS = rk.every(k => ['1','2','3','4','5'].includes(k)) || rk.every(k => ['1','2','3','4'].includes(k));
    const isCS = ck.every(k => ['1','2','3','4','5'].includes(k)) || ck.every(k => ['1','2','3','4'].includes(k));
    if (isRS || isCS) { document.getElementById('cross-chart-container').style.display = 'block'; createCrossChart(data, rk, ck, isRS, isCS, sw); }
    const isRR = rk.every(k => ['1','2','3','4'].includes(k)), isCR = ck.every(k => ['1','2','3','4'].includes(k));
    let h = '<table class="crosstab-table"><thead><tr><th></th>';
    ck.forEach(c => h += `<th>${isCR ? RLab(c) : c}</th>`);
    h += '<th>Total</th></tr></thead><tbody>';
    rk.forEach(r => { h += `<tr><td><strong>${isRR ? RLab(r) : r}</strong></td>`; let rt = 0; ck.forEach(c => { const v = data[r][c], sup = typeof v === 'string'; if (!sup) rt += v; h += `<td class="${sup?'suppressed':''}">${v??0}</td>`; }); h += `<td><strong>${rt}</strong></td></tr>`; });
    document.getElementById('cross-table-container').innerHTML = h + '</tbody></table>';
}

function createCrossChart(data, rk, ck, isRS, isCS, sw) {
    const ctx = document.getElementById('cross-chart').getContext('2d');
    if (isRS && isCS) {
        const pts = []; Object.entries(data).forEach(([r, cols]) => Object.entries(cols).forEach(([c, cnt]) => { if (typeof cnt === 'number' && cnt > 0) for (let i = 0; i < Math.min(cnt, 150); i++) pts.push({x: parseInt(sw?c:r)+(Math.random()-0.5)*0.5, y: parseInt(sw?r:c)+(Math.random()-0.5)*0.5}); }));
        charts.cross = new Chart(ctx, {type: 'scatter', data: {datasets: [{data: pts, backgroundColor: 'rgba(88,166,255,0.4)', pointRadius: 3}]}, options: {responsive: true, maintainAspectRatio: false, plugins: {legend: {display: false}}, scales: {x: {min: 0.5, max: Math.max(...rk.map(k=>parseInt(k)))+0.5, ticks: {stepSize: 1, color: '#8b949e'}, grid: {color: '#30363d'}}, y: {min: 0.5, max: Math.max(...ck.map(k=>parseInt(k)))+0.5, ticks: {stepSize: 1, color: '#8b949e'}, grid: {color: '#30363d'}}}}});
    } else if (isCS) {
        const sorted = [...ck].sort((a,b)=>parseInt(a)-parseInt(b));
        const ds = sorted.map((c,i) => ({label: RLab(c), data: rk.map(r => typeof data[r][c]==='number' ? data[r][c] : 0), backgroundColor: getColors(sorted)[i]}));
        charts.cross = new Chart(ctx, {type: 'bar', data: {labels: rk, datasets: ds}, options: {responsive: true, maintainAspectRatio: false, plugins: {legend: {position: 'top', labels: {color: '#e6edf3'}}}, scales: {x: {stacked: true, ticks: {color: '#8b949e'}, grid: {color: '#30363d'}}, y: {stacked: true, ticks: {color: '#8b949e'}, grid: {color: '#30363d'}}}}});
    } else if (isRS) {
        const sorted = [...rk].sort((a,b)=>parseInt(a)-parseInt(b));
        const ds = sorted.map((r,i) => ({label: RLab(r), data: ck.map(c => typeof data[r][c]==='number' ? data[r][c] : 0), backgroundColor: getColors(sorted)[i]}));
        charts.cross = new Chart(ctx, {type: 'bar', data: {labels: ck, datasets: ds}, options: {responsive: true, maintainAspectRatio: false, plugins: {legend: {position: 'top', labels: {color: '#e6edf3'}}}, scales: {x: {ticks: {color: '#8b949e'}, grid: {color: '#30363d'}}, y: {ticks: {color: '#8b949e'}, grid: {color: '#30363d'}}}}});
    }
}

let curFT = [];
function showFreetext() {
    const k = document.getElementById('freetext-question').value;
    if (!k) { document.getElementById('freetext-title').textContent = 'Select a question'; document.getElementById('freetext-list').innerHTML = ''; return; }
    const d = DATA.freetext[k];
    if (!d) { document.getElementById('freetext-title').textContent = 'No responses'; document.getElementById('freetext-list').innerHTML = '<p class="no-data">No responses</p>'; return; }
    const opt = document.getElementById('freetext-question').selectedOptions[0];
    curFT = [...d.responses].sort(() => Math.random() - 0.5);
    document.getElementById('freetext-title').innerHTML = `${opt.dataset.f || opt.textContent} <span class="response-count">${d.response_count}</span>`;
    renderFT(curFT);
}
function renderFT(r) { const c = document.getElementById('freetext-list'); if (!r.length) { c.innerHTML = '<p class="no-data">No matching</p>'; return; } c.innerHTML = r.slice(0,200).map(x => `<div class="free-text-item">${escHTML(x)}</div>`).join('') + (r.length > 200 ? `<p class="no-data">Showing 200 of ${r.length}</p>` : ''); }
function filterFreetext() { const s = document.getElementById('freetext-search').value.toLowerCase(); renderFT(s ? curFT.filter(r => r.toLowerCase().includes(s)) : curFT); }
function escHTML(s) { const d = document.createElement('div'); d.textContent = s; return d.innerHTML; }

// Display free text responses in the distributions panel
function showDistFreeText(filterKey) {
    const ftArea = document.getElementById('dist-freetext-area');
    const ftContainer = document.getElementById('free-text-container');
    
    // Get selected free text questions from the free-text-container (not variable-container)
    const ftChecks = ftContainer ? Array.from(ftContainer.querySelectorAll('input[data-ft-key]:checked')) : [];
    
    console.log('[showDistFreeText] filterKey:', filterKey, 'ftChecks:', ftChecks.length);
    
    if (ftChecks.length === 0) {
        ftArea.style.display = 'none';
        ftArea.innerHTML = '';
        return;
    }
    
    // Check if we're in split mode
    const { splitBySample, splitBySource, splitByCluster } = getSplitConfig();
    const isSplitMode = splitBySample || splitBySource || splitByCluster;
    
    // Get filter state to check for follow-up exclusion
    const box = document.getElementById('sample-filter-box');
    const isAllSelected = document.getElementById('f-none')?.checked;
    const followUpCheckbox = box?.querySelector('input[data-v="follow-up"]');
    const isFollowUpChecked = followUpCheckbox?.checked || false;
    const sampleCheckboxes = box?.querySelectorAll('input[data-t="sample"]:checked') || [];
    const isFollowUpOnly = isFollowUpChecked && sampleCheckboxes.length === 1 && 
        Array.from(sampleCheckboxes).every(cb => cb.dataset.v === 'follow-up');
    const includesFollowUp = isAllSelected || isFollowUpChecked;
    
    // Free text keys that are NOT in follow-up
    const ftKeysNotInFollowup = [
        'goals_without_consciousness_example', 'consciousness_without_goals_example',
        'sensations_without_consciousness_example', 'consciousness_without_sensations_example',
        'consciousness_intelligence_common', 'higher_moral_status_people',
        'higher_moral_status_animals', 'no_kill_other'
    ];
    
    let html = '<div class="free-text-results" style="border-top:1px solid var(--border);padding-top:1.5rem;margin-top:1rem;">';
    html += '<h4 style="margin-bottom:1rem;color:var(--text-primary);font-size:1.1rem;">Free Text Responses</h4>';
    
    if (isSplitMode) {
        // Split mode: show responses grouped by sample/source
        const filterInfo = getFilterSelections();
        const samples = filterInfo.samples;
        const sources = filterInfo.sources;
        const isAllSelected = filterInfo.isAll;
        const notInFollowup = DATA.metadata.not_in_followup || [];
        
        // Get all available sources if none selected
        const effectiveSources = sources.length > 0 ? sources : (DATA.metadata.source_values || ['Prolific', 'Free']);
        
        console.log('[FreeText Split] isAllSelected:', isAllSelected, 'samples:', samples, 'sources:', sources, 'effectiveSources:', effectiveSources);
        console.log('[FreeText Split] splitBySample:', splitBySample, 'splitBySource:', splitBySource);
        
        ftChecks.forEach((cb, ftIdx) => {
            const key = cb.dataset.ftKey;
            const label = cb.dataset.ftLabel;
            const questionNotInFollowup = ftKeysNotInFollowup.includes(key);
            const sectionId = `ft-split-section-${ftIdx}`;
            
            // Build split groups
            let groups = [];
            let useFallback = false;  // Flag if combined keys don't exist
            
            if (splitBySample && splitBySource) {
                samples.forEach(smp => {
                    effectiveSources.forEach(src => {
                        const isFollowUp = smp.toLowerCase().includes('follow');
                        const isFree = src.toLowerCase() === 'free';
                        if (isFollowUp && isFree) return;
                        const groupKey = `sample_${smp}__source_${src}`;
                        groups.push({ label: `${capitalizePhase(smp)} / ${src}`, key: groupKey });
                    });
                });
                // Check if combined keys exist
                const anyKeyExists = groups.some(grp => DATA.freetext?.[grp.key]?.[key]);
                if (!anyKeyExists) {
                    // Fall back to sample-only keys for display
                    console.log('[FreeText Split] Combined keys not available, falling back to sample-only');
                    useFallback = true;
                    groups = [];
                    samples.forEach(smp => {
                        if (questionNotInFollowup && smp.toLowerCase().includes('follow')) return;
                        groups.push({ label: capitalizePhase(smp), key: `sample_${smp}`, fallbackLabel: true });
                    });
                }
            } else if (splitBySample) {
                samples.forEach(smp => {
                    if (questionNotInFollowup && smp.toLowerCase().includes('follow')) return;
                    groups.push({ label: capitalizePhase(smp), key: `sample_${smp}` });
                });
            } else if (splitBySource) {
                // When splitting by source only (not by sample), ALWAYS use global source keys
                // The sample filter affects which data is shown, but split dimension is source
                console.log('[FreeText Split] splitBySource branch: isAllSelected=', isAllSelected, 'samples.length=', samples.length);
                
                // Always use global source keys when splitting by source only
                effectiveSources.forEach(src => {
                    groups.push({ label: src, key: `source_${src}` });
                });
            } else if (splitByCluster) {
                // Split by cluster only
                const clusters = DATA.metadata.cluster_values || [];
                clusters.forEach(cluster => {
                    groups.push({ label: capitalizeLabel(cluster), key: `cluster_${cluster}` });
                });
            }
            
            // Calculate N values for each group using freetext response_count
            console.log('[FreeText Split] About to calculate Ns. Groups:', groups.map(g => ({label: g.label, key: g.key})));
            const groupNs = groups.map(grp => {
                const filterKey = grp.key;
                const questionKey = key;
                console.log('[FreeText Split] Looking up freetext[' + filterKey + '][' + questionKey + ']');
                const grpData = DATA.freetext?.[filterKey]?.[questionKey];
                console.log('[FreeText Split] Result:', grpData ? {response_count: grpData.response_count, responses_length: grpData.responses?.length} : 'NOT FOUND');
                if (grpData && typeof grpData.response_count === 'number') {
                    return grpData.response_count;
                }
                return 0;
            });
            
            // Track which groups have available responses
            const groupHasResponses = groups.map(grp => {
                const grpData = DATA.freetext?.[grp.key]?.[key];
                return grpData && grpData.responses && grpData.responses.length > 0;
            });
            
            const totalN = groupNs.reduce((sum, n) => sum + n, 0);
            
            console.log('[FreeText Split] Question:', key, 'Groups:', groups.map(g => g.key), 'Ns:', groupNs, 'HasResponses:', groupHasResponses, 'Total:', totalN);
            
            // Build N display with clickable filters
            const listId = `ft-split-list-${ftIdx}`;
            
            let splitNHtml = groups.map((grp, i) => {
                const displayN = groupNs[i];
                return `<span class="ft-split-filter" data-list-id="${listId}" data-filter-label="${grp.label}" style="cursor:pointer;padding:0.2rem 0.4rem;border-radius:4px;transition:background 0.2s;" onmouseover="this.style.background='rgba(88,166,255,0.2)'" onmouseout="if(!this.classList.contains('active')){this.style.background='transparent'}">${grp.label}: N=${displayN}</span>`;
            }).join(' <span style="color:#6e7681;">|</span> ');
            
            html += `<div class="ft-question-section" id="${sectionId}" style="margin-bottom:1.5rem;">`;
            html += `<h5 style="margin-bottom:0.5rem;color:#e6edf3;font-size:1.05rem;">${escHTML(label)} <span class="filter-badge" style="font-weight:normal;font-size:0.9rem;">Total N=${totalN}</span></h5>`;
            
            html += `<div style="margin-bottom:0.4rem;color:#8b949e;font-size:0.85rem;font-style:italic;">Click a split below to filter responses (click again to show all):</div>`;
            html += `<div style="margin-bottom:0.5rem;font-size:0.9rem;">${splitNHtml}</div>`;
            
            if (questionNotInFollowup && includesFollowUp && !isFollowUpOnly) {
                html += `<div class="filter-note align-left" style="margin-bottom:0.5rem;">NOTE: Data excludes Follow-up sample (not asked this question)</div>`;
            }
            
            // Add note for Most Important feature "Other" free text
            const isMostImportantOther = key.includes('most_important') && key.includes('other') ||
                                        label.toLowerCase().includes('most important') && label.toLowerCase().includes('other');
            if (isMostImportantOther) {
                html += `<div class="filter-note align-left" style="margin-bottom:0.5rem;">NOTE: Only asked if multiple features were marked as "Important for Moral Considerations"</div>`;
            }
            
            // Add note for experience source free text (only includes respondents who rated 3+)
            // Check both the key and label for experience-related questions
            const isExpSource = key.includes('expsrc') || 
                               key.includes('experience_source') || 
                               key.includes('ai_exp_other') || 
                               key.includes('consciousness_exp_other') || 
                               key.includes('ethics_exp_other') || 
                               key.includes('animals_other') ||
                               label.toLowerCase().includes('experience source') ||
                               label.toLowerCase().includes('animal types');
            if (isExpSource) {
                html += `<div class="filter-note align-left" style="margin-bottom:0.5rem;">NOTE: Experience source only includes respondents who rated 3+ on this experience</div>`;
            }
            
            html += `<div class="filter-note align-left" style="margin-bottom:0.5rem;background:rgba(88,166,255,0.15);color:#58a6ff;font-size:0.9rem;">Responses are shown verbatim and in random order</div>`;
            
            // Collect all responses with labels
            const allResponses = [];
            groups.forEach(grp => {
                const grpData = DATA.freetext?.[grp.key]?.[key];
                if (grpData && grpData.responses && grpData.responses.length > 0) {
                    grpData.responses.forEach(r => {
                        allResponses.push({ text: r, label: grp.label });
                    });
                }
            });
            
            // Shuffle all responses
            const shuffled = [...allResponses].sort(() => Math.random() - 0.5);
            
            // Scrollable container for responses
            html += `<div class="free-text-list" id="${listId}" style="max-height:500px;overflow-y:auto;background:var(--bg-secondary);border-radius:6px;padding:0.5rem;" data-all-responses='${JSON.stringify(shuffled).replace(/'/g, "&#39;")}' data-showing="100">`;
            
            shuffled.slice(0, 100).forEach(item => {
                html += `<div class="free-text-item" style="padding:0.5rem 0.75rem;border-bottom:1px solid var(--border);font-size:0.95rem;color:#c9d1d9;display:flex;justify-content:space-between;gap:1rem;">`;
                html += `<span style="flex:1;">${escHTML(item.text)}</span>`;
                html += `<span style="font-size:0.75rem;color:var(--text-muted);white-space:nowrap;padding-left:0.5rem;border-left:1px solid var(--border);display:flex;align-items:center;">${item.label}</span>`;
                html += `</div>`;
            });
            
            html += `</div>`;
            
            // Show all / Show less toggle
            if (shuffled.length > 100) {
                html += `<div style="margin-top:0.6rem;display:flex;align-items:center;gap:0.75rem;flex-wrap:wrap;">`;
                html += `<span style="color:var(--text-muted);font-size:0.9rem;" id="${listId}-count">Showing 100 of ${shuffled.length} responses</span>`;
                html += `<span style="color:#8b949e;font-size:0.9rem;font-weight:600;cursor:pointer;text-decoration:underline;" onclick="toggleShowAllSplit('${listId}', ${shuffled.length})" id="${listId}-toggle">Show all</span>`;
                html += `</div>`;
            } else {
                html += `<div style="margin-top:0.5rem;color:var(--text-muted);font-size:0.85rem;">Total: ${shuffled.length} responses</div>`;
            }
            
            html += `<div style="margin-top:0.5rem;font-size:0.8rem;color:#6e7681;font-style:italic;">Content reflects respondents' own views and might include language some find offensive.</div>`;
            
            html += `</div>`;
        });
    } else {
        // Non-split mode: original behavior
        let ftData = {};
        
        if (filterKey && filterKey.includes('+')) {
            const keys = filterKey.split('+');
            console.log('[showDistFreeText] Merging freetext from keys:', keys);
            
            ftChecks.forEach(cb => {
                const ftKey = cb.dataset.ftKey;
                let mergedResponses = [];
                let mergedCount = 0;
                
                keys.forEach(k => {
                    const keyData = DATA.freetext?.[k]?.[ftKey];
                    if (keyData && keyData.responses) {
                        mergedResponses = mergedResponses.concat(keyData.responses);
                        mergedCount += keyData.response_count;
                    }
                });
                
                if (mergedResponses.length > 0) {
                    ftData[ftKey] = {
                        responses: mergedResponses,
                        response_count: mergedCount
                    };
                }
            });
        } else {
            ftData = DATA.freetext?.[filterKey] || DATA.freetext?.['all'] || {};
        }
        
        console.log('[showDistFreeText] ftData keys:', Object.keys(ftData));
        
        const notInFollowup = DATA.metadata.not_in_followup || [];
        
        ftChecks.forEach((cb, idx) => {
            const key = cb.dataset.ftKey;
            const label = cb.dataset.ftLabel;
            const data = ftData[key];
            const sectionId = `ft-section-${idx}`;
            const listId = `ft-list-${idx}`;
            const questionNotInFollowup = ftKeysNotInFollowup.includes(key);
            
            console.log('[showDistFreeText] Looking for key:', key, 'found:', !!data, 'notInFollowup:', questionNotInFollowup);
            
            if (data && data.responses && data.responses.length > 0) {
                const shuffled = [...data.responses].sort(() => Math.random() - 0.5);
                const totalCount = shuffled.length;
                
                html += `<div class="ft-question-section" id="${sectionId}" style="margin-bottom:1.5rem;" data-all-responses='${JSON.stringify(shuffled).replace(/'/g, "&#39;")}' data-showing="100">`;
                html += `<h5 style="margin-bottom:0.75rem;color:#e6edf3;font-size:1.05rem;">${escHTML(label)} <span class="filter-badge" style="font-weight:normal;font-size:0.9rem;">N=${data.response_count}</span></h5>`;
                
                if (questionNotInFollowup && includesFollowUp && !isFollowUpOnly) {
                    html += `<div class="filter-note align-left" style="margin-bottom:0.5rem;">NOTE: Data excludes Follow-up sample (not asked this question)</div>`;
                }
                
                // Add note for Most Important feature "Other" free text
                const isMostImportantOther = key.includes('most_important') && key.includes('other') ||
                                            label.toLowerCase().includes('most important') && label.toLowerCase().includes('other');
                if (isMostImportantOther) {
                    html += `<div class="filter-note align-left" style="margin-bottom:0.5rem;">NOTE: Only asked if multiple features were marked as "Important for Moral Considerations"</div>`;
                }
                
                // Add note for experience source free text (only includes respondents who rated 3+)
                // Check both the key and label for experience-related questions
                const isExpSource = key.includes('expsrc') || 
                                   key.includes('experience_source') || 
                                   key.includes('ai_exp_other') || 
                                   key.includes('consciousness_exp_other') || 
                                   key.includes('ethics_exp_other') || 
                                   key.includes('animals_other') ||
                                   label.toLowerCase().includes('experience source') ||
                                   label.toLowerCase().includes('animal types');
                if (isExpSource) {
                    html += `<div class="filter-note align-left" style="margin-bottom:0.5rem;">NOTE: Experience source only includes respondents who rated 3+ on this experience</div>`;
                }
                
                html += `<div class="filter-note align-left" style="margin-bottom:0.5rem;background:rgba(88,166,255,0.15);color:#58a6ff;font-size:0.9rem;">Responses are shown verbatim and in random order</div>`;
                html += `<div class="free-text-list" id="${listId}" style="max-height:400px;overflow-y:auto;background:var(--bg-secondary);border-radius:6px;padding:0.5rem;">`;
                shuffled.slice(0, 100).forEach(r => {
                    html += `<div class="free-text-item" style="padding:0.5rem 0.75rem;border-bottom:1px solid var(--border);font-size:0.95rem;color:#c9d1d9;">${escHTML(r)}</div>`;
                });
                html += `</div>`;
                if (totalCount > 100) {
                    html += `<div style="margin-top:0.6rem;display:flex;align-items:center;gap:0.75rem;flex-wrap:wrap;">`;
                    html += `<span style="color:var(--text-muted);font-size:0.9rem;" id="${listId}-count">Showing 100 of ${totalCount} responses</span>`;
                    html += `<span style="color:#8b949e;font-size:0.9rem;font-weight:600;cursor:pointer;text-decoration:underline;" onclick="toggleShowAll('${sectionId}', '${listId}', ${totalCount})" id="${listId}-toggle">Show all</span>`;
                    html += `</div>`;
                }
                html += `<div style="margin-top:0.5rem;font-size:0.8rem;color:#6e7681;font-style:italic;">Content reflects respondents' own views and might include language some find offensive.</div>`;
                html += `</div>`;
            } else {
                html += `<div class="ft-question-section" style="margin-bottom:1rem;">`;
                html += `<h5 style="margin-bottom:0.5rem;color:#e6edf3;font-size:1.05rem;">${escHTML(label)} <span class="filter-badge" style="font-weight:normal;font-size:0.9rem;">N=0</span></h5>`;
                if (isFollowUpOnly && questionNotInFollowup) {
                    html += `<p class="no-data" style="font-size:0.95rem;">This question was not asked in the Follow-up sample</p>`;
                } else {
                    html += `<p class="no-data" style="font-size:0.95rem;">No responses for this filter</p>`;
                }
                html += `</div>`;
            }
        });
    }
    
    html += '</div>';
    ftArea.innerHTML = html;
    ftArea.style.display = 'block';
    
    // Add click handlers for split filter labels
    ftArea.querySelectorAll('.ft-split-filter').forEach(el => {
        el.addEventListener('click', () => {
            const listId = el.dataset.listId;
            const filterLabel = el.dataset.filterLabel;
            const list = document.getElementById(listId);
            if (!list) return;
            
            const allResponses = JSON.parse(list.dataset.allResponses || '[]');
            const isActive = el.classList.contains('active');
            const countSpan = document.getElementById(`${listId}-count`);
            const toggleSpan = document.getElementById(`${listId}-toggle`);
            
            // Reset all filter styles in this row
            el.parentElement.querySelectorAll('.ft-split-filter').forEach(f => {
                f.classList.remove('active');
                f.style.background = 'transparent';
                f.style.fontWeight = 'normal';
            });
            
            if (isActive) {
                // Show all responses again
                const shuffled = [...allResponses].sort(() => Math.random() - 0.5);
                const showCount = Math.min(100, allResponses.length);
                const toShow = shuffled.slice(0, showCount);
                list.innerHTML = toShow.map(item => 
                    `<div class="free-text-item" style="padding:0.5rem 0.75rem;border-bottom:1px solid var(--border);font-size:0.95rem;color:#c9d1d9;display:flex;justify-content:space-between;gap:1rem;">
                        <span style="flex:1;">${escHTML(item.text)}</span>
                        <span style="font-size:0.75rem;color:var(--text-muted);white-space:nowrap;padding-left:0.5rem;border-left:1px solid var(--border);display:flex;align-items:center;">${item.label}</span>
                    </div>`
                ).join('');
                list.dataset.showing = String(showCount);
                // Update count display
                if (countSpan) {
                    if (allResponses.length > 100) {
                        countSpan.textContent = `Showing ${showCount} of ${allResponses.length} responses`;
                    } else {
                        countSpan.textContent = `Showing all ${allResponses.length} responses`;
                    }
                }
                if (toggleSpan) {
                    toggleSpan.style.display = allResponses.length > 100 ? 'inline' : 'none';
                    toggleSpan.textContent = 'Show all';
                }
            } else {
                // Filter to show only this split
                el.classList.add('active');
                el.style.background = 'rgba(88,166,255,0.3)';
                el.style.fontWeight = '600';
                
                const filtered = allResponses.filter(item => item.label === filterLabel);
                const shuffled = [...filtered].sort(() => Math.random() - 0.5);
                list.innerHTML = shuffled.map(item => 
                    `<div class="free-text-item" style="padding:0.5rem 0.75rem;border-bottom:1px solid var(--border);font-size:0.95rem;color:#c9d1d9;display:flex;justify-content:space-between;gap:1rem;">
                        <span style="flex:1;">${escHTML(item.text)}</span>
                        <span style="font-size:0.75rem;color:var(--text-muted);white-space:nowrap;padding-left:0.5rem;border-left:1px solid var(--border);display:flex;align-items:center;">${item.label}</span>
                    </div>`
                ).join('');
                
                // Update count display for filtered results
                if (countSpan) {
                    countSpan.textContent = `Showing all ${filtered.length} responses (filtered)`;
                }
                if (toggleSpan) {
                    toggleSpan.style.display = 'none';  // Hide toggle when filtered
                }
                
                if (filtered.length === 0) {
                    list.innerHTML = '<p class="no-data" style="padding:1rem;text-align:center;color:var(--text-muted);">No responses for this split</p>';
                }
            }
        });
    });
}

// Toggle showing all free text responses
function toggleShowAll(sectionId, listId, totalCount) {
    const section = document.getElementById(sectionId);
    const list = document.getElementById(listId);
    const countSpan = document.getElementById(`${listId}-count`);
    const toggleSpan = document.getElementById(`${listId}-toggle`);
    
    if (!section || !list) return;
    
    const allResponses = JSON.parse(section.dataset.allResponses || '[]');
    const currentlyShowing = parseInt(section.dataset.showing) || 100;
    
    if (currentlyShowing >= totalCount) {
        // Currently showing all, switch to 100
        list.innerHTML = allResponses.slice(0, 100).map(r => 
            `<div class="free-text-item" style="padding:0.5rem 0.75rem;border-bottom:1px solid var(--border);font-size:0.95rem;color:#c9d1d9;">${escHTML(r)}</div>`
        ).join('');
        section.dataset.showing = '100';
        if (countSpan) countSpan.textContent = `Showing 100 of ${totalCount} responses`;
        if (toggleSpan) toggleSpan.textContent = 'Show all';
        list.style.maxHeight = '400px';
    } else {
        // Currently showing 100, switch to all
        list.innerHTML = allResponses.map(r => 
            `<div class="free-text-item" style="padding:0.5rem 0.75rem;border-bottom:1px solid var(--border);font-size:0.95rem;color:#c9d1d9;">${escHTML(r)}</div>`
        ).join('');
        section.dataset.showing = String(totalCount);
        if (countSpan) countSpan.textContent = `Showing all ${totalCount} responses`;
        if (toggleSpan) toggleSpan.textContent = 'Show less';
        list.style.maxHeight = '600px';
    }
}

// Toggle showing all free text responses in split mode (with labels)
function toggleShowAllSplit(listId, totalCount) {
    const list = document.getElementById(listId);
    const countSpan = document.getElementById(`${listId}-count`);
    const toggleSpan = document.getElementById(`${listId}-toggle`);
    
    if (!list) return;
    
    const allResponses = JSON.parse(list.dataset.allResponses || '[]');
    const currentlyShowing = parseInt(list.dataset.showing) || 100;
    
    // Clear any active filter highlights when toggling show all
    const section = list.closest('.ft-question-section');
    if (section) {
        section.querySelectorAll('.ft-split-filter').forEach(f => {
            f.classList.remove('active');
            f.style.background = 'transparent';
            f.style.fontWeight = 'normal';
        });
    }
    
    if (currentlyShowing >= totalCount) {
        // Currently showing all, switch to 100
        list.innerHTML = allResponses.slice(0, 100).map(item => 
            `<div class="free-text-item" style="padding:0.5rem 0.75rem;border-bottom:1px solid var(--border);font-size:0.95rem;color:#c9d1d9;display:flex;justify-content:space-between;gap:1rem;">
                <span style="flex:1;">${escHTML(item.text)}</span>
                <span style="font-size:0.75rem;color:var(--text-muted);white-space:nowrap;padding-left:0.5rem;border-left:1px solid var(--border);display:flex;align-items:center;">${item.label}</span>
            </div>`
        ).join('');
        list.dataset.showing = '100';
        if (countSpan) countSpan.textContent = `Showing 100 of ${totalCount} responses`;
        if (toggleSpan) toggleSpan.textContent = 'Show all';
        list.style.maxHeight = '500px';
    } else {
        // Currently showing 100, switch to all
        list.innerHTML = allResponses.map(item => 
            `<div class="free-text-item" style="padding:0.5rem 0.75rem;border-bottom:1px solid var(--border);font-size:0.95rem;color:#c9d1d9;display:flex;justify-content:space-between;gap:1rem;">
                <span style="flex:1;">${escHTML(item.text)}</span>
                <span style="font-size:0.75rem;color:var(--text-muted);white-space:nowrap;padding-left:0.5rem;border-left:1px solid var(--border);display:flex;align-items:center;">${item.label}</span>
            </div>`
        ).join('');
        list.dataset.showing = String(totalCount);
        if (countSpan) countSpan.textContent = `Showing all ${totalCount} responses`;
        if (toggleSpan) toggleSpan.textContent = 'Show less';
        list.style.maxHeight = '700px';
    }
}

// Toggle showing all table rows
function toggleTableRows(toggleEl, totalRows, action = null) {
    const MAX_ROWS = 10;
    const paginationDiv = toggleEl.closest('.table-pagination');
    if (!paginationDiv) return;
    
    const table = paginationDiv.previousElementSibling;
    const tbody = table?.querySelector('tbody');
    const countSpan = paginationDiv.querySelector('#table-row-count, [id$="-row-count"]');
    
    if (!tbody) return;
    
    const allRows = JSON.parse(toggleEl.dataset.allRows || '[]');
    const currentText = toggleEl.textContent;
    
    // Determine action based on current text state (toggle behavior)
    let targetAction = action;
    if (action === 'show-all') {
        // Toggle: if currently "Show less", go back to showing partial; otherwise show all
        targetAction = (currentText === 'Show less') ? 'show-less' : 'show-all';
    }
    
    if (targetAction === 'show-all') {
        // Show all rows
        tbody.innerHTML = allRows.join('');
        if (countSpan) countSpan.textContent = `Showing all ${totalRows} rows`;
        toggleEl.textContent = 'Show less';
    } else if (targetAction === 'show-less') {
        // Switch to showing MAX_ROWS
        tbody.innerHTML = allRows.slice(0, MAX_ROWS).join('');
        if (countSpan) countSpan.textContent = `Showing ${Math.min(MAX_ROWS, totalRows)} of ${totalRows} rows`;
        toggleEl.textContent = 'Show all';
    } else if (targetAction === 'hide-all') {
        // Hide all rows (show just header)
        tbody.innerHTML = '';
        if (countSpan) countSpan.textContent = `Showing 0 of ${totalRows} rows`;
        // Find the Show all/Show less span and reset it
        const showAllSpan = paginationDiv.querySelector('[data-action="show-all"]');
        if (showAllSpan) showAllSpan.textContent = 'Show all';
    }
}

// Download charts as PNG with attribution - High DPI version
async function downloadCharts() {
    const chartArea = document.getElementById('dist-chart-area');
    const legendArea = document.getElementById('dist-legend-area');
    const distTitle = document.getElementById('dist-title');
    
    if (!chartArea) return;
    
    // Hide any tooltips before capturing
    const tooltipEl = document.getElementById('chartjs-tooltip');
    if (tooltipEl) tooltipEl.style.opacity = '0';
    
    // Also hide any Chart.js native tooltips
    if (typeof Chart !== 'undefined' && Chart.instances) {
        Object.values(Chart.instances).forEach(chart => {
            if (chart.tooltip) {
                chart.tooltip.setActiveElements([], {x: 0, y: 0});
                chart.update('none');
            }
        });
    }
    
    const canvases = chartArea.querySelectorAll('canvas');
    if (canvases.length === 0) {
        alert('No charts to download');
        return;
    }
    
    // HIGH DPI SCALE FACTOR
    const DPI_SCALE = 2;
    
    // Get configuration
    const { splitBySample, splitBySource, splitByCluster } = getSplitConfig();
    const isSplitMode = splitBySample || splitBySource || splitByCluster;
    const catSelect = document.getElementById('dist-category');
    const topicName = catSelect?.selectedOptions[0]?.textContent || 'chart';
    const currentCategory = catSelect?.value || '';
    
    // Get entity names for title/filename
    const isEntityView = ['c_attr', 'ms_attr', 'combined_attr'].includes(currentCategory);
    let entityNames = [];
    if (isEntityView) {
        const checkedEntities = document.querySelectorAll('#vbox input[type="checkbox"]:checked:not(#v-all)');
        entityNames = Array.from(checkedEntities).map(cb => cb.nextElementSibling?.textContent?.trim()).filter(Boolean);
    }
    
    // Get question names - check both select element and checkbox groups
    const varSelect = document.getElementById('dist-variable');
    let questionNames = [];
    if (varSelect) {
        questionNames = Array.from(varSelect.selectedOptions || []).map(opt => opt.textContent.trim());
    }
    
    // Also check for demographics checkboxes (they use checkbox group, not select)
    if (currentCategory === 'demo') {
        const demoBox = document.getElementById('variable-container');
        const checkedDemos = demoBox?.querySelectorAll('input[type="checkbox"]:checked:not([id="v-all"])');
        if (checkedDemos && checkedDemos.length > 0) {
            questionNames = Array.from(checkedDemos).map(cb => cb.nextElementSibling?.textContent?.trim()).filter(Boolean);
        }
    }
    
    // Also check for experience domains checkboxes
    if (currentCategory === 'exp_sources') {
        const expBox = document.getElementById('variable-container');
        const checkedExp = expBox?.querySelectorAll('input[type="checkbox"]:checked:not([id="v-all"])');
        if (checkedExp && checkedExp.length > 0) {
            questionNames = Array.from(checkedExp).map(cb => cb.nextElementSibling?.textContent?.trim()).filter(Boolean);
        }
    }
    
    // Get filter info
    const filterBox = document.getElementById('sample-filter-box');
    let filterParts = [];
    filterBox?.querySelectorAll('.filter-group input:checked')?.forEach(cb => {
        const label = cb.nextElementSibling?.textContent?.trim();
        if (label && label !== 'All' && !label.includes('no filter')) filterParts.push(label);
    });
    
    let splitInfo = [];
    if (splitBySample) splitInfo.push('Split by Sample Phase');
    if (splitBySource) splitInfo.push('Split by Recruitment');
    if (splitByCluster) splitInfo.push('Split by Cluster');
    
    const filterText = filterParts.length > 0 ? filterParts.join(' + ') : 'All respondents';
    const fullFilterText = filterText + (splitInfo.length > 0 ? ' + ' + splitInfo.join(' + ') : '');
    
    // Get N and title
    const nMatch = distTitle?.innerHTML?.match(/N=(\d+)/);
    const nValue = nMatch ? nMatch[1] : '?';
    
    let mainTitle = distTitle?.textContent?.replace(/N=\d+/g, '').replace(/Total N=\d+/g, '').replace(/NOTE:.*/g, '').replace(/\d+ Questions? Selected.*/g, '').trim() || topicName;
    
    // Add entity name to title if missing
    if (isEntityView && entityNames.length > 0 && entityNames.length <= 3) {
        const entityStr = entityNames.join(', ');
        if (!mainTitle.toLowerCase().includes(entityStr.toLowerCase())) {
            mainTitle = mainTitle + ': ' + entityStr;
        }
    }
    
    const noteMatch = distTitle?.innerHTML?.match(/NOTE:[^<]*/);
    const noteText = noteMatch ? noteMatch[0] : '';
    
    // Detect layout type
    const splitHeaderRow = chartArea.querySelector('.split-header-row');
    const splitQuestionRows = chartArea.querySelectorAll('.split-question-row');
    const chartGrid = chartArea.querySelector('.chart-grid');
    const chartCells = chartArea.querySelectorAll('.chart-cell');
    
    // Detect special demo sections (employment, country, education topic bar charts)
    const specialDemoSections = chartArea.querySelectorAll('.special-demo-section');
    const hasSpecialDemoSections = specialDemoSections.length > 0;
    
    // Helper function to check if color is light
    function isLightColor(color) {
        if (!color) return false;
        let r, g, b;
        if (color.startsWith('rgb')) {
            const match = color.match(/(\d+),\s*(\d+),\s*(\d+)/);
            if (match) { r = parseInt(match[1]); g = parseInt(match[2]); b = parseInt(match[3]); }
        } else if (color.startsWith('#')) {
            const hex = color.slice(1);
            r = parseInt(hex.substr(0,2), 16);
            g = parseInt(hex.substr(2,2), 16);
            b = parseInt(hex.substr(4,2), 16);
        }
        if (r !== undefined) {
            const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
            return luminance > 0.6;
        }
        return false;
    }
    
    // Helper function to extract background color from element (handles inline style)
    function getHeaderBgColor(el, defaultColor = '#3a4149') {
        if (!el) return defaultColor;
        // First try inline style attribute (most reliable for dynamically set styles)
        const styleAttr = el.getAttribute('style') || '';
        const bgMatch = styleAttr.match(/background(?:-color)?:\s*([^;]+)/i);
        if (bgMatch) {
            return bgMatch[1].trim();
        }
        // Fall back to computed style
        const computed = getComputedStyle(el).backgroundColor;
        if (computed && computed !== 'rgba(0, 0, 0, 0)' && computed !== 'transparent') {
            return computed;
        }
        return defaultColor;
    }
    
    // Create canvas
    const tempCanvas = document.createElement('canvas');
    const ctx = tempCanvas.getContext('2d');
    
    // Base dimensions (will be scaled by DPI_SCALE)
    const padding = 30;
    const headerHeight = 35;
    const titleHeight = noteText ? 65 : 35;  // More space when NOTE exists
    const attributionHeight = 35;
    
    // Calculate legend rows needed
    let legendRowsNeeded = 1;
    const legendItems = legendArea?.querySelectorAll('.legend-item') || [];
    
    let baseWidth, baseHeight;
    
    if (splitHeaderRow && splitQuestionRows.length > 0) {
        // SPLIT VIEW - horizontal bars with headers
        const numSplits = splitHeaderRow.querySelectorAll('.split-column-header').length;
        const hasTickLabels = !!chartArea.querySelector('.split-tick-labels');
        const numEntities = splitQuestionRows.length;
        
        // Different layouts based on split count and entity count
        const isSplitByBoth = numSplits >= 4;  // 4-5 splits = split by both
        const useMultiBlockLayout = isEntityView && numEntities > 6 && !hasTickLabels;
        
        if (useMultiBlockLayout && isSplitByBoth) {
            // Split-by-both: 2 entities per row (10 donuts per row)
            const numBlocks = 2;
            const blockEntityLabelWidth = 60;
            const blockChartWidth = 75;
            const blockWidth = blockEntityLabelWidth + (numSplits * blockChartWidth);
            const gapBetweenBlocks = 25;
            const rowHeight = 105;  // Increased to prevent overlap
            const entitiesPerRow = numBlocks;
            const numRows = Math.ceil(numEntities / entitiesPerRow);
            
            baseWidth = numBlocks * blockWidth + gapBetweenBlocks + padding * 2;
            baseHeight = padding + headerHeight + titleHeight + 55 + (numRows * rowHeight) + (legendRowsNeeded * 25) + 20 + attributionHeight;
        } else if (useMultiBlockLayout && numSplits <= 3) {
            // Single split (2-3 splits): 4 entities per row
            const numBlocks = 4;
            const blockEntityLabelWidth = 55;
            const blockChartWidth = 85;
            const blockWidth = blockEntityLabelWidth + (numSplits * blockChartWidth);
            const gapBetweenBlocks = 18;
            const rowHeight = 95;
            const entitiesPerRow = numBlocks;
            const numRows = Math.ceil(numEntities / entitiesPerRow);
            
            baseWidth = numBlocks * blockWidth + (numBlocks - 1) * gapBetweenBlocks + padding * 2;
            baseHeight = padding + headerHeight + titleHeight + 45 + (numRows * rowHeight) + (legendRowsNeeded * 25) + 20 + attributionHeight;
        } else {
            // Original single-column layout or 2-questions-per-row for donuts
            const questionLabelWidth = 150;
            const tickColWidth = hasTickLabels ? 300 : 0;
            const chartColWidth = 180;
            
            // Check if this should be 2 questions per row (donuts without tick labels)
            const isDonutView = !hasTickLabels;
            const numQuestions = splitQuestionRows.length;
            
            if (isDonutView && numQuestions > 1) {
                // 2 questions per row layout
                const questionsPerRow = 2;
                const qLabelWidth = 100;
                const donutColWidth = 90;
                const blockWidth = qLabelWidth + (numSplits * donutColWidth);
                const gapBetweenBlocks = 30;
                const rowHeight = 110;  // Increased for multi-line labels
                const numRows = Math.ceil(numQuestions / questionsPerRow);
                
                baseWidth = questionsPerRow * blockWidth + gapBetweenBlocks + padding * 2;
                baseHeight = padding + headerHeight + titleHeight + 45 + (numRows * rowHeight) + (legendRowsNeeded * 24) + 50;
            } else {
                baseWidth = questionLabelWidth + tickColWidth + (numSplits * chartColWidth) + padding * 2;
                
                let totalRowHeight = 0;
                splitQuestionRows.forEach(row => {
                    // For horizontal bar charts, use data-bar-height if available (more accurate)
                    const chartCell = row.querySelector('.chart-cell[data-bar-height]');
                    const barHeight = chartCell ? parseInt(chartCell.dataset.barHeight) : null;
                    const canvas = row.querySelector('canvas');
                    // Use barHeight from data attribute, fallback to canvas height, then default
                    const rowHeight = barHeight || (canvas ? Math.min(canvas.height, 600) : 150);
                    totalRowHeight += rowHeight + 20;
                });
                
                // Tight height calculation - just content + small buffer
                baseHeight = padding + headerHeight + titleHeight + 55 + totalRowHeight + attributionHeight;
            }
        }
        
    } else if (chartGrid && chartCells.length > 0) {
        // GRID VIEW - donuts
        let cols = chartCells.length;
        if (chartGrid.classList.contains('cols-5')) cols = Math.min(5, chartCells.length);
        else if (chartGrid.classList.contains('cols-4')) cols = Math.min(4, chartCells.length);
        else if (chartGrid.classList.contains('cols-3')) cols = Math.min(3, chartCells.length);
        else if (chartGrid.classList.contains('cols-2')) cols = Math.min(2, chartCells.length);
        
        const rows = Math.ceil(chartCells.length / cols);
        
        // Detect if this is a split view (has split-column-header) 
        const hasSplitHeaders = !!chartCells[0]?.querySelector('.split-column-header');
        
        // Detect if cells have per-cell legends (EiD, KPT)
        const hasPerCellLegends = !!chartCells[0]?.querySelector('.chart-cell-legend');
        
        // Calculate max canvas height in the grid
        let maxCanvasHeight = 0;
        chartCells.forEach(cell => {
            const canvas = cell.querySelector('canvas');
            if (canvas && canvas.height > maxCanvasHeight) {
                maxCanvasHeight = canvas.height;
            }
        });
        
        // Different dimensions for split vs non-split (non-split needs more for multi-line titles)
        // Check if demographics with many legend items per cell
        const firstCellLegend = chartCells[0]?.querySelector('.chart-cell-legend');
        const legendItemCount = firstCellLegend?.querySelectorAll('span[style*="display:flex"]')?.length || 
                                firstCellLegend?.querySelectorAll('.legend-item')?.length || 0;
        const hasManyLegendItems = legendItemCount > 4;
        const needsMultiLineLegend = legendItemCount > 3;  // Age Group has 7+ items
        
        // For demographics with 2-3 donuts (regardless of bar charts below), use larger donuts
        const isDemographicsLargeDonuts = currentCategory === 'demo' && chartCells.length <= 3 && !hasSplitHeaders;
        
        const cellWidth = hasSplitHeaders ? 210 : (isDemographicsLargeDonuts ? 280 : (hasManyLegendItems ? 200 : 180));
        const titleAreaHeight = hasSplitHeaders ? 48 : 40;
        // More space for multi-line legends in demographics
        const perCellLegendHeight = hasPerCellLegends ? (needsMultiLineLegend ? 36 : 18) : 0;
        const chartTopPadding = 2;  // Minimal padding between legend and chart
        // Use actual canvas height (scaled) or minimum - larger for small demographics
        const chartHeight = hasSplitHeaders 
            ? 150 
            : (isDemographicsLargeDonuts ? Math.max(180, Math.min(maxCanvasHeight * 0.95, 250)) : Math.max(120, Math.min(maxCanvasHeight * 0.85, 200)));
        const cellHeight = titleAreaHeight + perCellLegendHeight + chartTopPadding + chartHeight + 8;
        
        baseWidth = cols * cellWidth + padding * 2;
        
        // Calculate legend wrapping
        if (legendItems.length > 0) {
            ctx.font = '12px "DM Sans", sans-serif';
            let testX = 0;
            legendItems.forEach(item => {
                const label = item.textContent.trim();
                const itemWidth = ctx.measureText(label).width + 32;
                if (testX + itemWidth > baseWidth - padding * 2) {
                    legendRowsNeeded++;
                    testX = itemWidth;
                } else {
                    testX += itemWidth;
                }
            });
        }
        
        // Tight height calculation - no excessive padding
        let specialDemoHeight = 0;
        if (hasSpecialDemoSections) {
            const maxChartWidth = baseWidth - padding * 2;
            specialDemoSections.forEach(section => {
                const canvas = section.querySelector('canvas');
                if (canvas) {
                    // Use same scaling as rendering (scale to fit width)
                    const scale = Math.min(maxChartWidth / canvas.width, 1);
                    const scaledHeight = canvas.height * scale;
                    specialDemoHeight += scaledHeight + 45;  // scaled chart + title + spacing
                }
            });
        }
        // Use tight calculation: content + attribution only
        baseHeight = padding + headerHeight + titleHeight + (rows * cellHeight) + specialDemoHeight + attributionHeight;
        
    } else {
        // Check if this is Entity Combined Mean mode with multiple scatter charts
        const splitScatters = chartArea.querySelectorAll('canvas[id^="split-scatter-"]');
        const splitColumnHeaders = chartArea.querySelectorAll('.split-column-header');
        
        if (splitScatters.length > 0 && splitColumnHeaders.length > 0) {
            // ENTITY COMBINED MEAN MODE dimensions
            const numSplits = splitScatters.length;
            const numCols = numSplits >= 5 ? 3 : numSplits;
            const numRows = Math.ceil(numSplits / numCols);
            const rowHeight = 300;
            const headerBarHeight = 50;
            
            baseWidth = Math.max(800, 280 * numCols + padding * 2);
            baseHeight = padding + headerHeight + titleHeight + numRows * (rowHeight + headerBarHeight + 15) + (legendRowsNeeded * 25) + 20 + attributionHeight;
            
        } else {
            // SINGLE CHART - scatter, horizontal bar
            const canvas = canvases[0];
            const isEntityCombined = currentCategory === 'combined_attr';
            const scaleFactor = isEntityCombined ? 1.3 : 1.1;
            
            baseWidth = Math.max(700, (canvas?.width || 500) * scaleFactor + padding * 2);
            
            // Calculate legend wrapping for entity combined
            if (legendItems.length > 0) {
                ctx.font = '12px "DM Sans", sans-serif';
                let testX = 0;
                legendItems.forEach(item => {
                    const label = item.textContent.trim();
                    const itemWidth = ctx.measureText(label).width + 32;
                    if (testX + itemWidth > baseWidth - padding * 2) {
                        legendRowsNeeded++;
                        testX = itemWidth;
                    } else {
                        testX += itemWidth;
                    }
                });
            }
            
            // More generous height - include special demo sections if present alone
            let specialDemoHeight = 0;
            if (hasSpecialDemoSections && !chartGrid) {
                const maxChartWidth = baseWidth - padding * 2;
                specialDemoSections.forEach(section => {
                    const sectionCanvas = section.querySelector('canvas');
                    if (sectionCanvas) {
                        const scale = Math.min(maxChartWidth / sectionCanvas.width, 1);
                        const scaledHeight = sectionCanvas.height * scale;
                        specialDemoHeight += scaledHeight + 45;
                    }
                });
            }
            baseHeight = padding + headerHeight + titleHeight + ((canvas?.height || 300) * scaleFactor) + specialDemoHeight + attributionHeight;
        }
    }
    
    // Apply DPI scale
    tempCanvas.width = baseWidth * DPI_SCALE;
    tempCanvas.height = baseHeight * DPI_SCALE;
    ctx.scale(DPI_SCALE, DPI_SCALE);
    
    // Fill background
    ctx.fillStyle = '#0d1117';
    ctx.fillRect(0, 0, baseWidth, baseHeight);
    
    // Draw header
    let yPos = padding;
    ctx.fillStyle = '#e6edf3';
    ctx.font = 'bold 18px "DM Sans", sans-serif';
    ctx.fillText(`N=${nValue}`, padding, yPos + 18);
    
    ctx.font = '14px "DM Sans", sans-serif';
    ctx.fillStyle = '#8b949e';
    ctx.fillText(`Filter: ${fullFilterText}`, padding + ctx.measureText(`N=${nValue}`).width + 25, yPos + 18);
    
    yPos += headerHeight;
    
    // Draw title
    ctx.fillStyle = '#e6edf3';
    ctx.font = 'bold 18px "DM Sans", sans-serif';
    ctx.fillText(mainTitle, padding, yPos + 20);
    
    if (noteText) {
        ctx.font = '13px "DM Sans", sans-serif';
        ctx.fillStyle = '#ffa657';
        ctx.fillText(noteText, padding, yPos + 40);
    }
    
    yPos += titleHeight;
    
    // RENDER BASED ON LAYOUT TYPE
    if (splitHeaderRow && splitQuestionRows.length > 0) {
        // SPLIT VIEW
        const splitHeaders = splitHeaderRow.querySelectorAll('.split-column-header');
        const numSplits = splitHeaders.length;
        const hasTickLabels = !!chartArea.querySelector('.split-tick-labels');
        const numEntities = splitQuestionRows.length;
        
        // Different layouts based on split count and entity count
        const isSplitByBoth = numSplits >= 4;
        const useMultiBlockLayout = isEntityView && numEntities > 6 && !hasTickLabels;
        
        if (useMultiBlockLayout && isSplitByBoth) {
            // Split-by-both: 2 entities per row (8-10 donuts per row)
            const numBlocks = 2;
            const blockEntityLabelWidth = 60;
            const blockChartWidth = 75;
            const blockWidth = blockEntityLabelWidth + (numSplits * blockChartWidth);
            const gapBetweenBlocks = 25;
            
            // Draw headers for both blocks
            for (let blockIdx = 0; blockIdx < numBlocks; blockIdx++) {
                const blockX = padding + blockIdx * (blockWidth + gapBetweenBlocks);
                let headerX = blockX + blockEntityLabelWidth;
                
                splitHeaders.forEach(header => {
                    const bgColor = getHeaderBgColor(header);
                    const text = header.textContent.replace(/\n/g, ' ').trim();
                    
                    ctx.fillStyle = bgColor;
                    ctx.fillRect(headerX + 1, yPos, blockChartWidth - 2, 42);  // Taller header for 3 lines
                    
                    ctx.fillStyle = isLightColor(bgColor) ? '#1a1a2e' : '#ffffff';
                    ctx.textAlign = 'center';
                    
                    const parts = text.split(/N=/);
                    const titlePart = parts[0].trim();
                    
                    // Always split into 3 lines for split-by-both: line1 / line2 / N=xxx
                    if (titlePart.includes(' / ')) {
                        const [line1, line2] = titlePart.split(' / ');
                        ctx.font = '6px "DM Sans", sans-serif';
                        ctx.fillText(line1.trim() + ' /', headerX + blockChartWidth / 2, yPos + 10);
                        ctx.fillText(line2.trim(), headerX + blockChartWidth / 2, yPos + 20);
                        if (parts[1]) {
                            ctx.font = '5.5px "DM Sans", sans-serif';
                            ctx.fillText('N=' + parts[1].trim(), headerX + blockChartWidth / 2, yPos + 32);
                        }
                    } else {
                        ctx.font = '6.5px "DM Sans", sans-serif';
                        ctx.fillText(titlePart, headerX + blockChartWidth / 2, yPos + 14);
                        if (parts[1]) {
                            ctx.font = '5.5px "DM Sans", sans-serif';
                            ctx.fillText('N=' + parts[1].trim(), headerX + blockChartWidth / 2, yPos + 28);
                        }
                    }
                    ctx.textAlign = 'left';
                    headerX += blockChartWidth;
                });
            }
            
            yPos += 48;  // Increased for taller headers
            
            // Draw rows - 2 entities per row with more spacing
            const entitiesPerRow = numBlocks;
            const rowArray = Array.from(splitQuestionRows);
            const rowHeight = 105;  // Increased to prevent overlap
            const numRows = Math.ceil(numEntities / entitiesPerRow);
            
            for (let rowIdx = 0; rowIdx < numRows; rowIdx++) {
                for (let blockIdx = 0; blockIdx < numBlocks; blockIdx++) {
                    const entityIdx = rowIdx * entitiesPerRow + blockIdx;
                    if (entityIdx >= numEntities) continue;
                    
                    const row = rowArray[entityIdx];
                    const questionLabel = row.querySelector('.split-question-label');
                    const rowCharts = row.querySelectorAll('canvas');
                    
                    const blockX = padding + blockIdx * (blockWidth + gapBetweenBlocks);
                    
                    // Entity label - right-aligned, closer to donuts
                    if (questionLabel) {
                        ctx.fillStyle = '#c9d1d9';
                        ctx.font = '8px "DM Sans", sans-serif';
                        const text = questionLabel.textContent.trim();
                        const displayText = text.length > 10 ? text.substring(0, 8) + '...' : text;
                        ctx.textAlign = 'right';
                        ctx.fillText(displayText, blockX + blockEntityLabelWidth - 3, yPos + rowHeight / 2 + 3);
                        ctx.textAlign = 'left';
                    }
                    
                    // Charts
                    let chartX = blockX + blockEntityLabelWidth;
                    rowCharts.forEach(canvas => {
                        const scale = Math.min((blockChartWidth - 6) / canvas.width, (rowHeight - 6) / canvas.height);
                        const w = canvas.width * scale, h = canvas.height * scale;
                        ctx.drawImage(canvas, chartX + (blockChartWidth - w) / 2, yPos + (rowHeight - h) / 2, w, h);
                        chartX += blockChartWidth;
                    });
                }
                
                yPos += rowHeight;
            }
            
        } else if (useMultiBlockLayout && numSplits <= 3) {
            // Single split: 4 entities per row
            const numBlocks = 4;
            const blockEntityLabelWidth = 55;
            const blockChartWidth = 85;
            const blockWidth = blockEntityLabelWidth + (numSplits * blockChartWidth);
            const gapBetweenBlocks = 18;
            
            // Draw headers for all 4 blocks
            for (let blockIdx = 0; blockIdx < numBlocks; blockIdx++) {
                const blockX = padding + blockIdx * (blockWidth + gapBetweenBlocks);
                let headerX = blockX + blockEntityLabelWidth;
                
                splitHeaders.forEach(header => {
                    const bgColor = getHeaderBgColor(header);
                    const text = header.textContent.replace(/\n/g, ' ').trim();
                    
                    ctx.fillStyle = bgColor;
                    ctx.fillRect(headerX + 2, yPos, blockChartWidth - 4, 32);
                    
                    ctx.fillStyle = isLightColor(bgColor) ? '#1a1a2e' : '#ffffff';
                    ctx.font = '8px "DM Sans", sans-serif';
                    ctx.textAlign = 'center';
                    
                    const parts = text.split(/N=/);
                    ctx.fillText(parts[0].trim(), headerX + blockChartWidth / 2, yPos + 11);
                    if (parts[1]) {
                        ctx.font = '7px "DM Sans", sans-serif';
                        ctx.fillText('N=' + parts[1].trim(), headerX + blockChartWidth / 2, yPos + 22);
                    }
                    ctx.textAlign = 'left';
                    headerX += blockChartWidth;
                });
            }
            
            yPos += 40;
            
            // Draw rows - 4 entities per row
            const entitiesPerRow = numBlocks;
            const rowArray = Array.from(splitQuestionRows);
            const rowHeight = 95;
            const numRows = Math.ceil(numEntities / entitiesPerRow);
            
            for (let rowIdx = 0; rowIdx < numRows; rowIdx++) {
                for (let blockIdx = 0; blockIdx < numBlocks; blockIdx++) {
                    const entityIdx = rowIdx * entitiesPerRow + blockIdx;
                    if (entityIdx >= numEntities) continue;
                    
                    const row = rowArray[entityIdx];
                    const questionLabel = row.querySelector('.split-question-label');
                    const rowCharts = row.querySelectorAll('canvas');
                    
                    const blockX = padding + blockIdx * (blockWidth + gapBetweenBlocks);
                    
                    // Entity label - right-aligned, close to donuts
                    if (questionLabel) {
                        ctx.fillStyle = '#c9d1d9';
                        ctx.font = '9px "DM Sans", sans-serif';
                        const text = questionLabel.textContent.trim();
                        const displayText = text.length > 10 ? text.substring(0, 8) + '...' : text;
                        ctx.textAlign = 'right';
                        ctx.fillText(displayText, blockX + blockEntityLabelWidth - 2, yPos + rowHeight / 2 + 3);
                        ctx.textAlign = 'left';
                    }
                    
                    // Charts
                    let chartX = blockX + blockEntityLabelWidth;
                    rowCharts.forEach(canvas => {
                        const scale = Math.min((blockChartWidth - 6) / canvas.width, (rowHeight - 6) / canvas.height);
                        const w = canvas.width * scale, h = canvas.height * scale;
                        ctx.drawImage(canvas, chartX + (blockChartWidth - w) / 2, yPos + (rowHeight - h) / 2, w, h);
                        chartX += blockChartWidth;
                    });
                }
                
                yPos += rowHeight;
            }
            
        } else {
            // Check if this is a donut-only view (no tick labels = donuts)
            const isDonutView = !hasTickLabels;
            const numQuestions = splitQuestionRows.length;
            
            if (isDonutView && numQuestions > 1) {
                // 2 QUESTIONS PER ROW layout for KPT, EiD split views with donuts
                const questionsPerRow = 2;
                const questionLabelWidth = 100;
                const blockWidth = questionLabelWidth + (numSplits * 90);
                const gapBetweenBlocks = 30;
                const totalWidth = questionsPerRow * blockWidth + gapBetweenBlocks;
                
                // Draw headers for both blocks
                for (let blockIdx = 0; blockIdx < questionsPerRow; blockIdx++) {
                    const blockX = padding + blockIdx * (blockWidth + gapBetweenBlocks);
                    let headerX = blockX + questionLabelWidth;
                    
                    splitHeaders.forEach(header => {
                        const bgColor = getHeaderBgColor(header);
                        const text = header.textContent.replace(/\n/g, ' ').trim();
                        const chartColWidth = 90;
                        
                        ctx.fillStyle = bgColor;
                        ctx.fillRect(headerX + 2, yPos, chartColWidth - 4, 38);
                        
                        ctx.fillStyle = isLightColor(bgColor) ? '#1a1a2e' : '#ffffff';
                        ctx.font = '10px "DM Sans", sans-serif';
                        ctx.textAlign = 'center';
                        
                        const parts = text.split(/N=/);
                        ctx.fillText(parts[0].trim(), headerX + chartColWidth / 2, yPos + 12);
                        if (parts[1]) {
                            ctx.font = '9px "DM Sans", sans-serif';
                            ctx.fillText('N=' + parts[1].trim(), headerX + chartColWidth / 2, yPos + 26);
                        }
                        ctx.textAlign = 'left';
                        headerX += chartColWidth;
                    });
                }
                
                yPos += 45;
                
                // Draw rows - 2 questions per row
                const rowArray = Array.from(splitQuestionRows);
                const rowHeight = 110;  // Increased for multi-line labels
                const numRows = Math.ceil(numQuestions / questionsPerRow);
                
                for (let rowIdx = 0; rowIdx < numRows; rowIdx++) {
                    for (let blockIdx = 0; blockIdx < questionsPerRow; blockIdx++) {
                        const questionIdx = rowIdx * questionsPerRow + blockIdx;
                        if (questionIdx >= numQuestions) continue;
                        
                        const row = rowArray[questionIdx];
                        const questionLabel = row.querySelector('.split-question-label');
                        const rowCharts = row.querySelectorAll('canvas');
                        
                        const blockX = padding + blockIdx * (blockWidth + gapBetweenBlocks);
                        const chartColWidth = 90;
                        
                        // Question label - word wrap and right-align
                        if (questionLabel) {
                            ctx.fillStyle = '#9ca3af';
                            ctx.font = '7.5px "DM Sans", sans-serif';  // Smaller font to prevent overlap
                            const text = questionLabel.textContent.trim();
                            const maxWidth = questionLabelWidth - 10;
                            
                            // Word wrap
                            const words = text.split(' ');
                            const lines = [];
                            let currentLine = '';
                            words.forEach(word => {
                                const testLine = currentLine ? currentLine + ' ' + word : word;
                                if (ctx.measureText(testLine).width > maxWidth && currentLine) {
                                    lines.push(currentLine);
                                    currentLine = word;
                                } else {
                                    currentLine = testLine;
                                }
                            });
                            if (currentLine) lines.push(currentLine);
                            
                            // Draw lines right-aligned, centered vertically
                            const lineHeight = 11;
                            const totalHeight = lines.length * lineHeight;
                            const startY = yPos + (rowHeight - totalHeight) / 2 + 8;
                            
                            ctx.textAlign = 'right';
                            lines.forEach((line, i) => {
                                ctx.fillText(line, blockX + questionLabelWidth - 4, startY + i * lineHeight);
                            });
                            ctx.textAlign = 'left';
                        }
                        
                        // Charts
                        let chartX = blockX + questionLabelWidth;
                        rowCharts.forEach(canvas => {
                            const scale = Math.min((chartColWidth - 8) / canvas.width, (rowHeight - 8) / canvas.height) * 0.92;
                            const w = canvas.width * scale, h = canvas.height * scale;
                            ctx.drawImage(canvas, chartX + (chartColWidth - w) / 2, yPos + (rowHeight - h) / 2, w, h);
                            chartX += chartColWidth;
                        });
                    }
                    
                    yPos += rowHeight;
                }
                
            } else {
                // Original single-column layout (for horizontal bars)
                const questionLabelWidth = 150;
                const tickColWidth = hasTickLabels ? 300 : 0;
                const chartColWidth = (baseWidth - padding * 2 - questionLabelWidth - tickColWidth) / numSplits;
                
                // Draw headers
                let headerX = padding + questionLabelWidth + tickColWidth;
                splitHeaders.forEach(header => {
                    const bgColor = getHeaderBgColor(header);
                    const text = header.textContent.replace(/\n/g, ' ').trim();
                    
                    ctx.fillStyle = bgColor;
                    ctx.fillRect(headerX + 3, yPos, chartColWidth - 6, 45);
                    
                    ctx.fillStyle = isLightColor(bgColor) ? '#1a1a2e' : '#ffffff';
                    ctx.font = '12px "DM Sans", sans-serif';
                    ctx.textAlign = 'center';
                    
                    const parts = text.split(/N=/);
                    ctx.fillText(parts[0].trim(), headerX + chartColWidth / 2, yPos + 16);
                    if (parts[1]) {
                        ctx.font = '11px "DM Sans", sans-serif';
                        ctx.fillText('N=' + parts[1].trim(), headerX + chartColWidth / 2, yPos + 32);
                    }
                    ctx.textAlign = 'left';
                    headerX += chartColWidth;
                });
                
                yPos += 55;
                
                // Draw rows
                splitQuestionRows.forEach(row => {
                    const questionLabel = row.querySelector('.split-question-label');
                    const tickLabels = row.querySelector('.split-tick-labels');
                    const rowCharts = row.querySelectorAll('canvas');
                    const firstChart = rowCharts[0];
                    // Use data-bar-height for accurate row height (especially for country/employment)
                    const chartCell = row.querySelector('.chart-cell[data-bar-height]');
                    const barHeight = chartCell ? parseInt(chartCell.dataset.barHeight) : null;
                    const rowHeight = barHeight || (firstChart ? Math.min(firstChart.height, 600) : 150);
                    
                    // Question label
                    if (questionLabel) {
                        ctx.fillStyle = '#8b949e';
                        ctx.font = '12px "DM Sans", sans-serif';
                        const words = questionLabel.textContent.trim().split(' ');
                        let line = '', labelY = yPos + 25;
                        words.forEach(word => {
                            const test = line + word + ' ';
                            if (ctx.measureText(test).width > questionLabelWidth - 15 && line) {
                                ctx.fillText(line.trim(), padding, labelY);
                                line = word + ' ';
                                labelY += 15;
                            } else {
                                line = test;
                            }
                        });
                        ctx.fillText(line.trim(), padding, labelY);
                    }
                    
                    // Tick labels - align with the actual chart bars
                    // Must account for chart scaling and centering using same layout as Chart.js
                    if (tickLabels) {
                        const ticks = tickLabels.querySelectorAll('div');
                        const numBars = ticks.length;
                        
                        // Get first chart to calculate exact positioning
                        const firstCanvas = rowCharts[0];
                        if (firstCanvas) {
                            const scale = Math.min((chartColWidth - 10) / firstCanvas.width, rowHeight / firstCanvas.height);
                            const scaledW = firstCanvas.width * scale;
                            const scaledH = firstCanvas.height * scale;
                            // Charts are centered vertically
                            const chartYOffset = yPos + (rowHeight - scaledH) / 2;
                            
                            // Use same layout calculation as the HTML/CSS layout (lines 3994-4000)
                            // Chart.js horizontal bar uses: top padding + bar area + x-axis labels
                            const xAxisHeightRatio = 28 / firstCanvas.height;  // ~28px for x-axis
                            const chartTopPadRatio = 10 / firstCanvas.height;  // ~10px top padding
                            const chartBottomPadRatio = 2 / firstCanvas.height; // ~2px before axis
                            
                            const plotAreaStart = chartYOffset + (scaledH * chartTopPadRatio);
                            const plotAreaEnd = chartYOffset + scaledH - (scaledH * xAxisHeightRatio) - (scaledH * chartBottomPadRatio);
                            const plotAreaHeight = plotAreaEnd - plotAreaStart;
                            const categoryHeight = plotAreaHeight / numBars;
                            // Bar is 85% of category, centered - offset by half remaining space
                            const barOffsetInCategory = (categoryHeight * 0.15) / 2;
                            
                            ctx.fillStyle = '#c9d1d9';
                            ctx.font = '11px "DM Sans", sans-serif';
                            ctx.textAlign = 'right';
                            
                            ticks.forEach((tick, i) => {
                                let text = tick.textContent.trim();
                                // Position each label at the center of its corresponding bar
                                const tickY = plotAreaStart + barOffsetInCategory + (i * categoryHeight) + (categoryHeight * 0.85 / 2) + 4;
                                ctx.fillText(text, padding + questionLabelWidth + tickColWidth - 10, tickY);
                            });
                            ctx.textAlign = 'left';
                        }
                    }
                    
                    // Charts - draw at full height
                    let chartX = padding + questionLabelWidth + tickColWidth;
                    rowCharts.forEach(canvas => {
                        // Use full row height for the chart
                        const scale = Math.min((chartColWidth - 10) / canvas.width, rowHeight / canvas.height);
                        const w = canvas.width * scale, h = canvas.height * scale;
                        // Center chart vertically in its space
                        ctx.drawImage(canvas, chartX + (chartColWidth - w) / 2, yPos + (rowHeight - h) / 2, w, h);
                        chartX += chartColWidth;
                    });
                    
                    yPos += rowHeight + 20;
                });
            }
        }
        
    } else if (chartGrid && chartCells.length > 0) {
        // GRID VIEW - donuts (Entity Donuts, EiD, KPT, Graded C, etc.)
        let cols = chartCells.length;
        if (chartGrid.classList.contains('cols-5')) cols = Math.min(5, chartCells.length);
        else if (chartGrid.classList.contains('cols-4')) cols = Math.min(4, chartCells.length);
        else if (chartGrid.classList.contains('cols-3')) cols = Math.min(3, chartCells.length);
        else if (chartGrid.classList.contains('cols-2')) cols = Math.min(2, chartCells.length);
        
        // Detect if this is a split view (has split-column-header) or regular view (has h4)
        const firstSplitHeader = chartCells[0]?.querySelector('.split-column-header');
        const hasSplitHeaders = !!firstSplitHeader;
        
        // Detect if cells have per-cell legends (EiD, KPT)
        const hasPerCellLegends = !!chartCells[0]?.querySelector('.chart-cell-legend');
        
        // Calculate max canvas height in the grid
        let maxCanvasHeight = 0;
        chartCells.forEach(cell => {
            const canvas = cell.querySelector('canvas');
            if (canvas && canvas.height > maxCanvasHeight) {
                maxCanvasHeight = canvas.height;
            }
        });
        
        const cellWidth = (baseWidth - padding * 2) / cols;
        // Check if demographics with many legend items per cell
        const firstCellLegend = chartCells[0]?.querySelector('.chart-cell-legend');
        const legendItemCount = firstCellLegend?.querySelectorAll('span[style*="display:flex"]')?.length || 
                                firstCellLegend?.querySelectorAll('.legend-item')?.length || 0;
        const needsMultiLineLegend = legendItemCount > 3;
        // Use larger donuts when 2-3 donuts in demographics (regardless of bar charts below)
        const isDemographicsLargeDonuts = currentCategory === 'demo' && chartCells.length <= 3 && !hasSplitHeaders;
        
        // Different heights for split vs non-split (non-split needs more for multi-line titles)
        const titleAreaHeight = hasSplitHeaders ? 48 : 40;
        const perCellLegendHeight = hasPerCellLegends ? (needsMultiLineLegend ? 36 : 18) : 0;
        const chartTopPadding = 2;  // Minimal padding between legend and chart
        // Use actual canvas height (scaled) or minimum
        const chartHeight = hasSplitHeaders 
            ? Math.min(150, cellWidth * 0.7) 
            : (isDemographicsLargeDonuts ? Math.max(180, Math.min(maxCanvasHeight * 0.95, 250)) : Math.max(120, Math.min(maxCanvasHeight * 0.85, 200)));
        const cellHeight = titleAreaHeight + perCellLegendHeight + chartTopPadding + chartHeight + 8;
        
        chartCells.forEach((cell, idx) => {
            const col = idx % cols;
            const row = Math.floor(idx / cols);
            const cellX = padding + col * cellWidth;
            const cellY = yPos + row * cellHeight;
            
            // Check for split-column-header inside cell (for split views)
            const splitHeader = cell.querySelector('.split-column-header');
            const cellTitle = cell.querySelector('h4');
            const cellLegend = cell.querySelector('.chart-cell-legend');
            
            let currentY = cellY;  // Track vertical position within cell
            
            if (splitHeader) {
                // SPLIT VIEW - draw colored header bar
                const styleAttr = splitHeader.getAttribute('style') || '';
                let bgMatch = styleAttr.match(/background:\s*([^;]+)/i);
                if (!bgMatch) bgMatch = styleAttr.match(/background-color:\s*([^;]+)/i);
                const bgColor = bgMatch ? bgMatch[1].trim() : '#3a4149';
                
                // Get text content
                const fullText = splitHeader.textContent || '';
                const parts = fullText.split(/N=/);
                const titleText = parts[0].replace(/\s+/g, ' ').trim();
                const nValue = parts[1] ? parts[1].trim() : '';
                
                // Draw colored header bar
                ctx.fillStyle = bgColor;
                ctx.fillRect(cellX + 3, currentY, cellWidth - 6, titleAreaHeight);
                
                // Draw header text (not bold)
                ctx.fillStyle = isLightColor(bgColor) ? '#1a1a2e' : '#ffffff';
                ctx.textAlign = 'center';
                ctx.font = '11px "DM Sans", sans-serif';
                ctx.fillText(titleText, cellX + cellWidth / 2, currentY + 16);
                if (nValue) {
                    ctx.font = '10px "DM Sans", sans-serif';
                    ctx.fillText('N=' + nValue, cellX + cellWidth / 2, currentY + 32);
                }
                ctx.textAlign = 'left';
                currentY += titleAreaHeight;
                
            } else if (cellTitle) {
                // NON-SPLIT VIEW - just gray text, no background, with word wrapping
                const titleText = cellTitle.textContent?.trim() || '';
                
                ctx.fillStyle = '#9ca3af';  // Gray text
                ctx.font = '10px "DM Sans", sans-serif';
                ctx.textAlign = 'center';
                
                // Word wrap the title
                const maxTextWidth = cellWidth - 12;
                const words = titleText.split(' ');
                const lines = [];
                let currentLine = '';
                
                words.forEach(word => {
                    const testLine = currentLine ? currentLine + ' ' + word : word;
                    if (ctx.measureText(testLine).width > maxTextWidth && currentLine) {
                        lines.push(currentLine);
                        currentLine = word;
                    } else {
                        currentLine = testLine;
                    }
                });
                if (currentLine) lines.push(currentLine);
                
                // Draw lines centered vertically in title area
                const lineHeight = 12;
                const totalTextHeight = lines.length * lineHeight;
                const startY = currentY + (titleAreaHeight - totalTextHeight) / 2 + 10;
                
                lines.forEach((line, i) => {
                    ctx.fillText(line, cellX + cellWidth / 2, startY + i * lineHeight);
                });
                ctx.textAlign = 'left';
                currentY += titleAreaHeight;
            }
            
            // Draw per-cell legend if present (EiD, KPT, Demographics, Experience)
            if (cellLegend && hasPerCellLegends) {
                // Check for standard legend-item format first, then inline span format (demographics)
                let legendItems = cellLegend.querySelectorAll('.legend-item');
                let itemData = [];
                
                if (legendItems.length > 0) {
                    // Standard format with .legend-item and .legend-color
                    ctx.font = '8px "DM Sans", sans-serif';
                    legendItems.forEach(item => {
                        const colorBox = item.querySelector('.legend-color');
                        const bgColor = colorBox?.style?.backgroundColor || '#58a6ff';
                        let label = item.textContent.trim();
                        // Strip parenthetical suffixes
                        label = label.replace(/\s*\([^)]*\)\s*$/, '').trim();
                        const textWidth = ctx.measureText(label).width;
                        itemData.push({ bgColor, label, textWidth });
                    });
                } else {
                    // Demographics/Experience format - inline spans with color boxes
                    const spans = cellLegend.querySelectorAll('span[style*="display:flex"]');
                    ctx.font = '8px "DM Sans", sans-serif';
                    spans.forEach(span => {
                        const colorSpan = span.querySelector('span[style*="background"]');
                        let bgColor = '#58a6ff';
                        if (colorSpan) {
                            const styleAttr = colorSpan.getAttribute('style') || '';
                            const bgMatch = styleAttr.match(/background:\s*([^;]+)/i);
                            if (bgMatch) bgColor = bgMatch[1].trim();
                        }
                        // Get text (excluding color box text)
                        let label = span.textContent.trim();
                        label = label.replace(/\s*\([^)]*\)\s*$/, '').trim();
                        const textWidth = ctx.measureText(label).width;
                        itemData.push({ bgColor, label, textWidth });
                    });
                }
                
                if (itemData.length > 0) {
                    // Calculate if we need multi-line legend
                    const itemSpacing = 10 + 3 + 6;  // color box + gaps
                    let totalWidth = 0;
                    itemData.forEach(({ textWidth }) => {
                        totalWidth += itemSpacing + textWidth;
                    });
                    totalWidth -= 6;
                    
                    const maxLineWidth = cellWidth - 20;
                    const needsMultiLine = totalWidth > maxLineWidth;
                    
                    if (needsMultiLine) {
                        // Split into multiple lines
                        let lines = [[]];
                        let currentLineWidth = 0;
                        
                        itemData.forEach(item => {
                            const itemWidth = itemSpacing + item.textWidth;
                            if (currentLineWidth + itemWidth > maxLineWidth && lines[lines.length - 1].length > 0) {
                                lines.push([]);
                                currentLineWidth = 0;
                            }
                            lines[lines.length - 1].push(item);
                            currentLineWidth += itemWidth;
                        });
                        
                        // Draw each line
                        const lineHeight = 14;
                        const startY = currentY + 4;
                        
                        lines.forEach((lineItems, lineIdx) => {
                            let lineWidth = 0;
                            lineItems.forEach(({ textWidth }) => {
                                lineWidth += itemSpacing + textWidth;
                            });
                            lineWidth -= 6;
                            
                            let legX = cellX + (cellWidth - lineWidth) / 2;
                            const legY = startY + lineIdx * lineHeight;
                            
                            lineItems.forEach(({ bgColor, label, textWidth }) => {
                                ctx.fillStyle = bgColor;
                                ctx.fillRect(legX, legY, 8, 8);
                                ctx.fillStyle = '#c9d1d9';
                                ctx.fillText(label, legX + 11, legY + 7);
                                legX += itemSpacing + textWidth;
                            });
                        });
                    } else {
                        // Single line legend
                        let legX = cellX + (cellWidth - totalWidth) / 2;
                        const legY = currentY + perCellLegendHeight - 12;
                        
                        itemData.forEach(({ bgColor, label, textWidth }) => {
                            ctx.fillStyle = bgColor;
                            ctx.fillRect(legX, legY, 8, 8);
                            ctx.fillStyle = '#c9d1d9';
                            ctx.fillText(label, legX + 11, legY + 7);
                            legX += itemSpacing + textWidth;
                        });
                    }
                }
                currentY += perCellLegendHeight;  // Advance by the allocated space
            }
            
            // Draw chart centered below title/legend area
            const canvas = cell.querySelector('canvas');
            if (canvas) {
                const chartY = currentY + chartTopPadding;
                const maxChartW = cellWidth - 12;
                const maxChartH = chartHeight - 6;
                // Use higher scale factor for large demographics donuts
                const scaleFactor = isDemographicsLargeDonuts ? 0.98 : 0.94;
                const scale = Math.min(maxChartW / canvas.width, maxChartH / canvas.height) * scaleFactor;
                const w = canvas.width * scale, h = canvas.height * scale;
                ctx.drawImage(canvas, cellX + (cellWidth - w) / 2, chartY + (chartHeight - h) / 2, w, h);
            }
        });
        
        yPos += Math.ceil(chartCells.length / cols) * cellHeight;
        
        // Render special demo sections (employment, country, education topic bar charts) if present
        if (hasSpecialDemoSections) {
            specialDemoSections.forEach(section => {
                const title = section.querySelector('h4')?.textContent?.trim() || '';
                const canvas = section.querySelector('canvas');
                
                if (canvas) {
                    // Draw section title
                    ctx.fillStyle = '#8b949e';
                    ctx.font = '14px "DM Sans", sans-serif';
                    ctx.textAlign = 'center';
                    ctx.fillText(title, baseWidth / 2, yPos + 18);
                    ctx.textAlign = 'left';
                    yPos += 30;
                    
                    // Draw the bar chart, scaled to fit width
                    const maxWidth = baseWidth - padding * 2;
                    const scale = Math.min(maxWidth / canvas.width, 1);
                    const w = canvas.width * scale;
                    const h = canvas.height * scale;
                    const x = padding + (maxWidth - w) / 2;
                    
                    ctx.drawImage(canvas, x, yPos, w, h);
                    yPos += h + 15;  // Reduced spacing
                }
            });
        }
        
    } else {
        // Check if this is Entity Combined Mean mode with multiple scatter charts
        const splitScatters = chartArea.querySelectorAll('canvas[id^="split-scatter-"]');
        const splitColumnHeaders = chartArea.querySelectorAll('.split-column-header');
        
        if (splitScatters.length > 0 && splitColumnHeaders.length > 0) {
            // ENTITY COMBINED MEAN MODE - Multiple scatter plots in grid
            const numSplits = splitScatters.length;
            const numCols = numSplits >= 5 ? 3 : numSplits;
            const numRows = Math.ceil(numSplits / numCols);
            const colWidth = (baseWidth - padding * 2) / numCols;
            const rowHeight = 300;
            const headerBarHeight = 50;
            
            // Sort scatter canvases by index
            const sortedScatters = Array.from(splitScatters).sort((a, b) => {
                const idxA = parseInt(a.id.replace('split-scatter-', ''));
                const idxB = parseInt(b.id.replace('split-scatter-', ''));
                return idxA - idxB;
            });
            
            // Sort headers too
            const sortedHeaders = Array.from(splitColumnHeaders);
            
            // Draw each scatter plot
            sortedScatters.forEach((canvas, idx) => {
                const col = idx % numCols;
                const row = Math.floor(idx / numCols);
                const cellX = padding + col * colWidth;
                const cellY = yPos + row * (rowHeight + headerBarHeight + 15);
                
                // Get corresponding header
                const header = sortedHeaders[idx];
                const bgColor = getHeaderBgColor(header);
                const headerText = header?.textContent?.replace(/\n/g, ' ').trim() || '';
                
                // Draw header
                ctx.fillStyle = bgColor;
                ctx.fillRect(cellX + 5, cellY, colWidth - 10, headerBarHeight);
                
                ctx.fillStyle = isLightColor(bgColor) ? '#1a1a2e' : '#ffffff';
                ctx.font = '12px "DM Sans", sans-serif';
                ctx.textAlign = 'center';
                const parts = headerText.split(/N=/);
                ctx.fillText(parts[0].trim(), cellX + colWidth / 2, cellY + 18);
                if (parts[1]) {
                    ctx.font = '11px "DM Sans", sans-serif';
                    ctx.fillText('N=' + parts[1].trim(), cellX + colWidth / 2, cellY + 35);
                }
                ctx.textAlign = 'left';
                
                // Draw scatter chart
                const chartY = cellY + headerBarHeight + 5;
                const chartSpace = colWidth - 20;
                const scale = Math.min(chartSpace / canvas.width, (rowHeight - 10) / canvas.height);
                const w = canvas.width * scale;
                const h = canvas.height * scale;
                ctx.drawImage(canvas, cellX + (colWidth - w) / 2, chartY, w, h);
            });
            
            yPos += numRows * (rowHeight + headerBarHeight + 15);
            
        } else if (hasSpecialDemoSections && !chartGrid) {
            // SPECIAL DEMO SECTIONS ONLY (employment/country without other demographics)
            specialDemoSections.forEach(section => {
                const title = section.querySelector('h4')?.textContent?.trim() || '';
                const canvas = section.querySelector('canvas');
                
                if (canvas) {
                    // Draw section title
                    ctx.fillStyle = '#8b949e';
                    ctx.font = '14px "DM Sans", sans-serif';
                    ctx.textAlign = 'center';
                    ctx.fillText(title, baseWidth / 2, yPos + 18);
                    ctx.textAlign = 'left';
                    yPos += 30;
                    
                    // Draw the bar chart, scaled to fit width
                    const maxWidth = baseWidth - padding * 2;
                    const scale = Math.min(maxWidth / canvas.width, 1);
                    const w = canvas.width * scale;
                    const h = canvas.height * scale;
                    const x = padding + (maxWidth - w) / 2;
                    
                    ctx.drawImage(canvas, x, yPos, w, h);
                    yPos += h + 15;  // Reduced spacing
                }
            });
            
        } else {
            // SINGLE CHART
            const canvas = canvases[0];
            if (canvas) {
                const isEntityCombined = currentCategory === 'combined_attr';
                const scaleFactor = isEntityCombined ? 1.25 : 1.05;
                
                const legendSpace = legendRowsNeeded * 25 + 15;
                const maxW = baseWidth - padding * 2;
                const maxH = baseHeight - yPos - attributionHeight - legendSpace - 10;
                const scale = Math.min(maxW / canvas.width, maxH / canvas.height, scaleFactor);
                const w = canvas.width * scale, h = canvas.height * scale;
                
                ctx.drawImage(canvas, padding + (baseWidth - padding * 2 - w) / 2, yPos, w, h);
                yPos += h + 15;
            }
        }
    }
    
    // Draw global legend with wrapping (but skip if per-cell legends were drawn)
    // First check global legend area, then fall back to per-cell legends if needed
    let effectiveLegendItems = legendItems;
    let skipGlobalLegend = false;
    
    // If grid view has per-cell legends, skip the global legend to avoid redundancy
    if (chartGrid && chartCells.length > 0) {
        const hasPerCellLegends = !!chartCells[0]?.querySelector('.chart-cell-legend');
        if (hasPerCellLegends) {
            skipGlobalLegend = true;
        }
    }
    
    if (!skipGlobalLegend && effectiveLegendItems.length > 0) {
        let legX = padding;
        let legY = yPos + 10;  // Position relative to content
        ctx.font = '12px "DM Sans", sans-serif';
        
        effectiveLegendItems.forEach(item => {
            const colorBox = item.querySelector('.legend-color');
            const bgColor = colorBox?.style?.backgroundColor || '#58a6ff';
            let label = item.textContent.trim();
            // Strip parenthetical suffixes
            label = label.replace(/\s*\([^)]*\)\s*$/, '').trim();
            const itemWidth = ctx.measureText(label).width + 32;
            
            // Wrap to next line if needed
            if (legX + itemWidth > baseWidth - padding && legX > padding) {
                legX = padding;
                legY += 22;
            }
            
            ctx.fillStyle = bgColor;
            ctx.fillRect(legX, legY, 12, 12);
            ctx.fillStyle = '#c9d1d9';
            ctx.fillText(label, legX + 16, legY + 10);
            legX += itemWidth;
        });
        yPos = legY + 25;  // Update yPos after legend
    }
    
    // Draw attribution - always at bottom left corner with consistent size
    ctx.fillStyle = '#6e7681';
    ctx.font = '11px "DM Sans", sans-serif';
    ctx.fillText('© 2025 ronyhirsch.github.io/minds-matter — Use with attribution: doi.org/10.17605/OSF.IO/XXXXX', padding, baseHeight - 15);
    
    // Generate filename
    let filenameParts = ['minds-matter'];
    
    // Special handling for combined_attr
    if (currentCategory === 'combined_attr') {
        filenameParts.push('attributions-combined');
        if (entityNames.length === 1) {
            filenameParts.push(entityNames[0].toLowerCase().replace(/[^a-z0-9]+/g, '-'));
        } else if (entityNames.length > 1) {
            filenameParts.push(`${entityNames.length}-entities`);
        }
    } else if (entityNames.length === 1) {
        filenameParts.push(entityNames[0].toLowerCase().replace(/[^a-z0-9]+/g, '-'));
    } else if (entityNames.length > 1) {
        filenameParts.push(topicName.toLowerCase().replace(/[^a-z0-9]+/g, '-'));
        filenameParts.push(`${entityNames.length}-entities`);
    } else if (questionNames.length === 1) {
        // Single question/variable - use the question name
        filenameParts.push(questionNames[0].toLowerCase().replace(/[^a-z0-9]+/g, '-').substring(0, 40));
    } else if (questionNames.length > 1) {
        // Multiple questions - for demographics/experience use topic + count, same as attributions
        if (currentCategory === 'demo') {
            filenameParts.push('demographics');
            filenameParts.push(`${questionNames.length}-variables`);
        } else if (currentCategory === 'exp_sources') {
            filenameParts.push('experience-domains');
            filenameParts.push(`${questionNames.length}-variables`);
        } else {
            filenameParts.push(topicName.toLowerCase().replace(/[^a-z0-9]+/g, '-'));
            filenameParts.push(`${questionNames.length}-variables`);
        }
    } else {
        filenameParts.push(topicName.toLowerCase().replace(/[^a-z0-9]+/g, '-'));
    }
    
    if (splitBySample && splitBySource) filenameParts.push('split-both');
    else if (splitBySample) filenameParts.push('split-sample');
    else if (splitBySource) filenameParts.push('split-recruitment');
    else if (splitByCluster) filenameParts.push('split-cluster');
    
    const filename = filenameParts.join('_').replace(/-+/g, '-').replace(/_+/g, '_').replace(/^[-_]+|[-_]+$/g, '') + '.png';
    
    const link = document.createElement('a');
    link.download = filename;
    link.href = tempCanvas.toDataURL('image/png');
    link.click();
}

// Download a single entity's scatter plot (for split views)
function downloadEntityScatter(entityIdx, entityShort, splitPart) {
    const canvas = document.getElementById(`entity-scatter-${entityIdx}`);
    if (!canvas) return;
    
    const section = canvas.closest('.entity-scatter-section');
    const legendBar = section?.querySelector('.legend-bar');
    
    // DPI scale for high resolution
    const DPI_SCALE = 2;
    
    // Dimensions
    const padding = 30;
    const headerHeight = 35;
    const titleHeight = 35;
    const legendHeight = 35;
    const attributionHeight = 35;
    
    const chartWidth = canvas.width;
    const chartHeight = canvas.height;
    const scaleFactor = 1.2;
    
    const baseWidth = Math.max(700, chartWidth * scaleFactor + padding * 2);
    const baseHeight = padding + headerHeight + titleHeight + legendHeight + (chartHeight * scaleFactor) + attributionHeight;
    
    // Create canvas
    const tempCanvas = document.createElement('canvas');
    tempCanvas.width = baseWidth * DPI_SCALE;
    tempCanvas.height = baseHeight * DPI_SCALE;
    const ctx = tempCanvas.getContext('2d');
    ctx.scale(DPI_SCALE, DPI_SCALE);
    
    // Fill background
    ctx.fillStyle = '#0d1117';
    ctx.fillRect(0, 0, baseWidth, baseHeight);
    
    // Get N and filter info
    const distTitle = document.getElementById('dist-title');
    const nMatch = distTitle?.innerHTML?.match(/N=(\d+)/);
    const nValue = nMatch ? nMatch[1] : '?';
    
    const filterBox = document.getElementById('sample-filter-box');
    let filterParts = [];
    filterBox?.querySelectorAll('.filter-group input:checked')?.forEach(cb => {
        const label = cb.nextElementSibling?.textContent?.trim();
        if (label && label !== 'All' && !label.includes('no filter')) filterParts.push(label);
    });
    const filterText = filterParts.length > 0 ? filterParts.join(' + ') : 'All respondents';
    const splitLabel = splitPart.replace('split-', 'Split by ').replace('-', ' ');
    const fullFilterText = filterText + ' + ' + splitLabel.charAt(0).toUpperCase() + splitLabel.slice(1);
    
    // Draw header
    let yPos = padding;
    ctx.fillStyle = '#e6edf3';
    ctx.font = 'bold 18px "DM Sans", sans-serif';
    ctx.fillText(`N=${nValue}`, padding, yPos + 18);
    
    ctx.font = '14px "DM Sans", sans-serif';
    ctx.fillStyle = '#8b949e';
    ctx.fillText(`Filter: ${fullFilterText}`, padding + ctx.measureText(`N=${nValue}`).width + 25, yPos + 18);
    
    yPos += headerHeight;
    
    // Draw title
    ctx.fillStyle = '#e6edf3';
    ctx.font = 'bold 18px "DM Sans", sans-serif';
    ctx.fillText(`Entity Combined Attributions: ${entityShort}`, padding, yPos + 20);
    
    yPos += titleHeight;
    
    // Draw legend
    if (legendBar) {
        const legendItems = legendBar.querySelectorAll('.legend-item');
        let legX = padding;
        ctx.font = '13px "DM Sans", sans-serif';
        
        legendItems.forEach(item => {
            const colorBox = item.querySelector('.legend-color');
            const bgColor = colorBox?.style?.backgroundColor || '#58a6ff';
            const label = item.textContent.trim();
            
            ctx.fillStyle = bgColor;
            ctx.fillRect(legX, yPos, 14, 14);
            ctx.fillStyle = '#c9d1d9';
            ctx.fillText(label, legX + 20, yPos + 12);
            legX += ctx.measureText(label).width + 50;
        });
    }
    
    yPos += legendHeight;
    
    // Draw chart
    const maxW = baseWidth - padding * 2;
    const maxH = baseHeight - yPos - attributionHeight - 10;
    const scale = Math.min(maxW / canvas.width, maxH / canvas.height, scaleFactor);
    const w = canvas.width * scale, h = canvas.height * scale;
    ctx.drawImage(canvas, padding + (baseWidth - padding * 2 - w) / 2, yPos, w, h);
    
    // Draw attribution
    ctx.fillStyle = '#6e7681';
    ctx.font = '12px "DM Sans", sans-serif';
    ctx.fillText('© 2025 ronyhirsch.github.io/minds-matter — Use with attribution: doi.org/10.17605/OSF.IO/XXXXX', padding, baseHeight - 12);
    
    // Generate filename
    const entityPart = entityShort.toLowerCase().replace(/[^a-z0-9]+/g, '-');
    const filename = `minds-matter_attributions-combined_${entityPart}_${splitPart}.png`;
    
    // Download
    const link = document.createElement('a');
    link.download = filename;
    link.href = tempCanvas.toDataURL('image/png');
    link.click();
}

// Show/hide download button based on chart presence
function updateDownloadButton() {
    const btn = document.getElementById('download-chart-btn');
    const chartArea = document.getElementById('dist-chart-area');
    if (btn && chartArea) {
        const hasCharts = chartArea.querySelectorAll('canvas').length > 0;
        // Don't show main button if per-entity download buttons are present
        const hasEntityButtons = chartArea.querySelectorAll('.download-entity-btn').length > 0;
        btn.style.display = (hasCharts && !hasEntityButtons) ? 'block' : 'none';
    }
}

document.addEventListener('DOMContentLoaded', loadData);
</script>
</body>
</html>
